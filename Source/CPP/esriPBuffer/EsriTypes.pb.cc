// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: esriPBuffer/EsriTypes.proto

#include "esriPBuffer/EsriTypes.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_Scale_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_Translate_esriPBuffer_2fEsriTypes_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_esriPBuffer_2fEsriTypes_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto;
namespace esriPBuffer {
class EsriTypes_ScaleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_Scale> _instance;
} _EsriTypes_Scale_default_instance_;
class EsriTypes_TranslateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_Translate> _instance;
} _EsriTypes_Translate_default_instance_;
class EsriTypes_TransformDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_Transform> _instance;
} _EsriTypes_Transform_default_instance_;
class EsriTypes_QuantizationParametersDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_QuantizationParameters> _instance;
} _EsriTypes_QuantizationParameters_default_instance_;
class EsriTypes_SpatialReferenceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_SpatialReference> _instance;
} _EsriTypes_SpatialReference_default_instance_;
class EsriTypes_FieldIndexDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_FieldIndex> _instance;
} _EsriTypes_FieldIndex_default_instance_;
class EsriTypes_ValueDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_Value> _instance;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
  float float_value_;
  double double_value_;
  ::PROTOBUF_NAMESPACE_ID::int32 sint_value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uint_value_;
  ::PROTOBUF_NAMESPACE_ID::int64 int64_value_;
  ::PROTOBUF_NAMESPACE_ID::uint64 uint64_value_;
  ::PROTOBUF_NAMESPACE_ID::int64 sint64_value_;
  bool bool_value_;
} _EsriTypes_Value_default_instance_;
class EsriTypes_EnvelopeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_Envelope> _instance;
} _EsriTypes_Envelope_default_instance_;
class EsriTypes_CodedValueDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_CodedValue> _instance;
} _EsriTypes_CodedValue_default_instance_;
class EsriTypes_CodedValueDomainDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_CodedValueDomain> _instance;
} _EsriTypes_CodedValueDomain_default_instance_;
class EsriTypes_RangeDomainDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_RangeDomain> _instance;
} _EsriTypes_RangeDomain_default_instance_;
class EsriTypes_DomainDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_Domain> _instance;
  const ::esriPBuffer::EsriTypes_CodedValueDomain* codedvaluedomain_;
  const ::esriPBuffer::EsriTypes_RangeDomain* rangedomain_;
} _EsriTypes_Domain_default_instance_;
class EsriTypes_DatumTransformationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes_DatumTransformation> _instance;
} _EsriTypes_DatumTransformation_default_instance_;
class EsriTypesDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EsriTypes> _instance;
} _EsriTypes_default_instance_;
}  // namespace esriPBuffer
static void InitDefaultsscc_info_EsriTypes_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EsriTypes_esriPBuffer_2fEsriTypes_2eproto}, {}};

static void InitDefaultsscc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_CodedValue_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_CodedValue();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_CodedValue::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_CodedValueDomain_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_CodedValueDomain();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_CodedValueDomain::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_DatumTransformation_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_DatumTransformation_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_DatumTransformation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_DatumTransformation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_DatumTransformation_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EsriTypes_DatumTransformation_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_Domain_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_Domain_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_Domain();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_Domain::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_EsriTypes_Domain_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_EsriTypes_Domain_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto.base,
      &scc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_Envelope_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_Envelope();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_Envelope::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_FieldIndex_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_FieldIndex_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_FieldIndex();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_FieldIndex::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_FieldIndex_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EsriTypes_FieldIndex_esriPBuffer_2fEsriTypes_2eproto}, {}};

static void InitDefaultsscc_info_EsriTypes_QuantizationParameters_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_QuantizationParameters_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_QuantizationParameters();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_QuantizationParameters::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_QuantizationParameters_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EsriTypes_QuantizationParameters_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_RangeDomain_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_RangeDomain();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_RangeDomain::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_Scale_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_Scale_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_Scale();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_Scale::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_Scale_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EsriTypes_Scale_esriPBuffer_2fEsriTypes_2eproto}, {}};

static void InitDefaultsscc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_SpatialReference_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_SpatialReference();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_SpatialReference::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto}, {}};

static void InitDefaultsscc_info_EsriTypes_Transform_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_Transform_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_Transform();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_Transform::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_EsriTypes_Transform_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_EsriTypes_Transform_esriPBuffer_2fEsriTypes_2eproto}, {
      &scc_info_EsriTypes_Scale_esriPBuffer_2fEsriTypes_2eproto.base,
      &scc_info_EsriTypes_Translate_esriPBuffer_2fEsriTypes_2eproto.base,}};

static void InitDefaultsscc_info_EsriTypes_Translate_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_Translate_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_Translate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_Translate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_Translate_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EsriTypes_Translate_esriPBuffer_2fEsriTypes_2eproto}, {}};

static void InitDefaultsscc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::esriPBuffer::_EsriTypes_Value_default_instance_;
    new (ptr) ::esriPBuffer::EsriTypes_Value();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::esriPBuffer::EsriTypes_Value::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto}, {}};

namespace esriPBuffer {
bool EsriTypes_GeometryType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_GeometryType_strings[6] = {};

static const char EsriTypes_GeometryType_names[] =
  "esriGeometryTypeEnvelope"
  "esriGeometryTypeMultipatch"
  "esriGeometryTypeMultipoint"
  "esriGeometryTypePoint"
  "esriGeometryTypePolygon"
  "esriGeometryTypePolyline";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_GeometryType_entries[] = {
  { {EsriTypes_GeometryType_names + 0, 24}, 5 },
  { {EsriTypes_GeometryType_names + 24, 26}, 4 },
  { {EsriTypes_GeometryType_names + 50, 26}, 1 },
  { {EsriTypes_GeometryType_names + 76, 21}, 0 },
  { {EsriTypes_GeometryType_names + 97, 23}, 3 },
  { {EsriTypes_GeometryType_names + 120, 24}, 2 },
};

static const int EsriTypes_GeometryType_entries_by_number[] = {
  3, // 0 -> esriGeometryTypePoint
  2, // 1 -> esriGeometryTypeMultipoint
  5, // 2 -> esriGeometryTypePolyline
  4, // 3 -> esriGeometryTypePolygon
  1, // 4 -> esriGeometryTypeMultipatch
  0, // 5 -> esriGeometryTypeEnvelope
};

const std::string& EsriTypes_GeometryType_Name(
    EsriTypes_GeometryType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_GeometryType_entries,
          EsriTypes_GeometryType_entries_by_number,
          6, EsriTypes_GeometryType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_GeometryType_entries,
      EsriTypes_GeometryType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_GeometryType_strings[idx].get();
}
bool EsriTypes_GeometryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_GeometryType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_GeometryType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_GeometryType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_GeometryType EsriTypes::esriGeometryTypePoint;
constexpr EsriTypes_GeometryType EsriTypes::esriGeometryTypeMultipoint;
constexpr EsriTypes_GeometryType EsriTypes::esriGeometryTypePolyline;
constexpr EsriTypes_GeometryType EsriTypes::esriGeometryTypePolygon;
constexpr EsriTypes_GeometryType EsriTypes::esriGeometryTypeMultipatch;
constexpr EsriTypes_GeometryType EsriTypes::esriGeometryTypeEnvelope;
constexpr EsriTypes_GeometryType EsriTypes::GeometryType_MIN;
constexpr EsriTypes_GeometryType EsriTypes::GeometryType_MAX;
constexpr int EsriTypes::GeometryType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EsriTypes_esriSpatialRel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_esriSpatialRel_strings[8] = {};

static const char EsriTypes_esriSpatialRel_names[] =
  "esriSpatialRelContains"
  "esriSpatialRelCrosses"
  "esriSpatialRelEnvelopeIntersects"
  "esriSpatialRelIndexIntersects"
  "esriSpatialRelIntersects"
  "esriSpatialRelOverlaps"
  "esriSpatialRelTouches"
  "esriSpatialRelWithin";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_esriSpatialRel_entries[] = {
  { {EsriTypes_esriSpatialRel_names + 0, 22}, 1 },
  { {EsriTypes_esriSpatialRel_names + 22, 21}, 2 },
  { {EsriTypes_esriSpatialRel_names + 43, 32}, 3 },
  { {EsriTypes_esriSpatialRel_names + 75, 29}, 4 },
  { {EsriTypes_esriSpatialRel_names + 104, 24}, 0 },
  { {EsriTypes_esriSpatialRel_names + 128, 22}, 5 },
  { {EsriTypes_esriSpatialRel_names + 150, 21}, 6 },
  { {EsriTypes_esriSpatialRel_names + 171, 20}, 7 },
};

static const int EsriTypes_esriSpatialRel_entries_by_number[] = {
  4, // 0 -> esriSpatialRelIntersects
  0, // 1 -> esriSpatialRelContains
  1, // 2 -> esriSpatialRelCrosses
  2, // 3 -> esriSpatialRelEnvelopeIntersects
  3, // 4 -> esriSpatialRelIndexIntersects
  5, // 5 -> esriSpatialRelOverlaps
  6, // 6 -> esriSpatialRelTouches
  7, // 7 -> esriSpatialRelWithin
};

const std::string& EsriTypes_esriSpatialRel_Name(
    EsriTypes_esriSpatialRel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_esriSpatialRel_entries,
          EsriTypes_esriSpatialRel_entries_by_number,
          8, EsriTypes_esriSpatialRel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_esriSpatialRel_entries,
      EsriTypes_esriSpatialRel_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_esriSpatialRel_strings[idx].get();
}
bool EsriTypes_esriSpatialRel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_esriSpatialRel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_esriSpatialRel_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_esriSpatialRel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelIntersects;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelContains;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelCrosses;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelEnvelopeIntersects;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelIndexIntersects;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelOverlaps;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelTouches;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRelWithin;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRel_MIN;
constexpr EsriTypes_esriSpatialRel EsriTypes::esriSpatialRel_MAX;
constexpr int EsriTypes::esriSpatialRel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EsriTypes_esriFeatureEncoding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_esriFeatureEncoding_strings[3] = {};

static const char EsriTypes_esriFeatureEncoding_names[] =
  "esriCompressedShapeBuffer"
  "esriDefault"
  "esriFeatureEncoding_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_esriFeatureEncoding_entries[] = {
  { {EsriTypes_esriFeatureEncoding_names + 0, 25}, 2 },
  { {EsriTypes_esriFeatureEncoding_names + 25, 11}, 1 },
  { {EsriTypes_esriFeatureEncoding_names + 36, 31}, 0 },
};

static const int EsriTypes_esriFeatureEncoding_entries_by_number[] = {
  2, // 0 -> esriFeatureEncoding_UNSPECIFIED
  1, // 1 -> esriDefault
  0, // 2 -> esriCompressedShapeBuffer
};

const std::string& EsriTypes_esriFeatureEncoding_Name(
    EsriTypes_esriFeatureEncoding value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_esriFeatureEncoding_entries,
          EsriTypes_esriFeatureEncoding_entries_by_number,
          3, EsriTypes_esriFeatureEncoding_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_esriFeatureEncoding_entries,
      EsriTypes_esriFeatureEncoding_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_esriFeatureEncoding_strings[idx].get();
}
bool EsriTypes_esriFeatureEncoding_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_esriFeatureEncoding* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_esriFeatureEncoding_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_esriFeatureEncoding>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_esriFeatureEncoding EsriTypes::esriFeatureEncoding_UNSPECIFIED;
constexpr EsriTypes_esriFeatureEncoding EsriTypes::esriDefault;
constexpr EsriTypes_esriFeatureEncoding EsriTypes::esriCompressedShapeBuffer;
constexpr EsriTypes_esriFeatureEncoding EsriTypes::esriFeatureEncoding_MIN;
constexpr EsriTypes_esriFeatureEncoding EsriTypes::esriFeatureEncoding_MAX;
constexpr int EsriTypes::esriFeatureEncoding_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EsriTypes_MergePolicyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_MergePolicyType_strings[4] = {};

static const char EsriTypes_MergePolicyType_names[] =
  "esriMergePolicyTypeAreaWeighted"
  "esriMergePolicyTypeDefaultValue"
  "esriMergePolicyTypeSumValues"
  "esriMergePolicyType_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_MergePolicyType_entries[] = {
  { {EsriTypes_MergePolicyType_names + 0, 31}, 2 },
  { {EsriTypes_MergePolicyType_names + 31, 31}, 3 },
  { {EsriTypes_MergePolicyType_names + 62, 28}, 1 },
  { {EsriTypes_MergePolicyType_names + 90, 31}, 0 },
};

static const int EsriTypes_MergePolicyType_entries_by_number[] = {
  3, // 0 -> esriMergePolicyType_UNSPECIFIED
  2, // 1 -> esriMergePolicyTypeSumValues
  0, // 2 -> esriMergePolicyTypeAreaWeighted
  1, // 3 -> esriMergePolicyTypeDefaultValue
};

const std::string& EsriTypes_MergePolicyType_Name(
    EsriTypes_MergePolicyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_MergePolicyType_entries,
          EsriTypes_MergePolicyType_entries_by_number,
          4, EsriTypes_MergePolicyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_MergePolicyType_entries,
      EsriTypes_MergePolicyType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_MergePolicyType_strings[idx].get();
}
bool EsriTypes_MergePolicyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_MergePolicyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_MergePolicyType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_MergePolicyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_MergePolicyType EsriTypes::esriMergePolicyType_UNSPECIFIED;
constexpr EsriTypes_MergePolicyType EsriTypes::esriMergePolicyTypeSumValues;
constexpr EsriTypes_MergePolicyType EsriTypes::esriMergePolicyTypeAreaWeighted;
constexpr EsriTypes_MergePolicyType EsriTypes::esriMergePolicyTypeDefaultValue;
constexpr EsriTypes_MergePolicyType EsriTypes::MergePolicyType_MIN;
constexpr EsriTypes_MergePolicyType EsriTypes::MergePolicyType_MAX;
constexpr int EsriTypes::MergePolicyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EsriTypes_SplitPolicyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_SplitPolicyType_strings[4] = {};

static const char EsriTypes_SplitPolicyType_names[] =
  "esriSplitPolicyTypeDefaultValue"
  "esriSplitPolicyTypeDuplicate"
  "esriSplitPolicyTypeGeometryRatio"
  "esriSplitPolicyType_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_SplitPolicyType_entries[] = {
  { {EsriTypes_SplitPolicyType_names + 0, 31}, 3 },
  { {EsriTypes_SplitPolicyType_names + 31, 28}, 2 },
  { {EsriTypes_SplitPolicyType_names + 59, 32}, 1 },
  { {EsriTypes_SplitPolicyType_names + 91, 31}, 0 },
};

static const int EsriTypes_SplitPolicyType_entries_by_number[] = {
  3, // 0 -> esriSplitPolicyType_UNSPECIFIED
  2, // 1 -> esriSplitPolicyTypeGeometryRatio
  1, // 2 -> esriSplitPolicyTypeDuplicate
  0, // 3 -> esriSplitPolicyTypeDefaultValue
};

const std::string& EsriTypes_SplitPolicyType_Name(
    EsriTypes_SplitPolicyType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_SplitPolicyType_entries,
          EsriTypes_SplitPolicyType_entries_by_number,
          4, EsriTypes_SplitPolicyType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_SplitPolicyType_entries,
      EsriTypes_SplitPolicyType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_SplitPolicyType_strings[idx].get();
}
bool EsriTypes_SplitPolicyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_SplitPolicyType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_SplitPolicyType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_SplitPolicyType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_SplitPolicyType EsriTypes::esriSplitPolicyType_UNSPECIFIED;
constexpr EsriTypes_SplitPolicyType EsriTypes::esriSplitPolicyTypeGeometryRatio;
constexpr EsriTypes_SplitPolicyType EsriTypes::esriSplitPolicyTypeDuplicate;
constexpr EsriTypes_SplitPolicyType EsriTypes::esriSplitPolicyTypeDefaultValue;
constexpr EsriTypes_SplitPolicyType EsriTypes::SplitPolicyType_MIN;
constexpr EsriTypes_SplitPolicyType EsriTypes::SplitPolicyType_MAX;
constexpr int EsriTypes::SplitPolicyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EsriTypes_QuantizeOriginPostion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_QuantizeOriginPostion_strings[2] = {};

static const char EsriTypes_QuantizeOriginPostion_names[] =
  "lowerLeft"
  "upperLeft";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_QuantizeOriginPostion_entries[] = {
  { {EsriTypes_QuantizeOriginPostion_names + 0, 9}, 1 },
  { {EsriTypes_QuantizeOriginPostion_names + 9, 9}, 0 },
};

static const int EsriTypes_QuantizeOriginPostion_entries_by_number[] = {
  1, // 0 -> upperLeft
  0, // 1 -> lowerLeft
};

const std::string& EsriTypes_QuantizeOriginPostion_Name(
    EsriTypes_QuantizeOriginPostion value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_QuantizeOriginPostion_entries,
          EsriTypes_QuantizeOriginPostion_entries_by_number,
          2, EsriTypes_QuantizeOriginPostion_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_QuantizeOriginPostion_entries,
      EsriTypes_QuantizeOriginPostion_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_QuantizeOriginPostion_strings[idx].get();
}
bool EsriTypes_QuantizeOriginPostion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_QuantizeOriginPostion* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_QuantizeOriginPostion_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_QuantizeOriginPostion>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_QuantizeOriginPostion EsriTypes::upperLeft;
constexpr EsriTypes_QuantizeOriginPostion EsriTypes::lowerLeft;
constexpr EsriTypes_QuantizeOriginPostion EsriTypes::QuantizeOriginPostion_MIN;
constexpr EsriTypes_QuantizeOriginPostion EsriTypes::QuantizeOriginPostion_MAX;
constexpr int EsriTypes::QuantizeOriginPostion_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
bool EsriTypes_QuantizeMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EsriTypes_QuantizeMode_strings[2] = {};

static const char EsriTypes_QuantizeMode_names[] =
  "edit"
  "view";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EsriTypes_QuantizeMode_entries[] = {
  { {EsriTypes_QuantizeMode_names + 0, 4}, 1 },
  { {EsriTypes_QuantizeMode_names + 4, 4}, 0 },
};

static const int EsriTypes_QuantizeMode_entries_by_number[] = {
  1, // 0 -> view
  0, // 1 -> edit
};

const std::string& EsriTypes_QuantizeMode_Name(
    EsriTypes_QuantizeMode value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EsriTypes_QuantizeMode_entries,
          EsriTypes_QuantizeMode_entries_by_number,
          2, EsriTypes_QuantizeMode_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EsriTypes_QuantizeMode_entries,
      EsriTypes_QuantizeMode_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EsriTypes_QuantizeMode_strings[idx].get();
}
bool EsriTypes_QuantizeMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EsriTypes_QuantizeMode* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EsriTypes_QuantizeMode_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<EsriTypes_QuantizeMode>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr EsriTypes_QuantizeMode EsriTypes::view;
constexpr EsriTypes_QuantizeMode EsriTypes::edit;
constexpr EsriTypes_QuantizeMode EsriTypes::QuantizeMode_MIN;
constexpr EsriTypes_QuantizeMode EsriTypes::QuantizeMode_MAX;
constexpr int EsriTypes::QuantizeMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void EsriTypes_Scale::InitAsDefaultInstance() {
}
class EsriTypes_Scale::_Internal {
 public:
};

EsriTypes_Scale::EsriTypes_Scale(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.Scale)
}
EsriTypes_Scale::EsriTypes_Scale(const EsriTypes_Scale& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&xscale_, &from.xscale_,
    static_cast<size_t>(reinterpret_cast<char*>(&zscale_) -
    reinterpret_cast<char*>(&xscale_)) + sizeof(zscale_));
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.Scale)
}

void EsriTypes_Scale::SharedCtor() {
  ::memset(&xscale_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&zscale_) -
      reinterpret_cast<char*>(&xscale_)) + sizeof(zscale_));
}

EsriTypes_Scale::~EsriTypes_Scale() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.Scale)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_Scale::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EsriTypes_Scale::ArenaDtor(void* object) {
  EsriTypes_Scale* _this = reinterpret_cast< EsriTypes_Scale* >(object);
  (void)_this;
}
void EsriTypes_Scale::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_Scale::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_Scale& EsriTypes_Scale::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_Scale_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_Scale::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.Scale)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&xscale_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&zscale_) -
      reinterpret_cast<char*>(&xscale_)) + sizeof(zscale_));
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_Scale::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // double xScale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          xscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double yScale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          yscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double mScale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          mscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double zScale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          zscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_Scale::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.Scale)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double xScale = 1;
  if (!(this->xscale() <= 0 && this->xscale() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_xscale(), target);
  }

  // double yScale = 2;
  if (!(this->yscale() <= 0 && this->yscale() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_yscale(), target);
  }

  // double mScale = 3;
  if (!(this->mscale() <= 0 && this->mscale() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_mscale(), target);
  }

  // double zScale = 4;
  if (!(this->zscale() <= 0 && this->zscale() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_zscale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.Scale)
  return target;
}

size_t EsriTypes_Scale::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.Scale)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double xScale = 1;
  if (!(this->xscale() <= 0 && this->xscale() >= 0)) {
    total_size += 1 + 8;
  }

  // double yScale = 2;
  if (!(this->yscale() <= 0 && this->yscale() >= 0)) {
    total_size += 1 + 8;
  }

  // double mScale = 3;
  if (!(this->mscale() <= 0 && this->mscale() >= 0)) {
    total_size += 1 + 8;
  }

  // double zScale = 4;
  if (!(this->zscale() <= 0 && this->zscale() >= 0)) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_Scale::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_Scale*>(
      &from));
}

void EsriTypes_Scale::MergeFrom(const EsriTypes_Scale& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.Scale)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.xscale() <= 0 && from.xscale() >= 0)) {
    _internal_set_xscale(from._internal_xscale());
  }
  if (!(from.yscale() <= 0 && from.yscale() >= 0)) {
    _internal_set_yscale(from._internal_yscale());
  }
  if (!(from.mscale() <= 0 && from.mscale() >= 0)) {
    _internal_set_mscale(from._internal_mscale());
  }
  if (!(from.zscale() <= 0 && from.zscale() >= 0)) {
    _internal_set_zscale(from._internal_zscale());
  }
}

void EsriTypes_Scale::CopyFrom(const EsriTypes_Scale& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.Scale)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_Scale::IsInitialized() const {
  return true;
}

void EsriTypes_Scale::InternalSwap(EsriTypes_Scale* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_Scale, zscale_)
      + sizeof(EsriTypes_Scale::zscale_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_Scale, xscale_)>(
          reinterpret_cast<char*>(&xscale_),
          reinterpret_cast<char*>(&other->xscale_));
}

std::string EsriTypes_Scale::GetTypeName() const {
  return "esriPBuffer.EsriTypes.Scale";
}


// ===================================================================

void EsriTypes_Translate::InitAsDefaultInstance() {
}
class EsriTypes_Translate::_Internal {
 public:
};

EsriTypes_Translate::EsriTypes_Translate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.Translate)
}
EsriTypes_Translate::EsriTypes_Translate(const EsriTypes_Translate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&xtranslate_, &from.xtranslate_,
    static_cast<size_t>(reinterpret_cast<char*>(&ztranslate_) -
    reinterpret_cast<char*>(&xtranslate_)) + sizeof(ztranslate_));
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.Translate)
}

void EsriTypes_Translate::SharedCtor() {
  ::memset(&xtranslate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ztranslate_) -
      reinterpret_cast<char*>(&xtranslate_)) + sizeof(ztranslate_));
}

EsriTypes_Translate::~EsriTypes_Translate() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.Translate)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_Translate::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EsriTypes_Translate::ArenaDtor(void* object) {
  EsriTypes_Translate* _this = reinterpret_cast< EsriTypes_Translate* >(object);
  (void)_this;
}
void EsriTypes_Translate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_Translate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_Translate& EsriTypes_Translate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_Translate_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_Translate::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.Translate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&xtranslate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ztranslate_) -
      reinterpret_cast<char*>(&xtranslate_)) + sizeof(ztranslate_));
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_Translate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // double xTranslate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          xtranslate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double yTranslate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          ytranslate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double mTranslate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          mtranslate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double zTranslate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          ztranslate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_Translate::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.Translate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double xTranslate = 1;
  if (!(this->xtranslate() <= 0 && this->xtranslate() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_xtranslate(), target);
  }

  // double yTranslate = 2;
  if (!(this->ytranslate() <= 0 && this->ytranslate() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_ytranslate(), target);
  }

  // double mTranslate = 3;
  if (!(this->mtranslate() <= 0 && this->mtranslate() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_mtranslate(), target);
  }

  // double zTranslate = 4;
  if (!(this->ztranslate() <= 0 && this->ztranslate() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_ztranslate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.Translate)
  return target;
}

size_t EsriTypes_Translate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.Translate)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double xTranslate = 1;
  if (!(this->xtranslate() <= 0 && this->xtranslate() >= 0)) {
    total_size += 1 + 8;
  }

  // double yTranslate = 2;
  if (!(this->ytranslate() <= 0 && this->ytranslate() >= 0)) {
    total_size += 1 + 8;
  }

  // double mTranslate = 3;
  if (!(this->mtranslate() <= 0 && this->mtranslate() >= 0)) {
    total_size += 1 + 8;
  }

  // double zTranslate = 4;
  if (!(this->ztranslate() <= 0 && this->ztranslate() >= 0)) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_Translate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_Translate*>(
      &from));
}

void EsriTypes_Translate::MergeFrom(const EsriTypes_Translate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.Translate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!(from.xtranslate() <= 0 && from.xtranslate() >= 0)) {
    _internal_set_xtranslate(from._internal_xtranslate());
  }
  if (!(from.ytranslate() <= 0 && from.ytranslate() >= 0)) {
    _internal_set_ytranslate(from._internal_ytranslate());
  }
  if (!(from.mtranslate() <= 0 && from.mtranslate() >= 0)) {
    _internal_set_mtranslate(from._internal_mtranslate());
  }
  if (!(from.ztranslate() <= 0 && from.ztranslate() >= 0)) {
    _internal_set_ztranslate(from._internal_ztranslate());
  }
}

void EsriTypes_Translate::CopyFrom(const EsriTypes_Translate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.Translate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_Translate::IsInitialized() const {
  return true;
}

void EsriTypes_Translate::InternalSwap(EsriTypes_Translate* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_Translate, ztranslate_)
      + sizeof(EsriTypes_Translate::ztranslate_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_Translate, xtranslate_)>(
          reinterpret_cast<char*>(&xtranslate_),
          reinterpret_cast<char*>(&other->xtranslate_));
}

std::string EsriTypes_Translate::GetTypeName() const {
  return "esriPBuffer.EsriTypes.Translate";
}


// ===================================================================

void EsriTypes_Transform::InitAsDefaultInstance() {
  ::esriPBuffer::_EsriTypes_Transform_default_instance_._instance.get_mutable()->scale_ = const_cast< ::esriPBuffer::EsriTypes_Scale*>(
      ::esriPBuffer::EsriTypes_Scale::internal_default_instance());
  ::esriPBuffer::_EsriTypes_Transform_default_instance_._instance.get_mutable()->translate_ = const_cast< ::esriPBuffer::EsriTypes_Translate*>(
      ::esriPBuffer::EsriTypes_Translate::internal_default_instance());
}
class EsriTypes_Transform::_Internal {
 public:
  static const ::esriPBuffer::EsriTypes_Scale& scale(const EsriTypes_Transform* msg);
  static const ::esriPBuffer::EsriTypes_Translate& translate(const EsriTypes_Transform* msg);
};

const ::esriPBuffer::EsriTypes_Scale&
EsriTypes_Transform::_Internal::scale(const EsriTypes_Transform* msg) {
  return *msg->scale_;
}
const ::esriPBuffer::EsriTypes_Translate&
EsriTypes_Transform::_Internal::translate(const EsriTypes_Transform* msg) {
  return *msg->translate_;
}
EsriTypes_Transform::EsriTypes_Transform(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.Transform)
}
EsriTypes_Transform::EsriTypes_Transform(const EsriTypes_Transform& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_scale()) {
    scale_ = new ::esriPBuffer::EsriTypes_Scale(*from.scale_);
  } else {
    scale_ = nullptr;
  }
  if (from._internal_has_translate()) {
    translate_ = new ::esriPBuffer::EsriTypes_Translate(*from.translate_);
  } else {
    translate_ = nullptr;
  }
  quantizeoriginpostion_ = from.quantizeoriginpostion_;
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.Transform)
}

void EsriTypes_Transform::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_Transform_esriPBuffer_2fEsriTypes_2eproto.base);
  ::memset(&scale_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&quantizeoriginpostion_) -
      reinterpret_cast<char*>(&scale_)) + sizeof(quantizeoriginpostion_));
}

EsriTypes_Transform::~EsriTypes_Transform() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.Transform)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_Transform::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete scale_;
  if (this != internal_default_instance()) delete translate_;
}

void EsriTypes_Transform::ArenaDtor(void* object) {
  EsriTypes_Transform* _this = reinterpret_cast< EsriTypes_Transform* >(object);
  (void)_this;
}
void EsriTypes_Transform::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_Transform::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_Transform& EsriTypes_Transform::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_Transform_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_Transform::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
  if (GetArena() == nullptr && translate_ != nullptr) {
    delete translate_;
  }
  translate_ = nullptr;
  quantizeoriginpostion_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_Transform::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .esriPBuffer.EsriTypes.QuantizeOriginPostion quantizeOriginPostion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quantizeoriginpostion(static_cast<::esriPBuffer::EsriTypes_QuantizeOriginPostion>(val));
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.Scale scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.Translate translate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_translate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_Transform::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.Transform)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .esriPBuffer.EsriTypes.QuantizeOriginPostion quantizeOriginPostion = 1;
  if (this->quantizeoriginpostion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_quantizeoriginpostion(), target);
  }

  // .esriPBuffer.EsriTypes.Scale scale = 2;
  if (this->has_scale()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::scale(this), target, stream);
  }

  // .esriPBuffer.EsriTypes.Translate translate = 3;
  if (this->has_translate()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::translate(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.Transform)
  return target;
}

size_t EsriTypes_Transform::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.Transform)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .esriPBuffer.EsriTypes.Scale scale = 2;
  if (this->has_scale()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *scale_);
  }

  // .esriPBuffer.EsriTypes.Translate translate = 3;
  if (this->has_translate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *translate_);
  }

  // .esriPBuffer.EsriTypes.QuantizeOriginPostion quantizeOriginPostion = 1;
  if (this->quantizeoriginpostion() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quantizeoriginpostion());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_Transform::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_Transform*>(
      &from));
}

void EsriTypes_Transform::MergeFrom(const EsriTypes_Transform& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.Transform)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_scale()) {
    _internal_mutable_scale()->::esriPBuffer::EsriTypes_Scale::MergeFrom(from._internal_scale());
  }
  if (from.has_translate()) {
    _internal_mutable_translate()->::esriPBuffer::EsriTypes_Translate::MergeFrom(from._internal_translate());
  }
  if (from.quantizeoriginpostion() != 0) {
    _internal_set_quantizeoriginpostion(from._internal_quantizeoriginpostion());
  }
}

void EsriTypes_Transform::CopyFrom(const EsriTypes_Transform& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.Transform)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_Transform::IsInitialized() const {
  return true;
}

void EsriTypes_Transform::InternalSwap(EsriTypes_Transform* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_Transform, quantizeoriginpostion_)
      + sizeof(EsriTypes_Transform::quantizeoriginpostion_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_Transform, scale_)>(
          reinterpret_cast<char*>(&scale_),
          reinterpret_cast<char*>(&other->scale_));
}

std::string EsriTypes_Transform::GetTypeName() const {
  return "esriPBuffer.EsriTypes.Transform";
}


// ===================================================================

void EsriTypes_QuantizationParameters::InitAsDefaultInstance() {
  ::esriPBuffer::_EsriTypes_QuantizationParameters_default_instance_._instance.get_mutable()->extent_ = const_cast< ::esriPBuffer::EsriTypes_Envelope*>(
      ::esriPBuffer::EsriTypes_Envelope::internal_default_instance());
}
class EsriTypes_QuantizationParameters::_Internal {
 public:
  static const ::esriPBuffer::EsriTypes_Envelope& extent(const EsriTypes_QuantizationParameters* msg);
};

const ::esriPBuffer::EsriTypes_Envelope&
EsriTypes_QuantizationParameters::_Internal::extent(const EsriTypes_QuantizationParameters* msg) {
  return *msg->extent_;
}
EsriTypes_QuantizationParameters::EsriTypes_QuantizationParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.QuantizationParameters)
}
EsriTypes_QuantizationParameters::EsriTypes_QuantizationParameters(const EsriTypes_QuantizationParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_extent()) {
    extent_ = new ::esriPBuffer::EsriTypes_Envelope(*from.extent_);
  } else {
    extent_ = nullptr;
  }
  ::memcpy(&mode_, &from.mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&tolerance_) -
    reinterpret_cast<char*>(&mode_)) + sizeof(tolerance_));
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.QuantizationParameters)
}

void EsriTypes_QuantizationParameters::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_QuantizationParameters_esriPBuffer_2fEsriTypes_2eproto.base);
  ::memset(&extent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tolerance_) -
      reinterpret_cast<char*>(&extent_)) + sizeof(tolerance_));
}

EsriTypes_QuantizationParameters::~EsriTypes_QuantizationParameters() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.QuantizationParameters)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_QuantizationParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete extent_;
}

void EsriTypes_QuantizationParameters::ArenaDtor(void* object) {
  EsriTypes_QuantizationParameters* _this = reinterpret_cast< EsriTypes_QuantizationParameters* >(object);
  (void)_this;
}
void EsriTypes_QuantizationParameters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_QuantizationParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_QuantizationParameters& EsriTypes_QuantizationParameters::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_QuantizationParameters_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_QuantizationParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.QuantizationParameters)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && extent_ != nullptr) {
    delete extent_;
  }
  extent_ = nullptr;
  ::memset(&mode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&tolerance_) -
      reinterpret_cast<char*>(&mode_)) + sizeof(tolerance_));
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_QuantizationParameters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .esriPBuffer.EsriTypes.Envelope extent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_extent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.QuantizeMode mode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mode(static_cast<::esriPBuffer::EsriTypes_QuantizeMode>(val));
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.QuantizeOriginPostion quantizeOriginPostion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_quantizeoriginpostion(static_cast<::esriPBuffer::EsriTypes_QuantizeOriginPostion>(val));
        } else goto handle_unusual;
        continue;
      // double tolerance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          tolerance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_QuantizationParameters::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.QuantizationParameters)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .esriPBuffer.EsriTypes.Envelope extent = 1;
  if (this->has_extent()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::extent(this), target, stream);
  }

  // .esriPBuffer.EsriTypes.QuantizeMode mode = 2;
  if (this->mode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_mode(), target);
  }

  // .esriPBuffer.EsriTypes.QuantizeOriginPostion quantizeOriginPostion = 3;
  if (this->quantizeoriginpostion() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_quantizeoriginpostion(), target);
  }

  // double tolerance = 4;
  if (!(this->tolerance() <= 0 && this->tolerance() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_tolerance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.QuantizationParameters)
  return target;
}

size_t EsriTypes_QuantizationParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.QuantizationParameters)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .esriPBuffer.EsriTypes.Envelope extent = 1;
  if (this->has_extent()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *extent_);
  }

  // .esriPBuffer.EsriTypes.QuantizeMode mode = 2;
  if (this->mode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mode());
  }

  // .esriPBuffer.EsriTypes.QuantizeOriginPostion quantizeOriginPostion = 3;
  if (this->quantizeoriginpostion() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quantizeoriginpostion());
  }

  // double tolerance = 4;
  if (!(this->tolerance() <= 0 && this->tolerance() >= 0)) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_QuantizationParameters::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_QuantizationParameters*>(
      &from));
}

void EsriTypes_QuantizationParameters::MergeFrom(const EsriTypes_QuantizationParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.QuantizationParameters)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_extent()) {
    _internal_mutable_extent()->::esriPBuffer::EsriTypes_Envelope::MergeFrom(from._internal_extent());
  }
  if (from.mode() != 0) {
    _internal_set_mode(from._internal_mode());
  }
  if (from.quantizeoriginpostion() != 0) {
    _internal_set_quantizeoriginpostion(from._internal_quantizeoriginpostion());
  }
  if (!(from.tolerance() <= 0 && from.tolerance() >= 0)) {
    _internal_set_tolerance(from._internal_tolerance());
  }
}

void EsriTypes_QuantizationParameters::CopyFrom(const EsriTypes_QuantizationParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.QuantizationParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_QuantizationParameters::IsInitialized() const {
  return true;
}

void EsriTypes_QuantizationParameters::InternalSwap(EsriTypes_QuantizationParameters* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_QuantizationParameters, tolerance_)
      + sizeof(EsriTypes_QuantizationParameters::tolerance_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_QuantizationParameters, extent_)>(
          reinterpret_cast<char*>(&extent_),
          reinterpret_cast<char*>(&other->extent_));
}

std::string EsriTypes_QuantizationParameters::GetTypeName() const {
  return "esriPBuffer.EsriTypes.QuantizationParameters";
}


// ===================================================================

void EsriTypes_SpatialReference::InitAsDefaultInstance() {
}
class EsriTypes_SpatialReference::_Internal {
 public:
};

EsriTypes_SpatialReference::EsriTypes_SpatialReference(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.SpatialReference)
}
EsriTypes_SpatialReference::EsriTypes_SpatialReference(const EsriTypes_SpatialReference& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  wkt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_wkt().empty()) {
    wkt_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_wkt(),
      GetArena());
  }
  ::memcpy(&wkid_, &from.wkid_,
    static_cast<size_t>(reinterpret_cast<char*>(&sdesrid_) -
    reinterpret_cast<char*>(&wkid_)) + sizeof(sdesrid_));
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.SpatialReference)
}

void EsriTypes_SpatialReference::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto.base);
  wkt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&wkid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sdesrid_) -
      reinterpret_cast<char*>(&wkid_)) + sizeof(sdesrid_));
}

EsriTypes_SpatialReference::~EsriTypes_SpatialReference() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.SpatialReference)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_SpatialReference::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  wkt_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EsriTypes_SpatialReference::ArenaDtor(void* object) {
  EsriTypes_SpatialReference* _this = reinterpret_cast< EsriTypes_SpatialReference* >(object);
  (void)_this;
}
void EsriTypes_SpatialReference::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_SpatialReference::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_SpatialReference& EsriTypes_SpatialReference::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_SpatialReference_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_SpatialReference::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.SpatialReference)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  wkt_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::memset(&wkid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sdesrid_) -
      reinterpret_cast<char*>(&wkid_)) + sizeof(sdesrid_));
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_SpatialReference::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint32 wkid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          wkid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 lastestWkid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          lastestwkid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 vcsWkid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          vcswkid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 latestVcsWkid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          latestvcswkid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string wkt = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_wkt();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 sdesrid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          sdesrid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_SpatialReference::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.SpatialReference)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 wkid = 1;
  if (this->wkid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_wkid(), target);
  }

  // uint32 lastestWkid = 2;
  if (this->lastestwkid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_lastestwkid(), target);
  }

  // uint32 vcsWkid = 3;
  if (this->vcswkid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_vcswkid(), target);
  }

  // uint32 latestVcsWkid = 4;
  if (this->latestvcswkid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_latestvcswkid(), target);
  }

  // string wkt = 5;
  if (this->wkt().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_wkt().data(), static_cast<int>(this->_internal_wkt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.SpatialReference.wkt");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_wkt(), target);
  }

  // uint32 sdesrid = 6;
  if (this->sdesrid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_sdesrid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.SpatialReference)
  return target;
}

size_t EsriTypes_SpatialReference::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.SpatialReference)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string wkt = 5;
  if (this->wkt().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_wkt());
  }

  // uint32 wkid = 1;
  if (this->wkid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_wkid());
  }

  // uint32 lastestWkid = 2;
  if (this->lastestwkid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_lastestwkid());
  }

  // uint32 vcsWkid = 3;
  if (this->vcswkid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_vcswkid());
  }

  // uint32 latestVcsWkid = 4;
  if (this->latestvcswkid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_latestvcswkid());
  }

  // uint32 sdesrid = 6;
  if (this->sdesrid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_sdesrid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_SpatialReference::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_SpatialReference*>(
      &from));
}

void EsriTypes_SpatialReference::MergeFrom(const EsriTypes_SpatialReference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.SpatialReference)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.wkt().size() > 0) {
    _internal_set_wkt(from._internal_wkt());
  }
  if (from.wkid() != 0) {
    _internal_set_wkid(from._internal_wkid());
  }
  if (from.lastestwkid() != 0) {
    _internal_set_lastestwkid(from._internal_lastestwkid());
  }
  if (from.vcswkid() != 0) {
    _internal_set_vcswkid(from._internal_vcswkid());
  }
  if (from.latestvcswkid() != 0) {
    _internal_set_latestvcswkid(from._internal_latestvcswkid());
  }
  if (from.sdesrid() != 0) {
    _internal_set_sdesrid(from._internal_sdesrid());
  }
}

void EsriTypes_SpatialReference::CopyFrom(const EsriTypes_SpatialReference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.SpatialReference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_SpatialReference::IsInitialized() const {
  return true;
}

void EsriTypes_SpatialReference::InternalSwap(EsriTypes_SpatialReference* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  wkt_.Swap(&other->wkt_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_SpatialReference, sdesrid_)
      + sizeof(EsriTypes_SpatialReference::sdesrid_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_SpatialReference, wkid_)>(
          reinterpret_cast<char*>(&wkid_),
          reinterpret_cast<char*>(&other->wkid_));
}

std::string EsriTypes_SpatialReference::GetTypeName() const {
  return "esriPBuffer.EsriTypes.SpatialReference";
}


// ===================================================================

void EsriTypes_FieldIndex::InitAsDefaultInstance() {
}
class EsriTypes_FieldIndex::_Internal {
 public:
};

EsriTypes_FieldIndex::EsriTypes_FieldIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.FieldIndex)
}
EsriTypes_FieldIndex::EsriTypes_FieldIndex(const EsriTypes_FieldIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  fields_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_fields().empty()) {
    fields_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_fields(),
      GetArena());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_description().empty()) {
    description_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_description(),
      GetArena());
  }
  ::memcpy(&isascending_, &from.isascending_,
    static_cast<size_t>(reinterpret_cast<char*>(&isunique_) -
    reinterpret_cast<char*>(&isascending_)) + sizeof(isunique_));
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.FieldIndex)
}

void EsriTypes_FieldIndex::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_FieldIndex_esriPBuffer_2fEsriTypes_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fields_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&isascending_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isunique_) -
      reinterpret_cast<char*>(&isascending_)) + sizeof(isunique_));
}

EsriTypes_FieldIndex::~EsriTypes_FieldIndex() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.FieldIndex)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_FieldIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fields_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EsriTypes_FieldIndex::ArenaDtor(void* object) {
  EsriTypes_FieldIndex* _this = reinterpret_cast< EsriTypes_FieldIndex* >(object);
  (void)_this;
}
void EsriTypes_FieldIndex::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_FieldIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_FieldIndex& EsriTypes_FieldIndex::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_FieldIndex_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_FieldIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.FieldIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  fields_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  description_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::memset(&isascending_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isunique_) -
      reinterpret_cast<char*>(&isascending_)) + sizeof(isunique_));
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_FieldIndex::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string fields = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_fields();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool isAscending = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          isascending_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool isUnique = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          isunique_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_FieldIndex::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.FieldIndex)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.FieldIndex.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string fields = 2;
  if (this->fields().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fields().data(), static_cast<int>(this->_internal_fields().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.FieldIndex.fields");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_fields(), target);
  }

  // bool isAscending = 3;
  if (this->isascending() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isascending(), target);
  }

  // bool isUnique = 4;
  if (this->isunique() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_isunique(), target);
  }

  // string description = 5;
  if (this->description().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.FieldIndex.description");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.FieldIndex)
  return target;
}

size_t EsriTypes_FieldIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.FieldIndex)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string fields = 2;
  if (this->fields().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fields());
  }

  // string description = 5;
  if (this->description().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // bool isAscending = 3;
  if (this->isascending() != 0) {
    total_size += 1 + 1;
  }

  // bool isUnique = 4;
  if (this->isunique() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_FieldIndex::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_FieldIndex*>(
      &from));
}

void EsriTypes_FieldIndex::MergeFrom(const EsriTypes_FieldIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.FieldIndex)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.fields().size() > 0) {
    _internal_set_fields(from._internal_fields());
  }
  if (from.description().size() > 0) {
    _internal_set_description(from._internal_description());
  }
  if (from.isascending() != 0) {
    _internal_set_isascending(from._internal_isascending());
  }
  if (from.isunique() != 0) {
    _internal_set_isunique(from._internal_isunique());
  }
}

void EsriTypes_FieldIndex::CopyFrom(const EsriTypes_FieldIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.FieldIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_FieldIndex::IsInitialized() const {
  return true;
}

void EsriTypes_FieldIndex::InternalSwap(EsriTypes_FieldIndex* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  fields_.Swap(&other->fields_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  description_.Swap(&other->description_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_FieldIndex, isunique_)
      + sizeof(EsriTypes_FieldIndex::isunique_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_FieldIndex, isascending_)>(
          reinterpret_cast<char*>(&isascending_),
          reinterpret_cast<char*>(&other->isascending_));
}

std::string EsriTypes_FieldIndex::GetTypeName() const {
  return "esriPBuffer.EsriTypes.FieldIndex";
}


// ===================================================================

void EsriTypes_Value::InitAsDefaultInstance() {
}
class EsriTypes_Value::_Internal {
 public:
};

EsriTypes_Value::EsriTypes_Value(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.Value)
}
EsriTypes_Value::EsriTypes_Value(const EsriTypes_Value& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_value_type();
  switch (from.value_type_case()) {
    case kStringValue: {
      _internal_set_string_value(from._internal_string_value());
      break;
    }
    case kFloatValue: {
      _internal_set_float_value(from._internal_float_value());
      break;
    }
    case kDoubleValue: {
      _internal_set_double_value(from._internal_double_value());
      break;
    }
    case kSintValue: {
      _internal_set_sint_value(from._internal_sint_value());
      break;
    }
    case kUintValue: {
      _internal_set_uint_value(from._internal_uint_value());
      break;
    }
    case kInt64Value: {
      _internal_set_int64_value(from._internal_int64_value());
      break;
    }
    case kUint64Value: {
      _internal_set_uint64_value(from._internal_uint64_value());
      break;
    }
    case kSint64Value: {
      _internal_set_sint64_value(from._internal_sint64_value());
      break;
    }
    case kBoolValue: {
      _internal_set_bool_value(from._internal_bool_value());
      break;
    }
    case VALUE_TYPE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.Value)
}

void EsriTypes_Value::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto.base);
  clear_has_value_type();
}

EsriTypes_Value::~EsriTypes_Value() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.Value)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_Value::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (has_value_type()) {
    clear_value_type();
  }
}

void EsriTypes_Value::ArenaDtor(void* object) {
  EsriTypes_Value* _this = reinterpret_cast< EsriTypes_Value* >(object);
  (void)_this;
}
void EsriTypes_Value::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_Value::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_Value& EsriTypes_Value::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_Value_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_Value::clear_value_type() {
// @@protoc_insertion_point(one_of_clear_start:esriPBuffer.EsriTypes.Value)
  switch (value_type_case()) {
    case kStringValue: {
      value_type_.string_value_.Destroy(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
      break;
    }
    case kFloatValue: {
      // No need to clear
      break;
    }
    case kDoubleValue: {
      // No need to clear
      break;
    }
    case kSintValue: {
      // No need to clear
      break;
    }
    case kUintValue: {
      // No need to clear
      break;
    }
    case kInt64Value: {
      // No need to clear
      break;
    }
    case kUint64Value: {
      // No need to clear
      break;
    }
    case kSint64Value: {
      // No need to clear
      break;
    }
    case kBoolValue: {
      // No need to clear
      break;
    }
    case VALUE_TYPE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = VALUE_TYPE_NOT_SET;
}


void EsriTypes_Value::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.Value)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_value_type();
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_Value::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string string_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_string_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // float float_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _internal_set_float_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // double double_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          _internal_set_double_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // sint32 sint_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _internal_set_sint_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint32 uint_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _internal_set_uint_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int64 int64_value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _internal_set_int64_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // uint64 uint64_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _internal_set_uint64_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // sint64 sint64_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _internal_set_sint64_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool bool_value = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _internal_set_bool_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_Value::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.Value)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string string_value = 1;
  if (_internal_has_string_value()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_string_value().data(), static_cast<int>(this->_internal_string_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.Value.string_value");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_string_value(), target);
  }

  // float float_value = 2;
  if (_internal_has_float_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_float_value(), target);
  }

  // double double_value = 3;
  if (_internal_has_double_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_double_value(), target);
  }

  // sint32 sint_value = 4;
  if (_internal_has_sint_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(4, this->_internal_sint_value(), target);
  }

  // uint32 uint_value = 5;
  if (_internal_has_uint_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_uint_value(), target);
  }

  // int64 int64_value = 6;
  if (_internal_has_int64_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(6, this->_internal_int64_value(), target);
  }

  // uint64 uint64_value = 7;
  if (_internal_has_uint64_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_uint64_value(), target);
  }

  // sint64 sint64_value = 8;
  if (_internal_has_sint64_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt64ToArray(8, this->_internal_sint64_value(), target);
  }

  // bool bool_value = 9;
  if (_internal_has_bool_value()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_bool_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.Value)
  return target;
}

size_t EsriTypes_Value::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.Value)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (value_type_case()) {
    // string string_value = 1;
    case kStringValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_value());
      break;
    }
    // float float_value = 2;
    case kFloatValue: {
      total_size += 1 + 4;
      break;
    }
    // double double_value = 3;
    case kDoubleValue: {
      total_size += 1 + 8;
      break;
    }
    // sint32 sint_value = 4;
    case kSintValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
          this->_internal_sint_value());
      break;
    }
    // uint32 uint_value = 5;
    case kUintValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_uint_value());
      break;
    }
    // int64 int64_value = 6;
    case kInt64Value: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_int64_value());
      break;
    }
    // uint64 uint64_value = 7;
    case kUint64Value: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_uint64_value());
      break;
    }
    // sint64 sint64_value = 8;
    case kSint64Value: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt64Size(
          this->_internal_sint64_value());
      break;
    }
    // bool bool_value = 9;
    case kBoolValue: {
      total_size += 1 + 1;
      break;
    }
    case VALUE_TYPE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_Value::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_Value*>(
      &from));
}

void EsriTypes_Value::MergeFrom(const EsriTypes_Value& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.Value)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.value_type_case()) {
    case kStringValue: {
      _internal_set_string_value(from._internal_string_value());
      break;
    }
    case kFloatValue: {
      _internal_set_float_value(from._internal_float_value());
      break;
    }
    case kDoubleValue: {
      _internal_set_double_value(from._internal_double_value());
      break;
    }
    case kSintValue: {
      _internal_set_sint_value(from._internal_sint_value());
      break;
    }
    case kUintValue: {
      _internal_set_uint_value(from._internal_uint_value());
      break;
    }
    case kInt64Value: {
      _internal_set_int64_value(from._internal_int64_value());
      break;
    }
    case kUint64Value: {
      _internal_set_uint64_value(from._internal_uint64_value());
      break;
    }
    case kSint64Value: {
      _internal_set_sint64_value(from._internal_sint64_value());
      break;
    }
    case kBoolValue: {
      _internal_set_bool_value(from._internal_bool_value());
      break;
    }
    case VALUE_TYPE_NOT_SET: {
      break;
    }
  }
}

void EsriTypes_Value::CopyFrom(const EsriTypes_Value& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_Value::IsInitialized() const {
  return true;
}

void EsriTypes_Value::InternalSwap(EsriTypes_Value* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  swap(value_type_, other->value_type_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string EsriTypes_Value::GetTypeName() const {
  return "esriPBuffer.EsriTypes.Value";
}


// ===================================================================

void EsriTypes_Envelope::InitAsDefaultInstance() {
  ::esriPBuffer::_EsriTypes_Envelope_default_instance_._instance.get_mutable()->spatialreference_ = const_cast< ::esriPBuffer::EsriTypes_SpatialReference*>(
      ::esriPBuffer::EsriTypes_SpatialReference::internal_default_instance());
}
class EsriTypes_Envelope::_Internal {
 public:
  static const ::esriPBuffer::EsriTypes_SpatialReference& spatialreference(const EsriTypes_Envelope* msg);
};

const ::esriPBuffer::EsriTypes_SpatialReference&
EsriTypes_Envelope::_Internal::spatialreference(const EsriTypes_Envelope* msg) {
  return *msg->spatialreference_;
}
EsriTypes_Envelope::EsriTypes_Envelope(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.Envelope)
}
EsriTypes_Envelope::EsriTypes_Envelope(const EsriTypes_Envelope& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_spatialreference()) {
    spatialreference_ = new ::esriPBuffer::EsriTypes_SpatialReference(*from.spatialreference_);
  } else {
    spatialreference_ = nullptr;
  }
  ::memcpy(&xmin_, &from.xmin_,
    static_cast<size_t>(reinterpret_cast<char*>(&ymax_) -
    reinterpret_cast<char*>(&xmin_)) + sizeof(ymax_));
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.Envelope)
}

void EsriTypes_Envelope::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto.base);
  ::memset(&spatialreference_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ymax_) -
      reinterpret_cast<char*>(&spatialreference_)) + sizeof(ymax_));
}

EsriTypes_Envelope::~EsriTypes_Envelope() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.Envelope)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_Envelope::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete spatialreference_;
}

void EsriTypes_Envelope::ArenaDtor(void* object) {
  EsriTypes_Envelope* _this = reinterpret_cast< EsriTypes_Envelope* >(object);
  (void)_this;
}
void EsriTypes_Envelope::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_Envelope::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_Envelope& EsriTypes_Envelope::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_Envelope_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_Envelope::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.Envelope)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArena() == nullptr && spatialreference_ != nullptr) {
    delete spatialreference_;
  }
  spatialreference_ = nullptr;
  ::memset(&xmin_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ymax_) -
      reinterpret_cast<char*>(&xmin_)) + sizeof(ymax_));
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_Envelope::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // double XMin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 9)) {
          xmin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double YMin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 17)) {
          ymin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double XMax = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 25)) {
          xmax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // double YMax = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 33)) {
          ymax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.SpatialReference SpatialReference = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_spatialreference(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_Envelope::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.Envelope)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // double XMin = 1;
  if (!(this->xmin() <= 0 && this->xmin() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(1, this->_internal_xmin(), target);
  }

  // double YMin = 2;
  if (!(this->ymin() <= 0 && this->ymin() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_ymin(), target);
  }

  // double XMax = 3;
  if (!(this->xmax() <= 0 && this->xmax() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(3, this->_internal_xmax(), target);
  }

  // double YMax = 4;
  if (!(this->ymax() <= 0 && this->ymax() >= 0)) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(4, this->_internal_ymax(), target);
  }

  // .esriPBuffer.EsriTypes.SpatialReference SpatialReference = 5;
  if (this->has_spatialreference()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::spatialreference(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.Envelope)
  return target;
}

size_t EsriTypes_Envelope::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.Envelope)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .esriPBuffer.EsriTypes.SpatialReference SpatialReference = 5;
  if (this->has_spatialreference()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *spatialreference_);
  }

  // double XMin = 1;
  if (!(this->xmin() <= 0 && this->xmin() >= 0)) {
    total_size += 1 + 8;
  }

  // double YMin = 2;
  if (!(this->ymin() <= 0 && this->ymin() >= 0)) {
    total_size += 1 + 8;
  }

  // double XMax = 3;
  if (!(this->xmax() <= 0 && this->xmax() >= 0)) {
    total_size += 1 + 8;
  }

  // double YMax = 4;
  if (!(this->ymax() <= 0 && this->ymax() >= 0)) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_Envelope::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_Envelope*>(
      &from));
}

void EsriTypes_Envelope::MergeFrom(const EsriTypes_Envelope& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.Envelope)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_spatialreference()) {
    _internal_mutable_spatialreference()->::esriPBuffer::EsriTypes_SpatialReference::MergeFrom(from._internal_spatialreference());
  }
  if (!(from.xmin() <= 0 && from.xmin() >= 0)) {
    _internal_set_xmin(from._internal_xmin());
  }
  if (!(from.ymin() <= 0 && from.ymin() >= 0)) {
    _internal_set_ymin(from._internal_ymin());
  }
  if (!(from.xmax() <= 0 && from.xmax() >= 0)) {
    _internal_set_xmax(from._internal_xmax());
  }
  if (!(from.ymax() <= 0 && from.ymax() >= 0)) {
    _internal_set_ymax(from._internal_ymax());
  }
}

void EsriTypes_Envelope::CopyFrom(const EsriTypes_Envelope& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.Envelope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_Envelope::IsInitialized() const {
  return true;
}

void EsriTypes_Envelope::InternalSwap(EsriTypes_Envelope* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_Envelope, ymax_)
      + sizeof(EsriTypes_Envelope::ymax_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_Envelope, spatialreference_)>(
          reinterpret_cast<char*>(&spatialreference_),
          reinterpret_cast<char*>(&other->spatialreference_));
}

std::string EsriTypes_Envelope::GetTypeName() const {
  return "esriPBuffer.EsriTypes.Envelope";
}


// ===================================================================

void EsriTypes_CodedValue::InitAsDefaultInstance() {
  ::esriPBuffer::_EsriTypes_CodedValue_default_instance_._instance.get_mutable()->code_ = const_cast< ::esriPBuffer::EsriTypes_Value*>(
      ::esriPBuffer::EsriTypes_Value::internal_default_instance());
}
class EsriTypes_CodedValue::_Internal {
 public:
  static const ::esriPBuffer::EsriTypes_Value& code(const EsriTypes_CodedValue* msg);
};

const ::esriPBuffer::EsriTypes_Value&
EsriTypes_CodedValue::_Internal::code(const EsriTypes_CodedValue* msg) {
  return *msg->code_;
}
EsriTypes_CodedValue::EsriTypes_CodedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.CodedValue)
}
EsriTypes_CodedValue::EsriTypes_CodedValue(const EsriTypes_CodedValue& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  if (from._internal_has_code()) {
    code_ = new ::esriPBuffer::EsriTypes_Value(*from.code_);
  } else {
    code_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.CodedValue)
}

void EsriTypes_CodedValue::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  code_ = nullptr;
}

EsriTypes_CodedValue::~EsriTypes_CodedValue() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.CodedValue)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_CodedValue::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete code_;
}

void EsriTypes_CodedValue::ArenaDtor(void* object) {
  EsriTypes_CodedValue* _this = reinterpret_cast< EsriTypes_CodedValue* >(object);
  (void)_this;
}
void EsriTypes_CodedValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_CodedValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_CodedValue& EsriTypes_CodedValue::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_CodedValue_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_CodedValue::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.CodedValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && code_ != nullptr) {
    delete code_;
  }
  code_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_CodedValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.Value code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_code(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_CodedValue::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.CodedValue)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.CodedValue.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .esriPBuffer.EsriTypes.Value code = 2;
  if (this->has_code()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::code(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.CodedValue)
  return target;
}

size_t EsriTypes_CodedValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.CodedValue)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .esriPBuffer.EsriTypes.Value code = 2;
  if (this->has_code()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *code_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_CodedValue::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_CodedValue*>(
      &from));
}

void EsriTypes_CodedValue::MergeFrom(const EsriTypes_CodedValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.CodedValue)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.has_code()) {
    _internal_mutable_code()->::esriPBuffer::EsriTypes_Value::MergeFrom(from._internal_code());
  }
}

void EsriTypes_CodedValue::CopyFrom(const EsriTypes_CodedValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.CodedValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_CodedValue::IsInitialized() const {
  return true;
}

void EsriTypes_CodedValue::InternalSwap(EsriTypes_CodedValue* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(code_, other->code_);
}

std::string EsriTypes_CodedValue::GetTypeName() const {
  return "esriPBuffer.EsriTypes.CodedValue";
}


// ===================================================================

void EsriTypes_CodedValueDomain::InitAsDefaultInstance() {
}
class EsriTypes_CodedValueDomain::_Internal {
 public:
};

EsriTypes_CodedValueDomain::EsriTypes_CodedValueDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  codesvalues_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.CodedValueDomain)
}
EsriTypes_CodedValueDomain::EsriTypes_CodedValueDomain(const EsriTypes_CodedValueDomain& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      codesvalues_(from.codesvalues_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.CodedValueDomain)
}

void EsriTypes_CodedValueDomain::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto.base);
}

EsriTypes_CodedValueDomain::~EsriTypes_CodedValueDomain() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.CodedValueDomain)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_CodedValueDomain::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EsriTypes_CodedValueDomain::ArenaDtor(void* object) {
  EsriTypes_CodedValueDomain* _this = reinterpret_cast< EsriTypes_CodedValueDomain* >(object);
  (void)_this;
}
void EsriTypes_CodedValueDomain::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_CodedValueDomain::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_CodedValueDomain& EsriTypes_CodedValueDomain::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_CodedValueDomain_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_CodedValueDomain::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.CodedValueDomain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  codesvalues_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_CodedValueDomain::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .esriPBuffer.EsriTypes.CodedValue codesValues = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_codesvalues(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_CodedValueDomain::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.CodedValueDomain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .esriPBuffer.EsriTypes.CodedValue codesValues = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_codesvalues_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_codesvalues(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.CodedValueDomain)
  return target;
}

size_t EsriTypes_CodedValueDomain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.CodedValueDomain)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .esriPBuffer.EsriTypes.CodedValue codesValues = 3;
  total_size += 1UL * this->_internal_codesvalues_size();
  for (const auto& msg : this->codesvalues_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_CodedValueDomain::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_CodedValueDomain*>(
      &from));
}

void EsriTypes_CodedValueDomain::MergeFrom(const EsriTypes_CodedValueDomain& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.CodedValueDomain)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  codesvalues_.MergeFrom(from.codesvalues_);
}

void EsriTypes_CodedValueDomain::CopyFrom(const EsriTypes_CodedValueDomain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.CodedValueDomain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_CodedValueDomain::IsInitialized() const {
  return true;
}

void EsriTypes_CodedValueDomain::InternalSwap(EsriTypes_CodedValueDomain* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  codesvalues_.InternalSwap(&other->codesvalues_);
}

std::string EsriTypes_CodedValueDomain::GetTypeName() const {
  return "esriPBuffer.EsriTypes.CodedValueDomain";
}


// ===================================================================

void EsriTypes_RangeDomain::InitAsDefaultInstance() {
}
class EsriTypes_RangeDomain::_Internal {
 public:
};

EsriTypes_RangeDomain::EsriTypes_RangeDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena),
  range_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.RangeDomain)
}
EsriTypes_RangeDomain::EsriTypes_RangeDomain(const EsriTypes_RangeDomain& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      range_(from.range_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.RangeDomain)
}

void EsriTypes_RangeDomain::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto.base);
}

EsriTypes_RangeDomain::~EsriTypes_RangeDomain() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.RangeDomain)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_RangeDomain::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EsriTypes_RangeDomain::ArenaDtor(void* object) {
  EsriTypes_RangeDomain* _this = reinterpret_cast< EsriTypes_RangeDomain* >(object);
  (void)_this;
}
void EsriTypes_RangeDomain::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_RangeDomain::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_RangeDomain& EsriTypes_RangeDomain::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_RangeDomain_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_RangeDomain::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.RangeDomain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  range_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_RangeDomain::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .esriPBuffer.EsriTypes.Value range = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_range(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_RangeDomain::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.RangeDomain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .esriPBuffer.EsriTypes.Value range = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_range_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_range(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.RangeDomain)
  return target;
}

size_t EsriTypes_RangeDomain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.RangeDomain)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .esriPBuffer.EsriTypes.Value range = 3;
  total_size += 1UL * this->_internal_range_size();
  for (const auto& msg : this->range_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_RangeDomain::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_RangeDomain*>(
      &from));
}

void EsriTypes_RangeDomain::MergeFrom(const EsriTypes_RangeDomain& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.RangeDomain)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  range_.MergeFrom(from.range_);
}

void EsriTypes_RangeDomain::CopyFrom(const EsriTypes_RangeDomain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.RangeDomain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_RangeDomain::IsInitialized() const {
  return true;
}

void EsriTypes_RangeDomain::InternalSwap(EsriTypes_RangeDomain* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  range_.InternalSwap(&other->range_);
}

std::string EsriTypes_RangeDomain::GetTypeName() const {
  return "esriPBuffer.EsriTypes.RangeDomain";
}


// ===================================================================

void EsriTypes_Domain::InitAsDefaultInstance() {
}
class EsriTypes_Domain::_Internal {
 public:
  static const ::esriPBuffer::EsriTypes_CodedValueDomain& codedvaluedomain(const EsriTypes_Domain* msg);
  static const ::esriPBuffer::EsriTypes_RangeDomain& rangedomain(const EsriTypes_Domain* msg);
};

const ::esriPBuffer::EsriTypes_CodedValueDomain&
EsriTypes_Domain::_Internal::codedvaluedomain(const EsriTypes_Domain* msg) {
  return *msg->of_.codedvaluedomain_;
}
const ::esriPBuffer::EsriTypes_RangeDomain&
EsriTypes_Domain::_Internal::rangedomain(const EsriTypes_Domain* msg) {
  return *msg->of_.rangedomain_;
}
void EsriTypes_Domain::set_allocated_codedvaluedomain(::esriPBuffer::EsriTypes_CodedValueDomain* codedvaluedomain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_of();
  if (codedvaluedomain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(codedvaluedomain);
    if (message_arena != submessage_arena) {
      codedvaluedomain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, codedvaluedomain, submessage_arena);
    }
    set_has_codedvaluedomain();
    of_.codedvaluedomain_ = codedvaluedomain;
  }
  // @@protoc_insertion_point(field_set_allocated:esriPBuffer.EsriTypes.Domain.codedValueDomain)
}
void EsriTypes_Domain::set_allocated_rangedomain(::esriPBuffer::EsriTypes_RangeDomain* rangedomain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_of();
  if (rangedomain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rangedomain);
    if (message_arena != submessage_arena) {
      rangedomain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rangedomain, submessage_arena);
    }
    set_has_rangedomain();
    of_.rangedomain_ = rangedomain;
  }
  // @@protoc_insertion_point(field_set_allocated:esriPBuffer.EsriTypes.Domain.rangeDomain)
}
EsriTypes_Domain::EsriTypes_Domain(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.Domain)
}
EsriTypes_Domain::EsriTypes_Domain(const EsriTypes_Domain& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_type().empty()) {
    type_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  ::memcpy(&fieldtype_, &from.fieldtype_,
    static_cast<size_t>(reinterpret_cast<char*>(&splitpolicytype_) -
    reinterpret_cast<char*>(&fieldtype_)) + sizeof(splitpolicytype_));
  clear_has_of();
  switch (from.of_case()) {
    case kCodedValueDomain: {
      _internal_mutable_codedvaluedomain()->::esriPBuffer::EsriTypes_CodedValueDomain::MergeFrom(from._internal_codedvaluedomain());
      break;
    }
    case kRangeDomain: {
      _internal_mutable_rangedomain()->::esriPBuffer::EsriTypes_RangeDomain::MergeFrom(from._internal_rangedomain());
      break;
    }
    case OF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.Domain)
}

void EsriTypes_Domain::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_Domain_esriPBuffer_2fEsriTypes_2eproto.base);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&fieldtype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&splitpolicytype_) -
      reinterpret_cast<char*>(&fieldtype_)) + sizeof(splitpolicytype_));
  clear_has_of();
}

EsriTypes_Domain::~EsriTypes_Domain() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.Domain)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_Domain::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_of()) {
    clear_of();
  }
}

void EsriTypes_Domain::ArenaDtor(void* object) {
  EsriTypes_Domain* _this = reinterpret_cast< EsriTypes_Domain* >(object);
  (void)_this;
}
void EsriTypes_Domain::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_Domain::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_Domain& EsriTypes_Domain::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_Domain_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_Domain::clear_of() {
// @@protoc_insertion_point(one_of_clear_start:esriPBuffer.EsriTypes.Domain)
  switch (of_case()) {
    case kCodedValueDomain: {
      if (GetArena() == nullptr) {
        delete of_.codedvaluedomain_;
      }
      break;
    }
    case kRangeDomain: {
      if (GetArena() == nullptr) {
        delete of_.rangedomain_;
      }
      break;
    }
    case OF_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OF_NOT_SET;
}


void EsriTypes_Domain::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.Domain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::memset(&fieldtype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&splitpolicytype_) -
      reinterpret_cast<char*>(&fieldtype_)) + sizeof(splitpolicytype_));
  clear_of();
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_Domain::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.CodedValueDomain codedValueDomain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_codedvaluedomain(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.RangeDomain rangeDomain = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rangedomain(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriExtendedTypes.FieldType fieldType = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_fieldtype(static_cast<::esriPBuffer::EsriExtendedTypes::FieldType>(val));
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.MergePolicyType mergePolicyType = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_mergepolicytype(static_cast<::esriPBuffer::EsriTypes_MergePolicyType>(val));
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.SplitPolicyType splitPolicyType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_splitpolicytype(static_cast<::esriPBuffer::EsriTypes_SplitPolicyType>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_Domain::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.Domain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string type = 1;
  if (this->type().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.Domain.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // string name = 2;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.Domain.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // .esriPBuffer.EsriTypes.CodedValueDomain codedValueDomain = 3;
  if (_internal_has_codedvaluedomain()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::codedvaluedomain(this), target, stream);
  }

  // .esriPBuffer.EsriTypes.RangeDomain rangeDomain = 4;
  if (_internal_has_rangedomain()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::rangedomain(this), target, stream);
  }

  // .esriPBuffer.EsriExtendedTypes.FieldType fieldType = 5;
  if (this->fieldtype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_fieldtype(), target);
  }

  // .esriPBuffer.EsriTypes.MergePolicyType mergePolicyType = 6;
  if (this->mergepolicytype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_mergepolicytype(), target);
  }

  // .esriPBuffer.EsriTypes.SplitPolicyType splitPolicyType = 7;
  if (this->splitpolicytype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_splitpolicytype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.Domain)
  return target;
}

size_t EsriTypes_Domain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.Domain)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string type = 1;
  if (this->type().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  // string name = 2;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .esriPBuffer.EsriExtendedTypes.FieldType fieldType = 5;
  if (this->fieldtype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fieldtype());
  }

  // .esriPBuffer.EsriTypes.MergePolicyType mergePolicyType = 6;
  if (this->mergepolicytype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_mergepolicytype());
  }

  // .esriPBuffer.EsriTypes.SplitPolicyType splitPolicyType = 7;
  if (this->splitpolicytype() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_splitpolicytype());
  }

  switch (of_case()) {
    // .esriPBuffer.EsriTypes.CodedValueDomain codedValueDomain = 3;
    case kCodedValueDomain: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *of_.codedvaluedomain_);
      break;
    }
    // .esriPBuffer.EsriTypes.RangeDomain rangeDomain = 4;
    case kRangeDomain: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *of_.rangedomain_);
      break;
    }
    case OF_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_Domain::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_Domain*>(
      &from));
}

void EsriTypes_Domain::MergeFrom(const EsriTypes_Domain& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.Domain)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.type().size() > 0) {
    _internal_set_type(from._internal_type());
  }
  if (from.name().size() > 0) {
    _internal_set_name(from._internal_name());
  }
  if (from.fieldtype() != 0) {
    _internal_set_fieldtype(from._internal_fieldtype());
  }
  if (from.mergepolicytype() != 0) {
    _internal_set_mergepolicytype(from._internal_mergepolicytype());
  }
  if (from.splitpolicytype() != 0) {
    _internal_set_splitpolicytype(from._internal_splitpolicytype());
  }
  switch (from.of_case()) {
    case kCodedValueDomain: {
      _internal_mutable_codedvaluedomain()->::esriPBuffer::EsriTypes_CodedValueDomain::MergeFrom(from._internal_codedvaluedomain());
      break;
    }
    case kRangeDomain: {
      _internal_mutable_rangedomain()->::esriPBuffer::EsriTypes_RangeDomain::MergeFrom(from._internal_rangedomain());
      break;
    }
    case OF_NOT_SET: {
      break;
    }
  }
}

void EsriTypes_Domain::CopyFrom(const EsriTypes_Domain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.Domain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_Domain::IsInitialized() const {
  return true;
}

void EsriTypes_Domain::InternalSwap(EsriTypes_Domain* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_Domain, splitpolicytype_)
      + sizeof(EsriTypes_Domain::splitpolicytype_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_Domain, fieldtype_)>(
          reinterpret_cast<char*>(&fieldtype_),
          reinterpret_cast<char*>(&other->fieldtype_));
  swap(of_, other->of_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string EsriTypes_Domain::GetTypeName() const {
  return "esriPBuffer.EsriTypes.Domain";
}


// ===================================================================

void EsriTypes_DatumTransformation::InitAsDefaultInstance() {
  ::esriPBuffer::_EsriTypes_DatumTransformation_default_instance_._instance.get_mutable()->fromsr_ = const_cast< ::esriPBuffer::EsriTypes_SpatialReference*>(
      ::esriPBuffer::EsriTypes_SpatialReference::internal_default_instance());
  ::esriPBuffer::_EsriTypes_DatumTransformation_default_instance_._instance.get_mutable()->tosr_ = const_cast< ::esriPBuffer::EsriTypes_SpatialReference*>(
      ::esriPBuffer::EsriTypes_SpatialReference::internal_default_instance());
}
class EsriTypes_DatumTransformation::_Internal {
 public:
  static const ::esriPBuffer::EsriTypes_SpatialReference& fromsr(const EsriTypes_DatumTransformation* msg);
  static const ::esriPBuffer::EsriTypes_SpatialReference& tosr(const EsriTypes_DatumTransformation* msg);
};

const ::esriPBuffer::EsriTypes_SpatialReference&
EsriTypes_DatumTransformation::_Internal::fromsr(const EsriTypes_DatumTransformation* msg) {
  return *msg->fromsr_;
}
const ::esriPBuffer::EsriTypes_SpatialReference&
EsriTypes_DatumTransformation::_Internal::tosr(const EsriTypes_DatumTransformation* msg) {
  return *msg->tosr_;
}
EsriTypes_DatumTransformation::EsriTypes_DatumTransformation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes.DatumTransformation)
}
EsriTypes_DatumTransformation::EsriTypes_DatumTransformation(const EsriTypes_DatumTransformation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  wkt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_wkt().empty()) {
    wkt_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_wkt(),
      GetArena());
  }
  transformdirection_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_transformdirection().empty()) {
    transformdirection_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_transformdirection(),
      GetArena());
  }
  transformjson_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_transformjson().empty()) {
    transformjson_.SetLite(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_transformjson(),
      GetArena());
  }
  if (from._internal_has_fromsr()) {
    fromsr_ = new ::esriPBuffer::EsriTypes_SpatialReference(*from.fromsr_);
  } else {
    fromsr_ = nullptr;
  }
  if (from._internal_has_tosr()) {
    tosr_ = new ::esriPBuffer::EsriTypes_SpatialReference(*from.tosr_);
  } else {
    tosr_ = nullptr;
  }
  wkid_ = from.wkid_;
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes.DatumTransformation)
}

void EsriTypes_DatumTransformation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EsriTypes_DatumTransformation_esriPBuffer_2fEsriTypes_2eproto.base);
  wkt_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transformdirection_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transformjson_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&fromsr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&wkid_) -
      reinterpret_cast<char*>(&fromsr_)) + sizeof(wkid_));
}

EsriTypes_DatumTransformation::~EsriTypes_DatumTransformation() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes.DatumTransformation)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes_DatumTransformation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  wkt_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transformdirection_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  transformjson_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete fromsr_;
  if (this != internal_default_instance()) delete tosr_;
}

void EsriTypes_DatumTransformation::ArenaDtor(void* object) {
  EsriTypes_DatumTransformation* _this = reinterpret_cast< EsriTypes_DatumTransformation* >(object);
  (void)_this;
}
void EsriTypes_DatumTransformation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes_DatumTransformation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes_DatumTransformation& EsriTypes_DatumTransformation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_DatumTransformation_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes_DatumTransformation::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes.DatumTransformation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  wkt_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  transformdirection_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  transformjson_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  if (GetArena() == nullptr && fromsr_ != nullptr) {
    delete fromsr_;
  }
  fromsr_ = nullptr;
  if (GetArena() == nullptr && tosr_ != nullptr) {
    delete tosr_;
  }
  tosr_ = nullptr;
  wkid_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes_DatumTransformation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // uint32 wkid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          wkid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string wkt = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_wkt();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string transformDirection = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_transformdirection();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string transformJson = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_transformjson();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, nullptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.SpatialReference fromSR = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_fromsr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .esriPBuffer.EsriTypes.SpatialReference toSR = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_tosr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes_DatumTransformation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes.DatumTransformation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 wkid = 1;
  if (this->wkid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_wkid(), target);
  }

  // string wkt = 2;
  if (this->wkt().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_wkt().data(), static_cast<int>(this->_internal_wkt().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.DatumTransformation.wkt");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_wkt(), target);
  }

  // string transformDirection = 3;
  if (this->transformdirection().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transformdirection().data(), static_cast<int>(this->_internal_transformdirection().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.DatumTransformation.transformDirection");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_transformdirection(), target);
  }

  // string transformJson = 4;
  if (this->transformjson().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_transformjson().data(), static_cast<int>(this->_internal_transformjson().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "esriPBuffer.EsriTypes.DatumTransformation.transformJson");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_transformjson(), target);
  }

  // .esriPBuffer.EsriTypes.SpatialReference fromSR = 5;
  if (this->has_fromsr()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::fromsr(this), target, stream);
  }

  // .esriPBuffer.EsriTypes.SpatialReference toSR = 6;
  if (this->has_tosr()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::tosr(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes.DatumTransformation)
  return target;
}

size_t EsriTypes_DatumTransformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes.DatumTransformation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string wkt = 2;
  if (this->wkt().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_wkt());
  }

  // string transformDirection = 3;
  if (this->transformdirection().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transformdirection());
  }

  // string transformJson = 4;
  if (this->transformjson().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_transformjson());
  }

  // .esriPBuffer.EsriTypes.SpatialReference fromSR = 5;
  if (this->has_fromsr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *fromsr_);
  }

  // .esriPBuffer.EsriTypes.SpatialReference toSR = 6;
  if (this->has_tosr()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *tosr_);
  }

  // uint32 wkid = 1;
  if (this->wkid() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_wkid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes_DatumTransformation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes_DatumTransformation*>(
      &from));
}

void EsriTypes_DatumTransformation::MergeFrom(const EsriTypes_DatumTransformation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes.DatumTransformation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.wkt().size() > 0) {
    _internal_set_wkt(from._internal_wkt());
  }
  if (from.transformdirection().size() > 0) {
    _internal_set_transformdirection(from._internal_transformdirection());
  }
  if (from.transformjson().size() > 0) {
    _internal_set_transformjson(from._internal_transformjson());
  }
  if (from.has_fromsr()) {
    _internal_mutable_fromsr()->::esriPBuffer::EsriTypes_SpatialReference::MergeFrom(from._internal_fromsr());
  }
  if (from.has_tosr()) {
    _internal_mutable_tosr()->::esriPBuffer::EsriTypes_SpatialReference::MergeFrom(from._internal_tosr());
  }
  if (from.wkid() != 0) {
    _internal_set_wkid(from._internal_wkid());
  }
}

void EsriTypes_DatumTransformation::CopyFrom(const EsriTypes_DatumTransformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes.DatumTransformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes_DatumTransformation::IsInitialized() const {
  return true;
}

void EsriTypes_DatumTransformation::InternalSwap(EsriTypes_DatumTransformation* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
  wkt_.Swap(&other->wkt_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  transformdirection_.Swap(&other->transformdirection_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  transformjson_.Swap(&other->transformjson_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EsriTypes_DatumTransformation, wkid_)
      + sizeof(EsriTypes_DatumTransformation::wkid_)
      - PROTOBUF_FIELD_OFFSET(EsriTypes_DatumTransformation, fromsr_)>(
          reinterpret_cast<char*>(&fromsr_),
          reinterpret_cast<char*>(&other->fromsr_));
}

std::string EsriTypes_DatumTransformation::GetTypeName() const {
  return "esriPBuffer.EsriTypes.DatumTransformation";
}


// ===================================================================

void EsriTypes::InitAsDefaultInstance() {
}
class EsriTypes::_Internal {
 public:
};

EsriTypes::EsriTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:esriPBuffer.EsriTypes)
}
EsriTypes::EsriTypes(const EsriTypes& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:esriPBuffer.EsriTypes)
}

void EsriTypes::SharedCtor() {
}

EsriTypes::~EsriTypes() {
  // @@protoc_insertion_point(destructor:esriPBuffer.EsriTypes)
  SharedDtor();
  _internal_metadata_.Delete<std::string>();
}

void EsriTypes::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EsriTypes::ArenaDtor(void* object) {
  EsriTypes* _this = reinterpret_cast< EsriTypes* >(object);
  (void)_this;
}
void EsriTypes::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EsriTypes::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EsriTypes& EsriTypes::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EsriTypes_esriPBuffer_2fEsriTypes_2eproto.base);
  return *internal_default_instance();
}


void EsriTypes::Clear() {
// @@protoc_insertion_point(message_clear_start:esriPBuffer.EsriTypes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* EsriTypes::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<std::string>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EsriTypes::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:esriPBuffer.EsriTypes)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:esriPBuffer.EsriTypes)
  return target;
}

size_t EsriTypes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:esriPBuffer.EsriTypes)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EsriTypes::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::PROTOBUF_NAMESPACE_ID::internal::DownCast<const EsriTypes*>(
      &from));
}

void EsriTypes::MergeFrom(const EsriTypes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:esriPBuffer.EsriTypes)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void EsriTypes::CopyFrom(const EsriTypes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:esriPBuffer.EsriTypes)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EsriTypes::IsInitialized() const {
  return true;
}

void EsriTypes::InternalSwap(EsriTypes* other) {
  using std::swap;
  _internal_metadata_.Swap<std::string>(&other->_internal_metadata_);
}

std::string EsriTypes::GetTypeName() const {
  return "esriPBuffer.EsriTypes";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace esriPBuffer
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_Scale* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_Scale >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_Scale >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_Translate* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_Translate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_Translate >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_Transform* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_Transform >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_Transform >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_QuantizationParameters* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_QuantizationParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_QuantizationParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_SpatialReference* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_SpatialReference >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_SpatialReference >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_FieldIndex* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_FieldIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_FieldIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_Value* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_Value >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_Value >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_Envelope* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_Envelope >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_Envelope >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_CodedValue* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_CodedValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_CodedValue >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_CodedValueDomain* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_CodedValueDomain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_CodedValueDomain >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_RangeDomain* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_RangeDomain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_RangeDomain >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_Domain* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_Domain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_Domain >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes_DatumTransformation* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes_DatumTransformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes_DatumTransformation >(arena);
}
template<> PROTOBUF_NOINLINE ::esriPBuffer::EsriTypes* Arena::CreateMaybeMessage< ::esriPBuffer::EsriTypes >(Arena* arena) {
  return Arena::CreateMessageInternal< ::esriPBuffer::EsriTypes >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
