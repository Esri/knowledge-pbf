/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.esriPBuffer = (function() {
    
        /**
         * Namespace esriPBuffer.
         * @exports esriPBuffer
         * @namespace
         */
        var esriPBuffer = {};
    
        esriPBuffer.EsriExtendedTypes = (function() {
    
            /**
             * Namespace EsriExtendedTypes.
             * @memberof esriPBuffer
             * @namespace
             */
            var EsriExtendedTypes = {};
    
            /**
             * FieldType enum.
             * @name esriPBuffer.EsriExtendedTypes.FieldType
             * @enum {number}
             * @property {number} esriFieldType_UNSPECIFIED=0 esriFieldType_UNSPECIFIED value
             * @property {number} esriFieldTypeSmallInteger=1 esriFieldTypeSmallInteger value
             * @property {number} esriFieldTypeInteger=2 esriFieldTypeInteger value
             * @property {number} esriFieldTypeSingle=3 esriFieldTypeSingle value
             * @property {number} esriFieldTypeDouble=4 esriFieldTypeDouble value
             * @property {number} esriFieldTypeString=5 esriFieldTypeString value
             * @property {number} esriFieldTypeDate=6 esriFieldTypeDate value
             * @property {number} esriFieldTypeOID=7 esriFieldTypeOID value
             * @property {number} esriFieldTypeGeometry=8 esriFieldTypeGeometry value
             * @property {number} esriFieldTypeBlob=9 esriFieldTypeBlob value
             * @property {number} esriFieldTypeRaster=10 esriFieldTypeRaster value
             * @property {number} esriFieldTypeGUID=11 esriFieldTypeGUID value
             * @property {number} esriFieldTypeGlobalID=12 esriFieldTypeGlobalID value
             * @property {number} esriFieldTypeXML=13 esriFieldTypeXML value
             */
            EsriExtendedTypes.FieldType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriFieldType_UNSPECIFIED"] = 0;
                values[valuesById[1] = "esriFieldTypeSmallInteger"] = 1;
                values[valuesById[2] = "esriFieldTypeInteger"] = 2;
                values[valuesById[3] = "esriFieldTypeSingle"] = 3;
                values[valuesById[4] = "esriFieldTypeDouble"] = 4;
                values[valuesById[5] = "esriFieldTypeString"] = 5;
                values[valuesById[6] = "esriFieldTypeDate"] = 6;
                values[valuesById[7] = "esriFieldTypeOID"] = 7;
                values[valuesById[8] = "esriFieldTypeGeometry"] = 8;
                values[valuesById[9] = "esriFieldTypeBlob"] = 9;
                values[valuesById[10] = "esriFieldTypeRaster"] = 10;
                values[valuesById[11] = "esriFieldTypeGUID"] = 11;
                values[valuesById[12] = "esriFieldTypeGlobalID"] = 12;
                values[valuesById[13] = "esriFieldTypeXML"] = 13;
                return values;
            })();
    
            return EsriExtendedTypes;
        })();
    
        esriPBuffer.ObjectIdArray = (function() {
    
            /**
             * Properties of an ObjectIdArray.
             * @memberof esriPBuffer
             * @interface IObjectIdArray
             * @property {Array.<number|Long>|null} [value] ObjectIdArray value
             */
    
            /**
             * Constructs a new ObjectIdArray.
             * @memberof esriPBuffer
             * @classdesc Represents an ObjectIdArray.
             * @implements IObjectIdArray
             * @constructor
             * @param {esriPBuffer.IObjectIdArray=} [properties] Properties to set
             */
            function ObjectIdArray(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ObjectIdArray value.
             * @member {Array.<number|Long>} value
             * @memberof esriPBuffer.ObjectIdArray
             * @instance
             */
            ObjectIdArray.prototype.value = $util.emptyArray;
    
            /**
             * Creates a new ObjectIdArray instance using the specified properties.
             * @function create
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {esriPBuffer.IObjectIdArray=} [properties] Properties to set
             * @returns {esriPBuffer.ObjectIdArray} ObjectIdArray instance
             */
            ObjectIdArray.create = function create(properties) {
                return new ObjectIdArray(properties);
            };
    
            /**
             * Encodes the specified ObjectIdArray message. Does not implicitly {@link esriPBuffer.ObjectIdArray.verify|verify} messages.
             * @function encode
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {esriPBuffer.IObjectIdArray} message ObjectIdArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectIdArray.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && message.value.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.value.length; ++i)
                        writer.uint64(message.value[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified ObjectIdArray message, length delimited. Does not implicitly {@link esriPBuffer.ObjectIdArray.verify|verify} messages.
             * @function encodeDelimited
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {esriPBuffer.IObjectIdArray} message ObjectIdArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectIdArray.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ObjectIdArray message from the specified reader or buffer.
             * @function decode
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {esriPBuffer.ObjectIdArray} ObjectIdArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectIdArray.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.ObjectIdArray();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.value.push(reader.uint64());
                        } else
                            message.value.push(reader.uint64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ObjectIdArray message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {esriPBuffer.ObjectIdArray} ObjectIdArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectIdArray.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ObjectIdArray message.
             * @function verify
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObjectIdArray.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i)
                        if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                            return "value: integer|Long[] expected";
                }
                return null;
            };
    
            /**
             * Creates an ObjectIdArray message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {esriPBuffer.ObjectIdArray} ObjectIdArray
             */
            ObjectIdArray.fromObject = function fromObject(object) {
                if (object instanceof $root.esriPBuffer.ObjectIdArray)
                    return object;
                var message = new $root.esriPBuffer.ObjectIdArray();
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".esriPBuffer.ObjectIdArray.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i)
                        if ($util.Long)
                            (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = true;
                        else if (typeof object.value[i] === "string")
                            message.value[i] = parseInt(object.value[i], 10);
                        else if (typeof object.value[i] === "number")
                            message.value[i] = object.value[i];
                        else if (typeof object.value[i] === "object")
                            message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber(true);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an ObjectIdArray message. Also converts values to other types if specified.
             * @function toObject
             * @memberof esriPBuffer.ObjectIdArray
             * @static
             * @param {esriPBuffer.ObjectIdArray} message ObjectIdArray
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObjectIdArray.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        if (typeof message.value[j] === "number")
                            object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                        else
                            object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber(true) : message.value[j];
                }
                return object;
            };
    
            /**
             * Converts this ObjectIdArray to JSON.
             * @function toJSON
             * @memberof esriPBuffer.ObjectIdArray
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ObjectIdArray.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ObjectIdArray;
        })();
    
        esriPBuffer.ObjectIdentifierSet = (function() {
    
            /**
             * Properties of an ObjectIdentifierSet.
             * @memberof esriPBuffer
             * @interface IObjectIdentifierSet
             * @property {esriPBuffer.IObjectIdArray|null} [oidArray] ObjectIdentifierSet oidArray
             * @property {Uint8Array|null} [globalidArray] ObjectIdentifierSet globalidArray
             */
    
            /**
             * Constructs a new ObjectIdentifierSet.
             * @memberof esriPBuffer
             * @classdesc Represents an ObjectIdentifierSet.
             * @implements IObjectIdentifierSet
             * @constructor
             * @param {esriPBuffer.IObjectIdentifierSet=} [properties] Properties to set
             */
            function ObjectIdentifierSet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ObjectIdentifierSet oidArray.
             * @member {esriPBuffer.IObjectIdArray|null|undefined} oidArray
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @instance
             */
            ObjectIdentifierSet.prototype.oidArray = null;
    
            /**
             * ObjectIdentifierSet globalidArray.
             * @member {Uint8Array|null|undefined} globalidArray
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @instance
             */
            ObjectIdentifierSet.prototype.globalidArray = null;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * ObjectIdentifierSet idArray.
             * @member {"oidArray"|"globalidArray"|undefined} idArray
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @instance
             */
            Object.defineProperty(ObjectIdentifierSet.prototype, "idArray", {
                get: $util.oneOfGetter($oneOfFields = ["oidArray", "globalidArray"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new ObjectIdentifierSet instance using the specified properties.
             * @function create
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {esriPBuffer.IObjectIdentifierSet=} [properties] Properties to set
             * @returns {esriPBuffer.ObjectIdentifierSet} ObjectIdentifierSet instance
             */
            ObjectIdentifierSet.create = function create(properties) {
                return new ObjectIdentifierSet(properties);
            };
    
            /**
             * Encodes the specified ObjectIdentifierSet message. Does not implicitly {@link esriPBuffer.ObjectIdentifierSet.verify|verify} messages.
             * @function encode
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {esriPBuffer.IObjectIdentifierSet} message ObjectIdentifierSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectIdentifierSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.oidArray != null && Object.hasOwnProperty.call(message, "oidArray"))
                    $root.esriPBuffer.ObjectIdArray.encode(message.oidArray, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.globalidArray != null && Object.hasOwnProperty.call(message, "globalidArray"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.globalidArray);
                return writer;
            };
    
            /**
             * Encodes the specified ObjectIdentifierSet message, length delimited. Does not implicitly {@link esriPBuffer.ObjectIdentifierSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {esriPBuffer.IObjectIdentifierSet} message ObjectIdentifierSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectIdentifierSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ObjectIdentifierSet message from the specified reader or buffer.
             * @function decode
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {esriPBuffer.ObjectIdentifierSet} ObjectIdentifierSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectIdentifierSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.ObjectIdentifierSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.oidArray = $root.esriPBuffer.ObjectIdArray.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.globalidArray = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ObjectIdentifierSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {esriPBuffer.ObjectIdentifierSet} ObjectIdentifierSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectIdentifierSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ObjectIdentifierSet message.
             * @function verify
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObjectIdentifierSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.oidArray != null && message.hasOwnProperty("oidArray")) {
                    properties.idArray = 1;
                    {
                        var error = $root.esriPBuffer.ObjectIdArray.verify(message.oidArray);
                        if (error)
                            return "oidArray." + error;
                    }
                }
                if (message.globalidArray != null && message.hasOwnProperty("globalidArray")) {
                    if (properties.idArray === 1)
                        return "idArray: multiple values";
                    properties.idArray = 1;
                    if (!(message.globalidArray && typeof message.globalidArray.length === "number" || $util.isString(message.globalidArray)))
                        return "globalidArray: buffer expected";
                }
                return null;
            };
    
            /**
             * Creates an ObjectIdentifierSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {esriPBuffer.ObjectIdentifierSet} ObjectIdentifierSet
             */
            ObjectIdentifierSet.fromObject = function fromObject(object) {
                if (object instanceof $root.esriPBuffer.ObjectIdentifierSet)
                    return object;
                var message = new $root.esriPBuffer.ObjectIdentifierSet();
                if (object.oidArray != null) {
                    if (typeof object.oidArray !== "object")
                        throw TypeError(".esriPBuffer.ObjectIdentifierSet.oidArray: object expected");
                    message.oidArray = $root.esriPBuffer.ObjectIdArray.fromObject(object.oidArray);
                }
                if (object.globalidArray != null)
                    if (typeof object.globalidArray === "string")
                        $util.base64.decode(object.globalidArray, message.globalidArray = $util.newBuffer($util.base64.length(object.globalidArray)), 0);
                    else if (object.globalidArray.length)
                        message.globalidArray = object.globalidArray;
                return message;
            };
    
            /**
             * Creates a plain object from an ObjectIdentifierSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @static
             * @param {esriPBuffer.ObjectIdentifierSet} message ObjectIdentifierSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObjectIdentifierSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.oidArray != null && message.hasOwnProperty("oidArray")) {
                    object.oidArray = $root.esriPBuffer.ObjectIdArray.toObject(message.oidArray, options);
                    if (options.oneofs)
                        object.idArray = "oidArray";
                }
                if (message.globalidArray != null && message.hasOwnProperty("globalidArray")) {
                    object.globalidArray = options.bytes === String ? $util.base64.encode(message.globalidArray, 0, message.globalidArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalidArray) : message.globalidArray;
                    if (options.oneofs)
                        object.idArray = "globalidArray";
                }
                return object;
            };
    
            /**
             * Converts this ObjectIdentifierSet to JSON.
             * @function toJSON
             * @memberof esriPBuffer.ObjectIdentifierSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ObjectIdentifierSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ObjectIdentifierSet;
        })();
    
        esriPBuffer.EsriTypes = (function() {
    
            /**
             * Properties of an EsriTypes.
             * @memberof esriPBuffer
             * @interface IEsriTypes
             */
    
            /**
             * Constructs a new EsriTypes.
             * @memberof esriPBuffer
             * @classdesc Represents an EsriTypes.
             * @implements IEsriTypes
             * @constructor
             * @param {esriPBuffer.IEsriTypes=} [properties] Properties to set
             */
            function EsriTypes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new EsriTypes instance using the specified properties.
             * @function create
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {esriPBuffer.IEsriTypes=} [properties] Properties to set
             * @returns {esriPBuffer.EsriTypes} EsriTypes instance
             */
            EsriTypes.create = function create(properties) {
                return new EsriTypes(properties);
            };
    
            /**
             * Encodes the specified EsriTypes message. Does not implicitly {@link esriPBuffer.EsriTypes.verify|verify} messages.
             * @function encode
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {esriPBuffer.IEsriTypes} message EsriTypes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EsriTypes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Encodes the specified EsriTypes message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {esriPBuffer.IEsriTypes} message EsriTypes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EsriTypes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an EsriTypes message from the specified reader or buffer.
             * @function decode
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {esriPBuffer.EsriTypes} EsriTypes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EsriTypes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an EsriTypes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {esriPBuffer.EsriTypes} EsriTypes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EsriTypes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an EsriTypes message.
             * @function verify
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EsriTypes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };
    
            /**
             * Creates an EsriTypes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {esriPBuffer.EsriTypes} EsriTypes
             */
            EsriTypes.fromObject = function fromObject(object) {
                if (object instanceof $root.esriPBuffer.EsriTypes)
                    return object;
                return new $root.esriPBuffer.EsriTypes();
            };
    
            /**
             * Creates a plain object from an EsriTypes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof esriPBuffer.EsriTypes
             * @static
             * @param {esriPBuffer.EsriTypes} message EsriTypes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EsriTypes.toObject = function toObject() {
                return {};
            };
    
            /**
             * Converts this EsriTypes to JSON.
             * @function toJSON
             * @memberof esriPBuffer.EsriTypes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EsriTypes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * GeometryType enum.
             * @name esriPBuffer.EsriTypes.GeometryType
             * @enum {number}
             * @property {number} esriGeometryTypePoint=0 esriGeometryTypePoint value
             * @property {number} esriGeometryTypeMultipoint=1 esriGeometryTypeMultipoint value
             * @property {number} esriGeometryTypePolyline=2 esriGeometryTypePolyline value
             * @property {number} esriGeometryTypePolygon=3 esriGeometryTypePolygon value
             * @property {number} esriGeometryTypeMultipatch=4 esriGeometryTypeMultipatch value
             * @property {number} esriGeometryTypeEnvelope=5 esriGeometryTypeEnvelope value
             */
            EsriTypes.GeometryType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriGeometryTypePoint"] = 0;
                values[valuesById[1] = "esriGeometryTypeMultipoint"] = 1;
                values[valuesById[2] = "esriGeometryTypePolyline"] = 2;
                values[valuesById[3] = "esriGeometryTypePolygon"] = 3;
                values[valuesById[4] = "esriGeometryTypeMultipatch"] = 4;
                values[valuesById[5] = "esriGeometryTypeEnvelope"] = 5;
                return values;
            })();
    
            /**
             * esriSpatialRel enum.
             * @name esriPBuffer.EsriTypes.esriSpatialRel
             * @enum {number}
             * @property {number} esriSpatialRelIntersects=0 esriSpatialRelIntersects value
             * @property {number} esriSpatialRelContains=1 esriSpatialRelContains value
             * @property {number} esriSpatialRelCrosses=2 esriSpatialRelCrosses value
             * @property {number} esriSpatialRelEnvelopeIntersects=3 esriSpatialRelEnvelopeIntersects value
             * @property {number} esriSpatialRelIndexIntersects=4 esriSpatialRelIndexIntersects value
             * @property {number} esriSpatialRelOverlaps=5 esriSpatialRelOverlaps value
             * @property {number} esriSpatialRelTouches=6 esriSpatialRelTouches value
             * @property {number} esriSpatialRelWithin=7 esriSpatialRelWithin value
             */
            EsriTypes.esriSpatialRel = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriSpatialRelIntersects"] = 0;
                values[valuesById[1] = "esriSpatialRelContains"] = 1;
                values[valuesById[2] = "esriSpatialRelCrosses"] = 2;
                values[valuesById[3] = "esriSpatialRelEnvelopeIntersects"] = 3;
                values[valuesById[4] = "esriSpatialRelIndexIntersects"] = 4;
                values[valuesById[5] = "esriSpatialRelOverlaps"] = 5;
                values[valuesById[6] = "esriSpatialRelTouches"] = 6;
                values[valuesById[7] = "esriSpatialRelWithin"] = 7;
                return values;
            })();
    
            /**
             * esriFeatureEncoding enum.
             * @name esriPBuffer.EsriTypes.esriFeatureEncoding
             * @enum {number}
             * @property {number} esriFeatureEncoding_UNSPECIFIED=0 esriFeatureEncoding_UNSPECIFIED value
             * @property {number} esriDefault=1 esriDefault value
             * @property {number} esriCompressedShapeBuffer=2 esriCompressedShapeBuffer value
             */
            EsriTypes.esriFeatureEncoding = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriFeatureEncoding_UNSPECIFIED"] = 0;
                values[valuesById[1] = "esriDefault"] = 1;
                values[valuesById[2] = "esriCompressedShapeBuffer"] = 2;
                return values;
            })();
    
            /**
             * MergePolicyType enum.
             * @name esriPBuffer.EsriTypes.MergePolicyType
             * @enum {number}
             * @property {number} esriMergePolicyType_UNSPECIFIED=0 esriMergePolicyType_UNSPECIFIED value
             * @property {number} esriMergePolicyTypeSumValues=1 esriMergePolicyTypeSumValues value
             * @property {number} esriMergePolicyTypeAreaWeighted=2 esriMergePolicyTypeAreaWeighted value
             * @property {number} esriMergePolicyTypeDefaultValue=3 esriMergePolicyTypeDefaultValue value
             */
            EsriTypes.MergePolicyType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriMergePolicyType_UNSPECIFIED"] = 0;
                values[valuesById[1] = "esriMergePolicyTypeSumValues"] = 1;
                values[valuesById[2] = "esriMergePolicyTypeAreaWeighted"] = 2;
                values[valuesById[3] = "esriMergePolicyTypeDefaultValue"] = 3;
                return values;
            })();
    
            /**
             * SplitPolicyType enum.
             * @name esriPBuffer.EsriTypes.SplitPolicyType
             * @enum {number}
             * @property {number} esriSplitPolicyType_UNSPECIFIED=0 esriSplitPolicyType_UNSPECIFIED value
             * @property {number} esriSplitPolicyTypeGeometryRatio=1 esriSplitPolicyTypeGeometryRatio value
             * @property {number} esriSplitPolicyTypeDuplicate=2 esriSplitPolicyTypeDuplicate value
             * @property {number} esriSplitPolicyTypeDefaultValue=3 esriSplitPolicyTypeDefaultValue value
             */
            EsriTypes.SplitPolicyType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriSplitPolicyType_UNSPECIFIED"] = 0;
                values[valuesById[1] = "esriSplitPolicyTypeGeometryRatio"] = 1;
                values[valuesById[2] = "esriSplitPolicyTypeDuplicate"] = 2;
                values[valuesById[3] = "esriSplitPolicyTypeDefaultValue"] = 3;
                return values;
            })();
    
            /**
             * QuantizeOriginPostion enum.
             * @name esriPBuffer.EsriTypes.QuantizeOriginPostion
             * @enum {number}
             * @property {number} upperLeft=0 upperLeft value
             * @property {number} lowerLeft=1 lowerLeft value
             */
            EsriTypes.QuantizeOriginPostion = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "upperLeft"] = 0;
                values[valuesById[1] = "lowerLeft"] = 1;
                return values;
            })();
    
            /**
             * QuantizeMode enum.
             * @name esriPBuffer.EsriTypes.QuantizeMode
             * @enum {number}
             * @property {number} view=0 view value
             * @property {number} edit=1 edit value
             */
            EsriTypes.QuantizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "view"] = 0;
                values[valuesById[1] = "edit"] = 1;
                return values;
            })();
    
            EsriTypes.Scale = (function() {
    
                /**
                 * Properties of a Scale.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IScale
                 * @property {number|null} [xScale] Scale xScale
                 * @property {number|null} [yScale] Scale yScale
                 * @property {number|null} [mScale] Scale mScale
                 * @property {number|null} [zScale] Scale zScale
                 */
    
                /**
                 * Constructs a new Scale.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a Scale.
                 * @implements IScale
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IScale=} [properties] Properties to set
                 */
                function Scale(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scale xScale.
                 * @member {number} xScale
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @instance
                 */
                Scale.prototype.xScale = 0;
    
                /**
                 * Scale yScale.
                 * @member {number} yScale
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @instance
                 */
                Scale.prototype.yScale = 0;
    
                /**
                 * Scale mScale.
                 * @member {number} mScale
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @instance
                 */
                Scale.prototype.mScale = 0;
    
                /**
                 * Scale zScale.
                 * @member {number} zScale
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @instance
                 */
                Scale.prototype.zScale = 0;
    
                /**
                 * Creates a new Scale instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {esriPBuffer.EsriTypes.IScale=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.Scale} Scale instance
                 */
                Scale.create = function create(properties) {
                    return new Scale(properties);
                };
    
                /**
                 * Encodes the specified Scale message. Does not implicitly {@link esriPBuffer.EsriTypes.Scale.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {esriPBuffer.EsriTypes.IScale} message Scale message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Scale.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.xScale != null && Object.hasOwnProperty.call(message, "xScale"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.xScale);
                    if (message.yScale != null && Object.hasOwnProperty.call(message, "yScale"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.yScale);
                    if (message.mScale != null && Object.hasOwnProperty.call(message, "mScale"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.mScale);
                    if (message.zScale != null && Object.hasOwnProperty.call(message, "zScale"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.zScale);
                    return writer;
                };
    
                /**
                 * Encodes the specified Scale message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.Scale.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {esriPBuffer.EsriTypes.IScale} message Scale message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Scale.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Scale message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.Scale} Scale
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Scale.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.Scale();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.xScale = reader.double();
                            break;
                        case 2:
                            message.yScale = reader.double();
                            break;
                        case 3:
                            message.mScale = reader.double();
                            break;
                        case 4:
                            message.zScale = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Scale message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.Scale} Scale
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Scale.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Scale message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Scale.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.xScale != null && message.hasOwnProperty("xScale"))
                        if (typeof message.xScale !== "number")
                            return "xScale: number expected";
                    if (message.yScale != null && message.hasOwnProperty("yScale"))
                        if (typeof message.yScale !== "number")
                            return "yScale: number expected";
                    if (message.mScale != null && message.hasOwnProperty("mScale"))
                        if (typeof message.mScale !== "number")
                            return "mScale: number expected";
                    if (message.zScale != null && message.hasOwnProperty("zScale"))
                        if (typeof message.zScale !== "number")
                            return "zScale: number expected";
                    return null;
                };
    
                /**
                 * Creates a Scale message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.Scale} Scale
                 */
                Scale.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.Scale)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.Scale();
                    if (object.xScale != null)
                        message.xScale = Number(object.xScale);
                    if (object.yScale != null)
                        message.yScale = Number(object.yScale);
                    if (object.mScale != null)
                        message.mScale = Number(object.mScale);
                    if (object.zScale != null)
                        message.zScale = Number(object.zScale);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Scale message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @static
                 * @param {esriPBuffer.EsriTypes.Scale} message Scale
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Scale.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.xScale = 0;
                        object.yScale = 0;
                        object.mScale = 0;
                        object.zScale = 0;
                    }
                    if (message.xScale != null && message.hasOwnProperty("xScale"))
                        object.xScale = options.json && !isFinite(message.xScale) ? String(message.xScale) : message.xScale;
                    if (message.yScale != null && message.hasOwnProperty("yScale"))
                        object.yScale = options.json && !isFinite(message.yScale) ? String(message.yScale) : message.yScale;
                    if (message.mScale != null && message.hasOwnProperty("mScale"))
                        object.mScale = options.json && !isFinite(message.mScale) ? String(message.mScale) : message.mScale;
                    if (message.zScale != null && message.hasOwnProperty("zScale"))
                        object.zScale = options.json && !isFinite(message.zScale) ? String(message.zScale) : message.zScale;
                    return object;
                };
    
                /**
                 * Converts this Scale to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.Scale
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Scale.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Scale;
            })();
    
            EsriTypes.Translate = (function() {
    
                /**
                 * Properties of a Translate.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface ITranslate
                 * @property {number|null} [xTranslate] Translate xTranslate
                 * @property {number|null} [yTranslate] Translate yTranslate
                 * @property {number|null} [mTranslate] Translate mTranslate
                 * @property {number|null} [zTranslate] Translate zTranslate
                 */
    
                /**
                 * Constructs a new Translate.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a Translate.
                 * @implements ITranslate
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.ITranslate=} [properties] Properties to set
                 */
                function Translate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Translate xTranslate.
                 * @member {number} xTranslate
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @instance
                 */
                Translate.prototype.xTranslate = 0;
    
                /**
                 * Translate yTranslate.
                 * @member {number} yTranslate
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @instance
                 */
                Translate.prototype.yTranslate = 0;
    
                /**
                 * Translate mTranslate.
                 * @member {number} mTranslate
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @instance
                 */
                Translate.prototype.mTranslate = 0;
    
                /**
                 * Translate zTranslate.
                 * @member {number} zTranslate
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @instance
                 */
                Translate.prototype.zTranslate = 0;
    
                /**
                 * Creates a new Translate instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {esriPBuffer.EsriTypes.ITranslate=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.Translate} Translate instance
                 */
                Translate.create = function create(properties) {
                    return new Translate(properties);
                };
    
                /**
                 * Encodes the specified Translate message. Does not implicitly {@link esriPBuffer.EsriTypes.Translate.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {esriPBuffer.EsriTypes.ITranslate} message Translate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Translate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.xTranslate != null && Object.hasOwnProperty.call(message, "xTranslate"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.xTranslate);
                    if (message.yTranslate != null && Object.hasOwnProperty.call(message, "yTranslate"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.yTranslate);
                    if (message.mTranslate != null && Object.hasOwnProperty.call(message, "mTranslate"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.mTranslate);
                    if (message.zTranslate != null && Object.hasOwnProperty.call(message, "zTranslate"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.zTranslate);
                    return writer;
                };
    
                /**
                 * Encodes the specified Translate message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.Translate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {esriPBuffer.EsriTypes.ITranslate} message Translate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Translate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Translate message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.Translate} Translate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Translate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.Translate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.xTranslate = reader.double();
                            break;
                        case 2:
                            message.yTranslate = reader.double();
                            break;
                        case 3:
                            message.mTranslate = reader.double();
                            break;
                        case 4:
                            message.zTranslate = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Translate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.Translate} Translate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Translate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Translate message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Translate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.xTranslate != null && message.hasOwnProperty("xTranslate"))
                        if (typeof message.xTranslate !== "number")
                            return "xTranslate: number expected";
                    if (message.yTranslate != null && message.hasOwnProperty("yTranslate"))
                        if (typeof message.yTranslate !== "number")
                            return "yTranslate: number expected";
                    if (message.mTranslate != null && message.hasOwnProperty("mTranslate"))
                        if (typeof message.mTranslate !== "number")
                            return "mTranslate: number expected";
                    if (message.zTranslate != null && message.hasOwnProperty("zTranslate"))
                        if (typeof message.zTranslate !== "number")
                            return "zTranslate: number expected";
                    return null;
                };
    
                /**
                 * Creates a Translate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.Translate} Translate
                 */
                Translate.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.Translate)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.Translate();
                    if (object.xTranslate != null)
                        message.xTranslate = Number(object.xTranslate);
                    if (object.yTranslate != null)
                        message.yTranslate = Number(object.yTranslate);
                    if (object.mTranslate != null)
                        message.mTranslate = Number(object.mTranslate);
                    if (object.zTranslate != null)
                        message.zTranslate = Number(object.zTranslate);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Translate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @static
                 * @param {esriPBuffer.EsriTypes.Translate} message Translate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Translate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.xTranslate = 0;
                        object.yTranslate = 0;
                        object.mTranslate = 0;
                        object.zTranslate = 0;
                    }
                    if (message.xTranslate != null && message.hasOwnProperty("xTranslate"))
                        object.xTranslate = options.json && !isFinite(message.xTranslate) ? String(message.xTranslate) : message.xTranslate;
                    if (message.yTranslate != null && message.hasOwnProperty("yTranslate"))
                        object.yTranslate = options.json && !isFinite(message.yTranslate) ? String(message.yTranslate) : message.yTranslate;
                    if (message.mTranslate != null && message.hasOwnProperty("mTranslate"))
                        object.mTranslate = options.json && !isFinite(message.mTranslate) ? String(message.mTranslate) : message.mTranslate;
                    if (message.zTranslate != null && message.hasOwnProperty("zTranslate"))
                        object.zTranslate = options.json && !isFinite(message.zTranslate) ? String(message.zTranslate) : message.zTranslate;
                    return object;
                };
    
                /**
                 * Converts this Translate to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.Translate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Translate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Translate;
            })();
    
            EsriTypes.Transform = (function() {
    
                /**
                 * Properties of a Transform.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface ITransform
                 * @property {esriPBuffer.EsriTypes.QuantizeOriginPostion|null} [quantizeOriginPostion] Transform quantizeOriginPostion
                 * @property {esriPBuffer.EsriTypes.IScale|null} [scale] Transform scale
                 * @property {esriPBuffer.EsriTypes.ITranslate|null} [translate] Transform translate
                 */
    
                /**
                 * Constructs a new Transform.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a Transform.
                 * @implements ITransform
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.ITransform=} [properties] Properties to set
                 */
                function Transform(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Transform quantizeOriginPostion.
                 * @member {esriPBuffer.EsriTypes.QuantizeOriginPostion} quantizeOriginPostion
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @instance
                 */
                Transform.prototype.quantizeOriginPostion = 0;
    
                /**
                 * Transform scale.
                 * @member {esriPBuffer.EsriTypes.IScale|null|undefined} scale
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @instance
                 */
                Transform.prototype.scale = null;
    
                /**
                 * Transform translate.
                 * @member {esriPBuffer.EsriTypes.ITranslate|null|undefined} translate
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @instance
                 */
                Transform.prototype.translate = null;
    
                /**
                 * Creates a new Transform instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {esriPBuffer.EsriTypes.ITransform=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.Transform} Transform instance
                 */
                Transform.create = function create(properties) {
                    return new Transform(properties);
                };
    
                /**
                 * Encodes the specified Transform message. Does not implicitly {@link esriPBuffer.EsriTypes.Transform.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {esriPBuffer.EsriTypes.ITransform} message Transform message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transform.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.quantizeOriginPostion != null && Object.hasOwnProperty.call(message, "quantizeOriginPostion"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.quantizeOriginPostion);
                    if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                        $root.esriPBuffer.EsriTypes.Scale.encode(message.scale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.translate != null && Object.hasOwnProperty.call(message, "translate"))
                        $root.esriPBuffer.EsriTypes.Translate.encode(message.translate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Transform message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.Transform.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {esriPBuffer.EsriTypes.ITransform} message Transform message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transform.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Transform message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.Transform} Transform
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transform.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.Transform();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.quantizeOriginPostion = reader.int32();
                            break;
                        case 2:
                            message.scale = $root.esriPBuffer.EsriTypes.Scale.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.translate = $root.esriPBuffer.EsriTypes.Translate.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Transform message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.Transform} Transform
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transform.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Transform message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Transform.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.quantizeOriginPostion != null && message.hasOwnProperty("quantizeOriginPostion"))
                        switch (message.quantizeOriginPostion) {
                        default:
                            return "quantizeOriginPostion: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        var error = $root.esriPBuffer.EsriTypes.Scale.verify(message.scale);
                        if (error)
                            return "scale." + error;
                    }
                    if (message.translate != null && message.hasOwnProperty("translate")) {
                        var error = $root.esriPBuffer.EsriTypes.Translate.verify(message.translate);
                        if (error)
                            return "translate." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Transform message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.Transform} Transform
                 */
                Transform.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.Transform)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.Transform();
                    switch (object.quantizeOriginPostion) {
                    case "upperLeft":
                    case 0:
                        message.quantizeOriginPostion = 0;
                        break;
                    case "lowerLeft":
                    case 1:
                        message.quantizeOriginPostion = 1;
                        break;
                    }
                    if (object.scale != null) {
                        if (typeof object.scale !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.Transform.scale: object expected");
                        message.scale = $root.esriPBuffer.EsriTypes.Scale.fromObject(object.scale);
                    }
                    if (object.translate != null) {
                        if (typeof object.translate !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.Transform.translate: object expected");
                        message.translate = $root.esriPBuffer.EsriTypes.Translate.fromObject(object.translate);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Transform message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @static
                 * @param {esriPBuffer.EsriTypes.Transform} message Transform
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Transform.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.quantizeOriginPostion = options.enums === String ? "upperLeft" : 0;
                        object.scale = null;
                        object.translate = null;
                    }
                    if (message.quantizeOriginPostion != null && message.hasOwnProperty("quantizeOriginPostion"))
                        object.quantizeOriginPostion = options.enums === String ? $root.esriPBuffer.EsriTypes.QuantizeOriginPostion[message.quantizeOriginPostion] : message.quantizeOriginPostion;
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        object.scale = $root.esriPBuffer.EsriTypes.Scale.toObject(message.scale, options);
                    if (message.translate != null && message.hasOwnProperty("translate"))
                        object.translate = $root.esriPBuffer.EsriTypes.Translate.toObject(message.translate, options);
                    return object;
                };
    
                /**
                 * Converts this Transform to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.Transform
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Transform.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Transform;
            })();
    
            EsriTypes.QuantizationParameters = (function() {
    
                /**
                 * Properties of a QuantizationParameters.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IQuantizationParameters
                 * @property {esriPBuffer.EsriTypes.IEnvelope|null} [extent] QuantizationParameters extent
                 * @property {esriPBuffer.EsriTypes.QuantizeMode|null} [mode] QuantizationParameters mode
                 * @property {esriPBuffer.EsriTypes.QuantizeOriginPostion|null} [quantizeOriginPostion] QuantizationParameters quantizeOriginPostion
                 * @property {number|null} [tolerance] QuantizationParameters tolerance
                 */
    
                /**
                 * Constructs a new QuantizationParameters.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a QuantizationParameters.
                 * @implements IQuantizationParameters
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IQuantizationParameters=} [properties] Properties to set
                 */
                function QuantizationParameters(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QuantizationParameters extent.
                 * @member {esriPBuffer.EsriTypes.IEnvelope|null|undefined} extent
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.extent = null;
    
                /**
                 * QuantizationParameters mode.
                 * @member {esriPBuffer.EsriTypes.QuantizeMode} mode
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.mode = 0;
    
                /**
                 * QuantizationParameters quantizeOriginPostion.
                 * @member {esriPBuffer.EsriTypes.QuantizeOriginPostion} quantizeOriginPostion
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.quantizeOriginPostion = 0;
    
                /**
                 * QuantizationParameters tolerance.
                 * @member {number} tolerance
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.tolerance = 0;
    
                /**
                 * Creates a new QuantizationParameters instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.EsriTypes.IQuantizationParameters=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.QuantizationParameters} QuantizationParameters instance
                 */
                QuantizationParameters.create = function create(properties) {
                    return new QuantizationParameters(properties);
                };
    
                /**
                 * Encodes the specified QuantizationParameters message. Does not implicitly {@link esriPBuffer.EsriTypes.QuantizationParameters.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.EsriTypes.IQuantizationParameters} message QuantizationParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuantizationParameters.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.extent != null && Object.hasOwnProperty.call(message, "extent"))
                        $root.esriPBuffer.EsriTypes.Envelope.encode(message.extent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
                    if (message.quantizeOriginPostion != null && Object.hasOwnProperty.call(message, "quantizeOriginPostion"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.quantizeOriginPostion);
                    if (message.tolerance != null && Object.hasOwnProperty.call(message, "tolerance"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.tolerance);
                    return writer;
                };
    
                /**
                 * Encodes the specified QuantizationParameters message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.QuantizationParameters.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.EsriTypes.IQuantizationParameters} message QuantizationParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuantizationParameters.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QuantizationParameters message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.QuantizationParameters} QuantizationParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuantizationParameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.QuantizationParameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.extent = $root.esriPBuffer.EsriTypes.Envelope.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.mode = reader.int32();
                            break;
                        case 3:
                            message.quantizeOriginPostion = reader.int32();
                            break;
                        case 4:
                            message.tolerance = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QuantizationParameters message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.QuantizationParameters} QuantizationParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuantizationParameters.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QuantizationParameters message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QuantizationParameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.extent != null && message.hasOwnProperty("extent")) {
                        var error = $root.esriPBuffer.EsriTypes.Envelope.verify(message.extent);
                        if (error)
                            return "extent." + error;
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.quantizeOriginPostion != null && message.hasOwnProperty("quantizeOriginPostion"))
                        switch (message.quantizeOriginPostion) {
                        default:
                            return "quantizeOriginPostion: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.tolerance != null && message.hasOwnProperty("tolerance"))
                        if (typeof message.tolerance !== "number")
                            return "tolerance: number expected";
                    return null;
                };
    
                /**
                 * Creates a QuantizationParameters message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.QuantizationParameters} QuantizationParameters
                 */
                QuantizationParameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.QuantizationParameters)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.QuantizationParameters();
                    if (object.extent != null) {
                        if (typeof object.extent !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.QuantizationParameters.extent: object expected");
                        message.extent = $root.esriPBuffer.EsriTypes.Envelope.fromObject(object.extent);
                    }
                    switch (object.mode) {
                    case "view":
                    case 0:
                        message.mode = 0;
                        break;
                    case "edit":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    switch (object.quantizeOriginPostion) {
                    case "upperLeft":
                    case 0:
                        message.quantizeOriginPostion = 0;
                        break;
                    case "lowerLeft":
                    case 1:
                        message.quantizeOriginPostion = 1;
                        break;
                    }
                    if (object.tolerance != null)
                        message.tolerance = Number(object.tolerance);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QuantizationParameters message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.EsriTypes.QuantizationParameters} message QuantizationParameters
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QuantizationParameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.extent = null;
                        object.mode = options.enums === String ? "view" : 0;
                        object.quantizeOriginPostion = options.enums === String ? "upperLeft" : 0;
                        object.tolerance = 0;
                    }
                    if (message.extent != null && message.hasOwnProperty("extent"))
                        object.extent = $root.esriPBuffer.EsriTypes.Envelope.toObject(message.extent, options);
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.esriPBuffer.EsriTypes.QuantizeMode[message.mode] : message.mode;
                    if (message.quantizeOriginPostion != null && message.hasOwnProperty("quantizeOriginPostion"))
                        object.quantizeOriginPostion = options.enums === String ? $root.esriPBuffer.EsriTypes.QuantizeOriginPostion[message.quantizeOriginPostion] : message.quantizeOriginPostion;
                    if (message.tolerance != null && message.hasOwnProperty("tolerance"))
                        object.tolerance = options.json && !isFinite(message.tolerance) ? String(message.tolerance) : message.tolerance;
                    return object;
                };
    
                /**
                 * Converts this QuantizationParameters to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.QuantizationParameters
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QuantizationParameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QuantizationParameters;
            })();
    
            EsriTypes.SpatialReference = (function() {
    
                /**
                 * Properties of a SpatialReference.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface ISpatialReference
                 * @property {number|null} [wkid] SpatialReference wkid
                 * @property {number|null} [lastestWkid] SpatialReference lastestWkid
                 * @property {number|null} [vcsWkid] SpatialReference vcsWkid
                 * @property {number|null} [latestVcsWkid] SpatialReference latestVcsWkid
                 * @property {string|null} [wkt] SpatialReference wkt
                 * @property {number|null} [sdesrid] SpatialReference sdesrid
                 */
    
                /**
                 * Constructs a new SpatialReference.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a SpatialReference.
                 * @implements ISpatialReference
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.ISpatialReference=} [properties] Properties to set
                 */
                function SpatialReference(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SpatialReference wkid.
                 * @member {number} wkid
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 */
                SpatialReference.prototype.wkid = 0;
    
                /**
                 * SpatialReference lastestWkid.
                 * @member {number} lastestWkid
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 */
                SpatialReference.prototype.lastestWkid = 0;
    
                /**
                 * SpatialReference vcsWkid.
                 * @member {number} vcsWkid
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 */
                SpatialReference.prototype.vcsWkid = 0;
    
                /**
                 * SpatialReference latestVcsWkid.
                 * @member {number} latestVcsWkid
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 */
                SpatialReference.prototype.latestVcsWkid = 0;
    
                /**
                 * SpatialReference wkt.
                 * @member {string} wkt
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 */
                SpatialReference.prototype.wkt = "";
    
                /**
                 * SpatialReference sdesrid.
                 * @member {number} sdesrid
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 */
                SpatialReference.prototype.sdesrid = 0;
    
                /**
                 * Creates a new SpatialReference instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {esriPBuffer.EsriTypes.ISpatialReference=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.SpatialReference} SpatialReference instance
                 */
                SpatialReference.create = function create(properties) {
                    return new SpatialReference(properties);
                };
    
                /**
                 * Encodes the specified SpatialReference message. Does not implicitly {@link esriPBuffer.EsriTypes.SpatialReference.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {esriPBuffer.EsriTypes.ISpatialReference} message SpatialReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpatialReference.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.wkid != null && Object.hasOwnProperty.call(message, "wkid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.wkid);
                    if (message.lastestWkid != null && Object.hasOwnProperty.call(message, "lastestWkid"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lastestWkid);
                    if (message.vcsWkid != null && Object.hasOwnProperty.call(message, "vcsWkid"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.vcsWkid);
                    if (message.latestVcsWkid != null && Object.hasOwnProperty.call(message, "latestVcsWkid"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.latestVcsWkid);
                    if (message.wkt != null && Object.hasOwnProperty.call(message, "wkt"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.wkt);
                    if (message.sdesrid != null && Object.hasOwnProperty.call(message, "sdesrid"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.sdesrid);
                    return writer;
                };
    
                /**
                 * Encodes the specified SpatialReference message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.SpatialReference.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {esriPBuffer.EsriTypes.ISpatialReference} message SpatialReference message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SpatialReference.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SpatialReference message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.SpatialReference} SpatialReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpatialReference.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.SpatialReference();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.wkid = reader.uint32();
                            break;
                        case 2:
                            message.lastestWkid = reader.uint32();
                            break;
                        case 3:
                            message.vcsWkid = reader.uint32();
                            break;
                        case 4:
                            message.latestVcsWkid = reader.uint32();
                            break;
                        case 5:
                            message.wkt = reader.string();
                            break;
                        case 6:
                            message.sdesrid = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SpatialReference message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.SpatialReference} SpatialReference
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SpatialReference.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SpatialReference message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SpatialReference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.wkid != null && message.hasOwnProperty("wkid"))
                        if (!$util.isInteger(message.wkid))
                            return "wkid: integer expected";
                    if (message.lastestWkid != null && message.hasOwnProperty("lastestWkid"))
                        if (!$util.isInteger(message.lastestWkid))
                            return "lastestWkid: integer expected";
                    if (message.vcsWkid != null && message.hasOwnProperty("vcsWkid"))
                        if (!$util.isInteger(message.vcsWkid))
                            return "vcsWkid: integer expected";
                    if (message.latestVcsWkid != null && message.hasOwnProperty("latestVcsWkid"))
                        if (!$util.isInteger(message.latestVcsWkid))
                            return "latestVcsWkid: integer expected";
                    if (message.wkt != null && message.hasOwnProperty("wkt"))
                        if (!$util.isString(message.wkt))
                            return "wkt: string expected";
                    if (message.sdesrid != null && message.hasOwnProperty("sdesrid"))
                        if (!$util.isInteger(message.sdesrid))
                            return "sdesrid: integer expected";
                    return null;
                };
    
                /**
                 * Creates a SpatialReference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.SpatialReference} SpatialReference
                 */
                SpatialReference.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.SpatialReference)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.SpatialReference();
                    if (object.wkid != null)
                        message.wkid = object.wkid >>> 0;
                    if (object.lastestWkid != null)
                        message.lastestWkid = object.lastestWkid >>> 0;
                    if (object.vcsWkid != null)
                        message.vcsWkid = object.vcsWkid >>> 0;
                    if (object.latestVcsWkid != null)
                        message.latestVcsWkid = object.latestVcsWkid >>> 0;
                    if (object.wkt != null)
                        message.wkt = String(object.wkt);
                    if (object.sdesrid != null)
                        message.sdesrid = object.sdesrid >>> 0;
                    return message;
                };
    
                /**
                 * Creates a plain object from a SpatialReference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @static
                 * @param {esriPBuffer.EsriTypes.SpatialReference} message SpatialReference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SpatialReference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.wkid = 0;
                        object.lastestWkid = 0;
                        object.vcsWkid = 0;
                        object.latestVcsWkid = 0;
                        object.wkt = "";
                        object.sdesrid = 0;
                    }
                    if (message.wkid != null && message.hasOwnProperty("wkid"))
                        object.wkid = message.wkid;
                    if (message.lastestWkid != null && message.hasOwnProperty("lastestWkid"))
                        object.lastestWkid = message.lastestWkid;
                    if (message.vcsWkid != null && message.hasOwnProperty("vcsWkid"))
                        object.vcsWkid = message.vcsWkid;
                    if (message.latestVcsWkid != null && message.hasOwnProperty("latestVcsWkid"))
                        object.latestVcsWkid = message.latestVcsWkid;
                    if (message.wkt != null && message.hasOwnProperty("wkt"))
                        object.wkt = message.wkt;
                    if (message.sdesrid != null && message.hasOwnProperty("sdesrid"))
                        object.sdesrid = message.sdesrid;
                    return object;
                };
    
                /**
                 * Converts this SpatialReference to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.SpatialReference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SpatialReference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SpatialReference;
            })();
    
            EsriTypes.FieldIndex = (function() {
    
                /**
                 * Properties of a FieldIndex.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IFieldIndex
                 * @property {string|null} [name] FieldIndex name
                 * @property {string|null} [fields] FieldIndex fields
                 * @property {boolean|null} [isAscending] FieldIndex isAscending
                 * @property {boolean|null} [isUnique] FieldIndex isUnique
                 * @property {string|null} [description] FieldIndex description
                 */
    
                /**
                 * Constructs a new FieldIndex.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a FieldIndex.
                 * @implements IFieldIndex
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IFieldIndex=} [properties] Properties to set
                 */
                function FieldIndex(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FieldIndex name.
                 * @member {string} name
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @instance
                 */
                FieldIndex.prototype.name = "";
    
                /**
                 * FieldIndex fields.
                 * @member {string} fields
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @instance
                 */
                FieldIndex.prototype.fields = "";
    
                /**
                 * FieldIndex isAscending.
                 * @member {boolean} isAscending
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @instance
                 */
                FieldIndex.prototype.isAscending = false;
    
                /**
                 * FieldIndex isUnique.
                 * @member {boolean} isUnique
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @instance
                 */
                FieldIndex.prototype.isUnique = false;
    
                /**
                 * FieldIndex description.
                 * @member {string} description
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @instance
                 */
                FieldIndex.prototype.description = "";
    
                /**
                 * Creates a new FieldIndex instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {esriPBuffer.EsriTypes.IFieldIndex=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.FieldIndex} FieldIndex instance
                 */
                FieldIndex.create = function create(properties) {
                    return new FieldIndex(properties);
                };
    
                /**
                 * Encodes the specified FieldIndex message. Does not implicitly {@link esriPBuffer.EsriTypes.FieldIndex.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {esriPBuffer.EsriTypes.IFieldIndex} message FieldIndex message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldIndex.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.fields != null && Object.hasOwnProperty.call(message, "fields"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.fields);
                    if (message.isAscending != null && Object.hasOwnProperty.call(message, "isAscending"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isAscending);
                    if (message.isUnique != null && Object.hasOwnProperty.call(message, "isUnique"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isUnique);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.description);
                    return writer;
                };
    
                /**
                 * Encodes the specified FieldIndex message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.FieldIndex.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {esriPBuffer.EsriTypes.IFieldIndex} message FieldIndex message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FieldIndex.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FieldIndex message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.FieldIndex} FieldIndex
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldIndex.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.FieldIndex();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.fields = reader.string();
                            break;
                        case 3:
                            message.isAscending = reader.bool();
                            break;
                        case 4:
                            message.isUnique = reader.bool();
                            break;
                        case 5:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FieldIndex message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.FieldIndex} FieldIndex
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FieldIndex.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FieldIndex message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldIndex.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.fields != null && message.hasOwnProperty("fields"))
                        if (!$util.isString(message.fields))
                            return "fields: string expected";
                    if (message.isAscending != null && message.hasOwnProperty("isAscending"))
                        if (typeof message.isAscending !== "boolean")
                            return "isAscending: boolean expected";
                    if (message.isUnique != null && message.hasOwnProperty("isUnique"))
                        if (typeof message.isUnique !== "boolean")
                            return "isUnique: boolean expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };
    
                /**
                 * Creates a FieldIndex message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.FieldIndex} FieldIndex
                 */
                FieldIndex.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.FieldIndex)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.FieldIndex();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.fields != null)
                        message.fields = String(object.fields);
                    if (object.isAscending != null)
                        message.isAscending = Boolean(object.isAscending);
                    if (object.isUnique != null)
                        message.isUnique = Boolean(object.isUnique);
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FieldIndex message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @static
                 * @param {esriPBuffer.EsriTypes.FieldIndex} message FieldIndex
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldIndex.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.fields = "";
                        object.isAscending = false;
                        object.isUnique = false;
                        object.description = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.fields != null && message.hasOwnProperty("fields"))
                        object.fields = message.fields;
                    if (message.isAscending != null && message.hasOwnProperty("isAscending"))
                        object.isAscending = message.isAscending;
                    if (message.isUnique != null && message.hasOwnProperty("isUnique"))
                        object.isUnique = message.isUnique;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };
    
                /**
                 * Converts this FieldIndex to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.FieldIndex
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldIndex.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FieldIndex;
            })();
    
            EsriTypes.Value = (function() {
    
                /**
                 * Properties of a Value.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IValue
                 * @property {string|null} [stringValue] Value stringValue
                 * @property {number|null} [floatValue] Value floatValue
                 * @property {number|null} [doubleValue] Value doubleValue
                 * @property {number|null} [sintValue] Value sintValue
                 * @property {number|null} [uintValue] Value uintValue
                 * @property {number|Long|null} [int64Value] Value int64Value
                 * @property {number|Long|null} [uint64Value] Value uint64Value
                 * @property {number|Long|null} [sint64Value] Value sint64Value
                 * @property {boolean|null} [boolValue] Value boolValue
                 */
    
                /**
                 * Constructs a new Value.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a Value.
                 * @implements IValue
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IValue=} [properties] Properties to set
                 */
                function Value(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Value stringValue.
                 * @member {string|null|undefined} stringValue
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.stringValue = null;
    
                /**
                 * Value floatValue.
                 * @member {number|null|undefined} floatValue
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.floatValue = null;
    
                /**
                 * Value doubleValue.
                 * @member {number|null|undefined} doubleValue
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.doubleValue = null;
    
                /**
                 * Value sintValue.
                 * @member {number|null|undefined} sintValue
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.sintValue = null;
    
                /**
                 * Value uintValue.
                 * @member {number|null|undefined} uintValue
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.uintValue = null;
    
                /**
                 * Value int64Value.
                 * @member {number|Long|null|undefined} int64Value
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.int64Value = null;
    
                /**
                 * Value uint64Value.
                 * @member {number|Long|null|undefined} uint64Value
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.uint64Value = null;
    
                /**
                 * Value sint64Value.
                 * @member {number|Long|null|undefined} sint64Value
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.sint64Value = null;
    
                /**
                 * Value boolValue.
                 * @member {boolean|null|undefined} boolValue
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Value.prototype.boolValue = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Value valueType.
                 * @member {"stringValue"|"floatValue"|"doubleValue"|"sintValue"|"uintValue"|"int64Value"|"uint64Value"|"sint64Value"|"boolValue"|undefined} valueType
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 */
                Object.defineProperty(Value.prototype, "valueType", {
                    get: $util.oneOfGetter($oneOfFields = ["stringValue", "floatValue", "doubleValue", "sintValue", "uintValue", "int64Value", "uint64Value", "sint64Value", "boolValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Value instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {esriPBuffer.EsriTypes.IValue=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.Value} Value instance
                 */
                Value.create = function create(properties) {
                    return new Value(properties);
                };
    
                /**
                 * Encodes the specified Value message. Does not implicitly {@link esriPBuffer.EsriTypes.Value.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {esriPBuffer.EsriTypes.IValue} message Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Value.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);
                    if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.floatValue);
                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.doubleValue);
                    if (message.sintValue != null && Object.hasOwnProperty.call(message, "sintValue"))
                        writer.uint32(/* id 4, wireType 0 =*/32).sint32(message.sintValue);
                    if (message.uintValue != null && Object.hasOwnProperty.call(message, "uintValue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.uintValue);
                    if (message.int64Value != null && Object.hasOwnProperty.call(message, "int64Value"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int64(message.int64Value);
                    if (message.uint64Value != null && Object.hasOwnProperty.call(message, "uint64Value"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.uint64Value);
                    if (message.sint64Value != null && Object.hasOwnProperty.call(message, "sint64Value"))
                        writer.uint32(/* id 8, wireType 0 =*/64).sint64(message.sint64Value);
                    if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.boolValue);
                    return writer;
                };
    
                /**
                 * Encodes the specified Value message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.Value.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {esriPBuffer.EsriTypes.IValue} message Value message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Value.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Value message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.Value} Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Value.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.Value();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringValue = reader.string();
                            break;
                        case 2:
                            message.floatValue = reader.float();
                            break;
                        case 3:
                            message.doubleValue = reader.double();
                            break;
                        case 4:
                            message.sintValue = reader.sint32();
                            break;
                        case 5:
                            message.uintValue = reader.uint32();
                            break;
                        case 6:
                            message.int64Value = reader.int64();
                            break;
                        case 7:
                            message.uint64Value = reader.uint64();
                            break;
                        case 8:
                            message.sint64Value = reader.sint64();
                            break;
                        case 9:
                            message.boolValue = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Value message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.Value} Value
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Value.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Value message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Value.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        properties.valueType = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.floatValue !== "number")
                            return "floatValue: number expected";
                    }
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.doubleValue !== "number")
                            return "doubleValue: number expected";
                    }
                    if (message.sintValue != null && message.hasOwnProperty("sintValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.sintValue))
                            return "sintValue: integer expected";
                    }
                    if (message.uintValue != null && message.hasOwnProperty("uintValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.uintValue))
                            return "uintValue: integer expected";
                    }
                    if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                            return "int64Value: integer|Long expected";
                    }
                    if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.uint64Value) && !(message.uint64Value && $util.isInteger(message.uint64Value.low) && $util.isInteger(message.uint64Value.high)))
                            return "uint64Value: integer|Long expected";
                    }
                    if (message.sint64Value != null && message.hasOwnProperty("sint64Value")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.sint64Value) && !(message.sint64Value && $util.isInteger(message.sint64Value.low) && $util.isInteger(message.sint64Value.high)))
                            return "sint64Value: integer|Long expected";
                    }
                    if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.boolValue !== "boolean")
                            return "boolValue: boolean expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a Value message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.Value} Value
                 */
                Value.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.Value)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.Value();
                    if (object.stringValue != null)
                        message.stringValue = String(object.stringValue);
                    if (object.floatValue != null)
                        message.floatValue = Number(object.floatValue);
                    if (object.doubleValue != null)
                        message.doubleValue = Number(object.doubleValue);
                    if (object.sintValue != null)
                        message.sintValue = object.sintValue | 0;
                    if (object.uintValue != null)
                        message.uintValue = object.uintValue >>> 0;
                    if (object.int64Value != null)
                        if ($util.Long)
                            (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                        else if (typeof object.int64Value === "string")
                            message.int64Value = parseInt(object.int64Value, 10);
                        else if (typeof object.int64Value === "number")
                            message.int64Value = object.int64Value;
                        else if (typeof object.int64Value === "object")
                            message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
                    if (object.uint64Value != null)
                        if ($util.Long)
                            (message.uint64Value = $util.Long.fromValue(object.uint64Value)).unsigned = true;
                        else if (typeof object.uint64Value === "string")
                            message.uint64Value = parseInt(object.uint64Value, 10);
                        else if (typeof object.uint64Value === "number")
                            message.uint64Value = object.uint64Value;
                        else if (typeof object.uint64Value === "object")
                            message.uint64Value = new $util.LongBits(object.uint64Value.low >>> 0, object.uint64Value.high >>> 0).toNumber(true);
                    if (object.sint64Value != null)
                        if ($util.Long)
                            (message.sint64Value = $util.Long.fromValue(object.sint64Value)).unsigned = false;
                        else if (typeof object.sint64Value === "string")
                            message.sint64Value = parseInt(object.sint64Value, 10);
                        else if (typeof object.sint64Value === "number")
                            message.sint64Value = object.sint64Value;
                        else if (typeof object.sint64Value === "object")
                            message.sint64Value = new $util.LongBits(object.sint64Value.low >>> 0, object.sint64Value.high >>> 0).toNumber();
                    if (object.boolValue != null)
                        message.boolValue = Boolean(object.boolValue);
                    return message;
                };
    
                /**
                 * Creates a plain object from a Value message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @static
                 * @param {esriPBuffer.EsriTypes.Value} message Value
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Value.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        object.stringValue = message.stringValue;
                        if (options.oneofs)
                            object.valueType = "stringValue";
                    }
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                        if (options.oneofs)
                            object.valueType = "floatValue";
                    }
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                        object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                        if (options.oneofs)
                            object.valueType = "doubleValue";
                    }
                    if (message.sintValue != null && message.hasOwnProperty("sintValue")) {
                        object.sintValue = message.sintValue;
                        if (options.oneofs)
                            object.valueType = "sintValue";
                    }
                    if (message.uintValue != null && message.hasOwnProperty("uintValue")) {
                        object.uintValue = message.uintValue;
                        if (options.oneofs)
                            object.valueType = "uintValue";
                    }
                    if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                        if (typeof message.int64Value === "number")
                            object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                        else
                            object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
                        if (options.oneofs)
                            object.valueType = "int64Value";
                    }
                    if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                        if (typeof message.uint64Value === "number")
                            object.uint64Value = options.longs === String ? String(message.uint64Value) : message.uint64Value;
                        else
                            object.uint64Value = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Value) : options.longs === Number ? new $util.LongBits(message.uint64Value.low >>> 0, message.uint64Value.high >>> 0).toNumber(true) : message.uint64Value;
                        if (options.oneofs)
                            object.valueType = "uint64Value";
                    }
                    if (message.sint64Value != null && message.hasOwnProperty("sint64Value")) {
                        if (typeof message.sint64Value === "number")
                            object.sint64Value = options.longs === String ? String(message.sint64Value) : message.sint64Value;
                        else
                            object.sint64Value = options.longs === String ? $util.Long.prototype.toString.call(message.sint64Value) : options.longs === Number ? new $util.LongBits(message.sint64Value.low >>> 0, message.sint64Value.high >>> 0).toNumber() : message.sint64Value;
                        if (options.oneofs)
                            object.valueType = "sint64Value";
                    }
                    if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                        object.boolValue = message.boolValue;
                        if (options.oneofs)
                            object.valueType = "boolValue";
                    }
                    return object;
                };
    
                /**
                 * Converts this Value to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.Value
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Value.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Value;
            })();
    
            EsriTypes.Envelope = (function() {
    
                /**
                 * Properties of an Envelope.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IEnvelope
                 * @property {number|null} [XMin] Envelope XMin
                 * @property {number|null} [YMin] Envelope YMin
                 * @property {number|null} [XMax] Envelope XMax
                 * @property {number|null} [YMax] Envelope YMax
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [SpatialReference] Envelope SpatialReference
                 */
    
                /**
                 * Constructs a new Envelope.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents an Envelope.
                 * @implements IEnvelope
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IEnvelope=} [properties] Properties to set
                 */
                function Envelope(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Envelope XMin.
                 * @member {number} XMin
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @instance
                 */
                Envelope.prototype.XMin = 0;
    
                /**
                 * Envelope YMin.
                 * @member {number} YMin
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @instance
                 */
                Envelope.prototype.YMin = 0;
    
                /**
                 * Envelope XMax.
                 * @member {number} XMax
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @instance
                 */
                Envelope.prototype.XMax = 0;
    
                /**
                 * Envelope YMax.
                 * @member {number} YMax
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @instance
                 */
                Envelope.prototype.YMax = 0;
    
                /**
                 * Envelope SpatialReference.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} SpatialReference
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @instance
                 */
                Envelope.prototype.SpatialReference = null;
    
                /**
                 * Creates a new Envelope instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {esriPBuffer.EsriTypes.IEnvelope=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.Envelope} Envelope instance
                 */
                Envelope.create = function create(properties) {
                    return new Envelope(properties);
                };
    
                /**
                 * Encodes the specified Envelope message. Does not implicitly {@link esriPBuffer.EsriTypes.Envelope.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {esriPBuffer.EsriTypes.IEnvelope} message Envelope message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envelope.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.XMin != null && Object.hasOwnProperty.call(message, "XMin"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.XMin);
                    if (message.YMin != null && Object.hasOwnProperty.call(message, "YMin"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.YMin);
                    if (message.XMax != null && Object.hasOwnProperty.call(message, "XMax"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.XMax);
                    if (message.YMax != null && Object.hasOwnProperty.call(message, "YMax"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.YMax);
                    if (message.SpatialReference != null && Object.hasOwnProperty.call(message, "SpatialReference"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.SpatialReference, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Envelope message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.Envelope.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {esriPBuffer.EsriTypes.IEnvelope} message Envelope message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Envelope.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Envelope message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.Envelope} Envelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envelope.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.Envelope();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.XMin = reader.double();
                            break;
                        case 2:
                            message.YMin = reader.double();
                            break;
                        case 3:
                            message.XMax = reader.double();
                            break;
                        case 4:
                            message.YMax = reader.double();
                            break;
                        case 5:
                            message.SpatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Envelope message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.Envelope} Envelope
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Envelope.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Envelope message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Envelope.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.XMin != null && message.hasOwnProperty("XMin"))
                        if (typeof message.XMin !== "number")
                            return "XMin: number expected";
                    if (message.YMin != null && message.hasOwnProperty("YMin"))
                        if (typeof message.YMin !== "number")
                            return "YMin: number expected";
                    if (message.XMax != null && message.hasOwnProperty("XMax"))
                        if (typeof message.XMax !== "number")
                            return "XMax: number expected";
                    if (message.YMax != null && message.hasOwnProperty("YMax"))
                        if (typeof message.YMax !== "number")
                            return "YMax: number expected";
                    if (message.SpatialReference != null && message.hasOwnProperty("SpatialReference")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.SpatialReference);
                        if (error)
                            return "SpatialReference." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.Envelope} Envelope
                 */
                Envelope.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.Envelope)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.Envelope();
                    if (object.XMin != null)
                        message.XMin = Number(object.XMin);
                    if (object.YMin != null)
                        message.YMin = Number(object.YMin);
                    if (object.XMax != null)
                        message.XMax = Number(object.XMax);
                    if (object.YMax != null)
                        message.YMax = Number(object.YMax);
                    if (object.SpatialReference != null) {
                        if (typeof object.SpatialReference !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.Envelope.SpatialReference: object expected");
                        message.SpatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.SpatialReference);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Envelope message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @static
                 * @param {esriPBuffer.EsriTypes.Envelope} message Envelope
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Envelope.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.XMin = 0;
                        object.YMin = 0;
                        object.XMax = 0;
                        object.YMax = 0;
                        object.SpatialReference = null;
                    }
                    if (message.XMin != null && message.hasOwnProperty("XMin"))
                        object.XMin = options.json && !isFinite(message.XMin) ? String(message.XMin) : message.XMin;
                    if (message.YMin != null && message.hasOwnProperty("YMin"))
                        object.YMin = options.json && !isFinite(message.YMin) ? String(message.YMin) : message.YMin;
                    if (message.XMax != null && message.hasOwnProperty("XMax"))
                        object.XMax = options.json && !isFinite(message.XMax) ? String(message.XMax) : message.XMax;
                    if (message.YMax != null && message.hasOwnProperty("YMax"))
                        object.YMax = options.json && !isFinite(message.YMax) ? String(message.YMax) : message.YMax;
                    if (message.SpatialReference != null && message.hasOwnProperty("SpatialReference"))
                        object.SpatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.SpatialReference, options);
                    return object;
                };
    
                /**
                 * Converts this Envelope to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.Envelope
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Envelope.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Envelope;
            })();
    
            EsriTypes.CodedValue = (function() {
    
                /**
                 * Properties of a CodedValue.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface ICodedValue
                 * @property {string|null} [name] CodedValue name
                 * @property {esriPBuffer.EsriTypes.IValue|null} [code] CodedValue code
                 */
    
                /**
                 * Constructs a new CodedValue.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a CodedValue.
                 * @implements ICodedValue
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.ICodedValue=} [properties] Properties to set
                 */
                function CodedValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CodedValue name.
                 * @member {string} name
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @instance
                 */
                CodedValue.prototype.name = "";
    
                /**
                 * CodedValue code.
                 * @member {esriPBuffer.EsriTypes.IValue|null|undefined} code
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @instance
                 */
                CodedValue.prototype.code = null;
    
                /**
                 * Creates a new CodedValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {esriPBuffer.EsriTypes.ICodedValue=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.CodedValue} CodedValue instance
                 */
                CodedValue.create = function create(properties) {
                    return new CodedValue(properties);
                };
    
                /**
                 * Encodes the specified CodedValue message. Does not implicitly {@link esriPBuffer.EsriTypes.CodedValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {esriPBuffer.EsriTypes.ICodedValue} message CodedValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CodedValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        $root.esriPBuffer.EsriTypes.Value.encode(message.code, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CodedValue message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.CodedValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {esriPBuffer.EsriTypes.ICodedValue} message CodedValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CodedValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CodedValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.CodedValue} CodedValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CodedValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.CodedValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.code = $root.esriPBuffer.EsriTypes.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CodedValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.CodedValue} CodedValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CodedValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CodedValue message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CodedValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.code != null && message.hasOwnProperty("code")) {
                        var error = $root.esriPBuffer.EsriTypes.Value.verify(message.code);
                        if (error)
                            return "code." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a CodedValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.CodedValue} CodedValue
                 */
                CodedValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.CodedValue)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.CodedValue();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.code != null) {
                        if (typeof object.code !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.CodedValue.code: object expected");
                        message.code = $root.esriPBuffer.EsriTypes.Value.fromObject(object.code);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CodedValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @static
                 * @param {esriPBuffer.EsriTypes.CodedValue} message CodedValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CodedValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.code = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = $root.esriPBuffer.EsriTypes.Value.toObject(message.code, options);
                    return object;
                };
    
                /**
                 * Converts this CodedValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.CodedValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CodedValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CodedValue;
            })();
    
            EsriTypes.CodedValueDomain = (function() {
    
                /**
                 * Properties of a CodedValueDomain.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface ICodedValueDomain
                 * @property {Array.<esriPBuffer.EsriTypes.ICodedValue>|null} [codesValues] CodedValueDomain codesValues
                 */
    
                /**
                 * Constructs a new CodedValueDomain.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a CodedValueDomain.
                 * @implements ICodedValueDomain
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.ICodedValueDomain=} [properties] Properties to set
                 */
                function CodedValueDomain(properties) {
                    this.codesValues = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CodedValueDomain codesValues.
                 * @member {Array.<esriPBuffer.EsriTypes.ICodedValue>} codesValues
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @instance
                 */
                CodedValueDomain.prototype.codesValues = $util.emptyArray;
    
                /**
                 * Creates a new CodedValueDomain instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.ICodedValueDomain=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.CodedValueDomain} CodedValueDomain instance
                 */
                CodedValueDomain.create = function create(properties) {
                    return new CodedValueDomain(properties);
                };
    
                /**
                 * Encodes the specified CodedValueDomain message. Does not implicitly {@link esriPBuffer.EsriTypes.CodedValueDomain.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.ICodedValueDomain} message CodedValueDomain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CodedValueDomain.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.codesValues != null && message.codesValues.length)
                        for (var i = 0; i < message.codesValues.length; ++i)
                            $root.esriPBuffer.EsriTypes.CodedValue.encode(message.codesValues[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified CodedValueDomain message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.CodedValueDomain.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.ICodedValueDomain} message CodedValueDomain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CodedValueDomain.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CodedValueDomain message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.CodedValueDomain} CodedValueDomain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CodedValueDomain.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.CodedValueDomain();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3:
                            if (!(message.codesValues && message.codesValues.length))
                                message.codesValues = [];
                            message.codesValues.push($root.esriPBuffer.EsriTypes.CodedValue.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CodedValueDomain message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.CodedValueDomain} CodedValueDomain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CodedValueDomain.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CodedValueDomain message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CodedValueDomain.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.codesValues != null && message.hasOwnProperty("codesValues")) {
                        if (!Array.isArray(message.codesValues))
                            return "codesValues: array expected";
                        for (var i = 0; i < message.codesValues.length; ++i) {
                            var error = $root.esriPBuffer.EsriTypes.CodedValue.verify(message.codesValues[i]);
                            if (error)
                                return "codesValues." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a CodedValueDomain message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.CodedValueDomain} CodedValueDomain
                 */
                CodedValueDomain.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.CodedValueDomain)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.CodedValueDomain();
                    if (object.codesValues) {
                        if (!Array.isArray(object.codesValues))
                            throw TypeError(".esriPBuffer.EsriTypes.CodedValueDomain.codesValues: array expected");
                        message.codesValues = [];
                        for (var i = 0; i < object.codesValues.length; ++i) {
                            if (typeof object.codesValues[i] !== "object")
                                throw TypeError(".esriPBuffer.EsriTypes.CodedValueDomain.codesValues: object expected");
                            message.codesValues[i] = $root.esriPBuffer.EsriTypes.CodedValue.fromObject(object.codesValues[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CodedValueDomain message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.CodedValueDomain} message CodedValueDomain
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CodedValueDomain.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.codesValues = [];
                    if (message.codesValues && message.codesValues.length) {
                        object.codesValues = [];
                        for (var j = 0; j < message.codesValues.length; ++j)
                            object.codesValues[j] = $root.esriPBuffer.EsriTypes.CodedValue.toObject(message.codesValues[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this CodedValueDomain to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.CodedValueDomain
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CodedValueDomain.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CodedValueDomain;
            })();
    
            EsriTypes.RangeDomain = (function() {
    
                /**
                 * Properties of a RangeDomain.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IRangeDomain
                 * @property {Array.<esriPBuffer.EsriTypes.IValue>|null} [range] RangeDomain range
                 */
    
                /**
                 * Constructs a new RangeDomain.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a RangeDomain.
                 * @implements IRangeDomain
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IRangeDomain=} [properties] Properties to set
                 */
                function RangeDomain(properties) {
                    this.range = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RangeDomain range.
                 * @member {Array.<esriPBuffer.EsriTypes.IValue>} range
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @instance
                 */
                RangeDomain.prototype.range = $util.emptyArray;
    
                /**
                 * Creates a new RangeDomain instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.IRangeDomain=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.RangeDomain} RangeDomain instance
                 */
                RangeDomain.create = function create(properties) {
                    return new RangeDomain(properties);
                };
    
                /**
                 * Encodes the specified RangeDomain message. Does not implicitly {@link esriPBuffer.EsriTypes.RangeDomain.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.IRangeDomain} message RangeDomain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeDomain.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.range != null && message.range.length)
                        for (var i = 0; i < message.range.length; ++i)
                            $root.esriPBuffer.EsriTypes.Value.encode(message.range[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified RangeDomain message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.RangeDomain.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.IRangeDomain} message RangeDomain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RangeDomain.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RangeDomain message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.RangeDomain} RangeDomain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeDomain.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.RangeDomain();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 3:
                            if (!(message.range && message.range.length))
                                message.range = [];
                            message.range.push($root.esriPBuffer.EsriTypes.Value.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RangeDomain message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.RangeDomain} RangeDomain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RangeDomain.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RangeDomain message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RangeDomain.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.range != null && message.hasOwnProperty("range")) {
                        if (!Array.isArray(message.range))
                            return "range: array expected";
                        for (var i = 0; i < message.range.length; ++i) {
                            var error = $root.esriPBuffer.EsriTypes.Value.verify(message.range[i]);
                            if (error)
                                return "range." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a RangeDomain message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.RangeDomain} RangeDomain
                 */
                RangeDomain.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.RangeDomain)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.RangeDomain();
                    if (object.range) {
                        if (!Array.isArray(object.range))
                            throw TypeError(".esriPBuffer.EsriTypes.RangeDomain.range: array expected");
                        message.range = [];
                        for (var i = 0; i < object.range.length; ++i) {
                            if (typeof object.range[i] !== "object")
                                throw TypeError(".esriPBuffer.EsriTypes.RangeDomain.range: object expected");
                            message.range[i] = $root.esriPBuffer.EsriTypes.Value.fromObject(object.range[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a RangeDomain message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @static
                 * @param {esriPBuffer.EsriTypes.RangeDomain} message RangeDomain
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RangeDomain.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.range = [];
                    if (message.range && message.range.length) {
                        object.range = [];
                        for (var j = 0; j < message.range.length; ++j)
                            object.range[j] = $root.esriPBuffer.EsriTypes.Value.toObject(message.range[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this RangeDomain to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.RangeDomain
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RangeDomain.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RangeDomain;
            })();
    
            EsriTypes.Domain = (function() {
    
                /**
                 * Properties of a Domain.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IDomain
                 * @property {string|null} [type] Domain type
                 * @property {string|null} [name] Domain name
                 * @property {esriPBuffer.EsriTypes.ICodedValueDomain|null} [codedValueDomain] Domain codedValueDomain
                 * @property {esriPBuffer.EsriTypes.IRangeDomain|null} [rangeDomain] Domain rangeDomain
                 * @property {esriPBuffer.EsriExtendedTypes.FieldType|null} [fieldType] Domain fieldType
                 * @property {esriPBuffer.EsriTypes.MergePolicyType|null} [mergePolicyType] Domain mergePolicyType
                 * @property {esriPBuffer.EsriTypes.SplitPolicyType|null} [splitPolicyType] Domain splitPolicyType
                 */
    
                /**
                 * Constructs a new Domain.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a Domain.
                 * @implements IDomain
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IDomain=} [properties] Properties to set
                 */
                function Domain(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Domain type.
                 * @member {string} type
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.type = "";
    
                /**
                 * Domain name.
                 * @member {string} name
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.name = "";
    
                /**
                 * Domain codedValueDomain.
                 * @member {esriPBuffer.EsriTypes.ICodedValueDomain|null|undefined} codedValueDomain
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.codedValueDomain = null;
    
                /**
                 * Domain rangeDomain.
                 * @member {esriPBuffer.EsriTypes.IRangeDomain|null|undefined} rangeDomain
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.rangeDomain = null;
    
                /**
                 * Domain fieldType.
                 * @member {esriPBuffer.EsriExtendedTypes.FieldType} fieldType
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.fieldType = 0;
    
                /**
                 * Domain mergePolicyType.
                 * @member {esriPBuffer.EsriTypes.MergePolicyType} mergePolicyType
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.mergePolicyType = 0;
    
                /**
                 * Domain splitPolicyType.
                 * @member {esriPBuffer.EsriTypes.SplitPolicyType} splitPolicyType
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Domain.prototype.splitPolicyType = 0;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Domain of.
                 * @member {"codedValueDomain"|"rangeDomain"|undefined} of
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 */
                Object.defineProperty(Domain.prototype, "of", {
                    get: $util.oneOfGetter($oneOfFields = ["codedValueDomain", "rangeDomain"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Domain instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {esriPBuffer.EsriTypes.IDomain=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.Domain} Domain instance
                 */
                Domain.create = function create(properties) {
                    return new Domain(properties);
                };
    
                /**
                 * Encodes the specified Domain message. Does not implicitly {@link esriPBuffer.EsriTypes.Domain.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {esriPBuffer.EsriTypes.IDomain} message Domain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Domain.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.codedValueDomain != null && Object.hasOwnProperty.call(message, "codedValueDomain"))
                        $root.esriPBuffer.EsriTypes.CodedValueDomain.encode(message.codedValueDomain, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.rangeDomain != null && Object.hasOwnProperty.call(message, "rangeDomain"))
                        $root.esriPBuffer.EsriTypes.RangeDomain.encode(message.rangeDomain, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.fieldType != null && Object.hasOwnProperty.call(message, "fieldType"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.fieldType);
                    if (message.mergePolicyType != null && Object.hasOwnProperty.call(message, "mergePolicyType"))
                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.mergePolicyType);
                    if (message.splitPolicyType != null && Object.hasOwnProperty.call(message, "splitPolicyType"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.splitPolicyType);
                    return writer;
                };
    
                /**
                 * Encodes the specified Domain message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.Domain.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {esriPBuffer.EsriTypes.IDomain} message Domain message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Domain.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Domain message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.Domain} Domain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Domain.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.Domain();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.string();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.codedValueDomain = $root.esriPBuffer.EsriTypes.CodedValueDomain.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.rangeDomain = $root.esriPBuffer.EsriTypes.RangeDomain.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.fieldType = reader.int32();
                            break;
                        case 6:
                            message.mergePolicyType = reader.int32();
                            break;
                        case 7:
                            message.splitPolicyType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Domain message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.Domain} Domain
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Domain.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Domain message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Domain.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.codedValueDomain != null && message.hasOwnProperty("codedValueDomain")) {
                        properties.of = 1;
                        {
                            var error = $root.esriPBuffer.EsriTypes.CodedValueDomain.verify(message.codedValueDomain);
                            if (error)
                                return "codedValueDomain." + error;
                        }
                    }
                    if (message.rangeDomain != null && message.hasOwnProperty("rangeDomain")) {
                        if (properties.of === 1)
                            return "of: multiple values";
                        properties.of = 1;
                        {
                            var error = $root.esriPBuffer.EsriTypes.RangeDomain.verify(message.rangeDomain);
                            if (error)
                                return "rangeDomain." + error;
                        }
                    }
                    if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                        switch (message.fieldType) {
                        default:
                            return "fieldType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                            break;
                        }
                    if (message.mergePolicyType != null && message.hasOwnProperty("mergePolicyType"))
                        switch (message.mergePolicyType) {
                        default:
                            return "mergePolicyType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.splitPolicyType != null && message.hasOwnProperty("splitPolicyType"))
                        switch (message.splitPolicyType) {
                        default:
                            return "splitPolicyType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a Domain message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.Domain} Domain
                 */
                Domain.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.Domain)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.Domain();
                    if (object.type != null)
                        message.type = String(object.type);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.codedValueDomain != null) {
                        if (typeof object.codedValueDomain !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.Domain.codedValueDomain: object expected");
                        message.codedValueDomain = $root.esriPBuffer.EsriTypes.CodedValueDomain.fromObject(object.codedValueDomain);
                    }
                    if (object.rangeDomain != null) {
                        if (typeof object.rangeDomain !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.Domain.rangeDomain: object expected");
                        message.rangeDomain = $root.esriPBuffer.EsriTypes.RangeDomain.fromObject(object.rangeDomain);
                    }
                    switch (object.fieldType) {
                    case "esriFieldType_UNSPECIFIED":
                    case 0:
                        message.fieldType = 0;
                        break;
                    case "esriFieldTypeSmallInteger":
                    case 1:
                        message.fieldType = 1;
                        break;
                    case "esriFieldTypeInteger":
                    case 2:
                        message.fieldType = 2;
                        break;
                    case "esriFieldTypeSingle":
                    case 3:
                        message.fieldType = 3;
                        break;
                    case "esriFieldTypeDouble":
                    case 4:
                        message.fieldType = 4;
                        break;
                    case "esriFieldTypeString":
                    case 5:
                        message.fieldType = 5;
                        break;
                    case "esriFieldTypeDate":
                    case 6:
                        message.fieldType = 6;
                        break;
                    case "esriFieldTypeOID":
                    case 7:
                        message.fieldType = 7;
                        break;
                    case "esriFieldTypeGeometry":
                    case 8:
                        message.fieldType = 8;
                        break;
                    case "esriFieldTypeBlob":
                    case 9:
                        message.fieldType = 9;
                        break;
                    case "esriFieldTypeRaster":
                    case 10:
                        message.fieldType = 10;
                        break;
                    case "esriFieldTypeGUID":
                    case 11:
                        message.fieldType = 11;
                        break;
                    case "esriFieldTypeGlobalID":
                    case 12:
                        message.fieldType = 12;
                        break;
                    case "esriFieldTypeXML":
                    case 13:
                        message.fieldType = 13;
                        break;
                    }
                    switch (object.mergePolicyType) {
                    case "esriMergePolicyType_UNSPECIFIED":
                    case 0:
                        message.mergePolicyType = 0;
                        break;
                    case "esriMergePolicyTypeSumValues":
                    case 1:
                        message.mergePolicyType = 1;
                        break;
                    case "esriMergePolicyTypeAreaWeighted":
                    case 2:
                        message.mergePolicyType = 2;
                        break;
                    case "esriMergePolicyTypeDefaultValue":
                    case 3:
                        message.mergePolicyType = 3;
                        break;
                    }
                    switch (object.splitPolicyType) {
                    case "esriSplitPolicyType_UNSPECIFIED":
                    case 0:
                        message.splitPolicyType = 0;
                        break;
                    case "esriSplitPolicyTypeGeometryRatio":
                    case 1:
                        message.splitPolicyType = 1;
                        break;
                    case "esriSplitPolicyTypeDuplicate":
                    case 2:
                        message.splitPolicyType = 2;
                        break;
                    case "esriSplitPolicyTypeDefaultValue":
                    case 3:
                        message.splitPolicyType = 3;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Domain message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @static
                 * @param {esriPBuffer.EsriTypes.Domain} message Domain
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Domain.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = "";
                        object.name = "";
                        object.fieldType = options.enums === String ? "esriFieldType_UNSPECIFIED" : 0;
                        object.mergePolicyType = options.enums === String ? "esriMergePolicyType_UNSPECIFIED" : 0;
                        object.splitPolicyType = options.enums === String ? "esriSplitPolicyType_UNSPECIFIED" : 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.codedValueDomain != null && message.hasOwnProperty("codedValueDomain")) {
                        object.codedValueDomain = $root.esriPBuffer.EsriTypes.CodedValueDomain.toObject(message.codedValueDomain, options);
                        if (options.oneofs)
                            object.of = "codedValueDomain";
                    }
                    if (message.rangeDomain != null && message.hasOwnProperty("rangeDomain")) {
                        object.rangeDomain = $root.esriPBuffer.EsriTypes.RangeDomain.toObject(message.rangeDomain, options);
                        if (options.oneofs)
                            object.of = "rangeDomain";
                    }
                    if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                        object.fieldType = options.enums === String ? $root.esriPBuffer.EsriExtendedTypes.FieldType[message.fieldType] : message.fieldType;
                    if (message.mergePolicyType != null && message.hasOwnProperty("mergePolicyType"))
                        object.mergePolicyType = options.enums === String ? $root.esriPBuffer.EsriTypes.MergePolicyType[message.mergePolicyType] : message.mergePolicyType;
                    if (message.splitPolicyType != null && message.hasOwnProperty("splitPolicyType"))
                        object.splitPolicyType = options.enums === String ? $root.esriPBuffer.EsriTypes.SplitPolicyType[message.splitPolicyType] : message.splitPolicyType;
                    return object;
                };
    
                /**
                 * Converts this Domain to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.Domain
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Domain.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Domain;
            })();
    
            EsriTypes.DatumTransformation = (function() {
    
                /**
                 * Properties of a DatumTransformation.
                 * @memberof esriPBuffer.EsriTypes
                 * @interface IDatumTransformation
                 * @property {number|null} [wkid] DatumTransformation wkid
                 * @property {string|null} [wkt] DatumTransformation wkt
                 * @property {string|null} [transformDirection] DatumTransformation transformDirection
                 * @property {string|null} [transformJson] DatumTransformation transformJson
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [fromSR] DatumTransformation fromSR
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [toSR] DatumTransformation toSR
                 */
    
                /**
                 * Constructs a new DatumTransformation.
                 * @memberof esriPBuffer.EsriTypes
                 * @classdesc Represents a DatumTransformation.
                 * @implements IDatumTransformation
                 * @constructor
                 * @param {esriPBuffer.EsriTypes.IDatumTransformation=} [properties] Properties to set
                 */
                function DatumTransformation(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DatumTransformation wkid.
                 * @member {number} wkid
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 */
                DatumTransformation.prototype.wkid = 0;
    
                /**
                 * DatumTransformation wkt.
                 * @member {string} wkt
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 */
                DatumTransformation.prototype.wkt = "";
    
                /**
                 * DatumTransformation transformDirection.
                 * @member {string} transformDirection
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 */
                DatumTransformation.prototype.transformDirection = "";
    
                /**
                 * DatumTransformation transformJson.
                 * @member {string} transformJson
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 */
                DatumTransformation.prototype.transformJson = "";
    
                /**
                 * DatumTransformation fromSR.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} fromSR
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 */
                DatumTransformation.prototype.fromSR = null;
    
                /**
                 * DatumTransformation toSR.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} toSR
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 */
                DatumTransformation.prototype.toSR = null;
    
                /**
                 * Creates a new DatumTransformation instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {esriPBuffer.EsriTypes.IDatumTransformation=} [properties] Properties to set
                 * @returns {esriPBuffer.EsriTypes.DatumTransformation} DatumTransformation instance
                 */
                DatumTransformation.create = function create(properties) {
                    return new DatumTransformation(properties);
                };
    
                /**
                 * Encodes the specified DatumTransformation message. Does not implicitly {@link esriPBuffer.EsriTypes.DatumTransformation.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {esriPBuffer.EsriTypes.IDatumTransformation} message DatumTransformation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatumTransformation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.wkid != null && Object.hasOwnProperty.call(message, "wkid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.wkid);
                    if (message.wkt != null && Object.hasOwnProperty.call(message, "wkt"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.wkt);
                    if (message.transformDirection != null && Object.hasOwnProperty.call(message, "transformDirection"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.transformDirection);
                    if (message.transformJson != null && Object.hasOwnProperty.call(message, "transformJson"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.transformJson);
                    if (message.fromSR != null && Object.hasOwnProperty.call(message, "fromSR"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.fromSR, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.toSR != null && Object.hasOwnProperty.call(message, "toSR"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.toSR, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DatumTransformation message, length delimited. Does not implicitly {@link esriPBuffer.EsriTypes.DatumTransformation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {esriPBuffer.EsriTypes.IDatumTransformation} message DatumTransformation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DatumTransformation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DatumTransformation message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.EsriTypes.DatumTransformation} DatumTransformation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatumTransformation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.EsriTypes.DatumTransformation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.wkid = reader.uint32();
                            break;
                        case 2:
                            message.wkt = reader.string();
                            break;
                        case 3:
                            message.transformDirection = reader.string();
                            break;
                        case 4:
                            message.transformJson = reader.string();
                            break;
                        case 5:
                            message.fromSR = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.toSR = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DatumTransformation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.EsriTypes.DatumTransformation} DatumTransformation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DatumTransformation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DatumTransformation message.
                 * @function verify
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DatumTransformation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.wkid != null && message.hasOwnProperty("wkid"))
                        if (!$util.isInteger(message.wkid))
                            return "wkid: integer expected";
                    if (message.wkt != null && message.hasOwnProperty("wkt"))
                        if (!$util.isString(message.wkt))
                            return "wkt: string expected";
                    if (message.transformDirection != null && message.hasOwnProperty("transformDirection"))
                        if (!$util.isString(message.transformDirection))
                            return "transformDirection: string expected";
                    if (message.transformJson != null && message.hasOwnProperty("transformJson"))
                        if (!$util.isString(message.transformJson))
                            return "transformJson: string expected";
                    if (message.fromSR != null && message.hasOwnProperty("fromSR")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.fromSR);
                        if (error)
                            return "fromSR." + error;
                    }
                    if (message.toSR != null && message.hasOwnProperty("toSR")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.toSR);
                        if (error)
                            return "toSR." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DatumTransformation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.EsriTypes.DatumTransformation} DatumTransformation
                 */
                DatumTransformation.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.EsriTypes.DatumTransformation)
                        return object;
                    var message = new $root.esriPBuffer.EsriTypes.DatumTransformation();
                    if (object.wkid != null)
                        message.wkid = object.wkid >>> 0;
                    if (object.wkt != null)
                        message.wkt = String(object.wkt);
                    if (object.transformDirection != null)
                        message.transformDirection = String(object.transformDirection);
                    if (object.transformJson != null)
                        message.transformJson = String(object.transformJson);
                    if (object.fromSR != null) {
                        if (typeof object.fromSR !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.DatumTransformation.fromSR: object expected");
                        message.fromSR = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.fromSR);
                    }
                    if (object.toSR != null) {
                        if (typeof object.toSR !== "object")
                            throw TypeError(".esriPBuffer.EsriTypes.DatumTransformation.toSR: object expected");
                        message.toSR = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.toSR);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DatumTransformation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @static
                 * @param {esriPBuffer.EsriTypes.DatumTransformation} message DatumTransformation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DatumTransformation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.wkid = 0;
                        object.wkt = "";
                        object.transformDirection = "";
                        object.transformJson = "";
                        object.fromSR = null;
                        object.toSR = null;
                    }
                    if (message.wkid != null && message.hasOwnProperty("wkid"))
                        object.wkid = message.wkid;
                    if (message.wkt != null && message.hasOwnProperty("wkt"))
                        object.wkt = message.wkt;
                    if (message.transformDirection != null && message.hasOwnProperty("transformDirection"))
                        object.transformDirection = message.transformDirection;
                    if (message.transformJson != null && message.hasOwnProperty("transformJson"))
                        object.transformJson = message.transformJson;
                    if (message.fromSR != null && message.hasOwnProperty("fromSR"))
                        object.fromSR = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.fromSR, options);
                    if (message.toSR != null && message.hasOwnProperty("toSR"))
                        object.toSR = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.toSR, options);
                    return object;
                };
    
                /**
                 * Converts this DatumTransformation to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.EsriTypes.DatumTransformation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DatumTransformation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DatumTransformation;
            })();
    
            return EsriTypes;
        })();
    
        esriPBuffer.graph = (function() {
    
            /**
             * Namespace graph.
             * @memberof esriPBuffer
             * @namespace
             */
            var graph = {};
    
            graph.GraphDomainAddRequest = (function() {
    
                /**
                 * Properties of a GraphDomainAddRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphDomainAddRequest
                 * @property {esriPBuffer.EsriTypes.IDomain|null} [domains] GraphDomainAddRequest domains
                 */
    
                /**
                 * Constructs a new GraphDomainAddRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphDomainAddRequest.
                 * @implements IGraphDomainAddRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphDomainAddRequest=} [properties] Properties to set
                 */
                function GraphDomainAddRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphDomainAddRequest domains.
                 * @member {esriPBuffer.EsriTypes.IDomain|null|undefined} domains
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @instance
                 */
                GraphDomainAddRequest.prototype.domains = null;
    
                /**
                 * Creates a new GraphDomainAddRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainAddRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphDomainAddRequest} GraphDomainAddRequest instance
                 */
                GraphDomainAddRequest.create = function create(properties) {
                    return new GraphDomainAddRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphDomainAddRequest message. Does not implicitly {@link esriPBuffer.graph.GraphDomainAddRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainAddRequest} message GraphDomainAddRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainAddRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.domains != null && Object.hasOwnProperty.call(message, "domains"))
                        $root.esriPBuffer.EsriTypes.Domain.encode(message.domains, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphDomainAddRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphDomainAddRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainAddRequest} message GraphDomainAddRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainAddRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphDomainAddRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphDomainAddRequest} GraphDomainAddRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainAddRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphDomainAddRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.domains = $root.esriPBuffer.EsriTypes.Domain.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphDomainAddRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphDomainAddRequest} GraphDomainAddRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainAddRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphDomainAddRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphDomainAddRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.domains != null && message.hasOwnProperty("domains")) {
                        var error = $root.esriPBuffer.EsriTypes.Domain.verify(message.domains);
                        if (error)
                            return "domains." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphDomainAddRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphDomainAddRequest} GraphDomainAddRequest
                 */
                GraphDomainAddRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphDomainAddRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphDomainAddRequest();
                    if (object.domains != null) {
                        if (typeof object.domains !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphDomainAddRequest.domains: object expected");
                        message.domains = $root.esriPBuffer.EsriTypes.Domain.fromObject(object.domains);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphDomainAddRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphDomainAddRequest} message GraphDomainAddRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphDomainAddRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.domains = null;
                    if (message.domains != null && message.hasOwnProperty("domains"))
                        object.domains = $root.esriPBuffer.EsriTypes.Domain.toObject(message.domains, options);
                    return object;
                };
    
                /**
                 * Converts this GraphDomainAddRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphDomainAddRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphDomainAddRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphDomainAddRequest;
            })();
    
            graph.GraphDomainAddResponse = (function() {
    
                /**
                 * Properties of a GraphDomainAddResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphDomainAddResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphDomainAddResponse error
                 */
    
                /**
                 * Constructs a new GraphDomainAddResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphDomainAddResponse.
                 * @implements IGraphDomainAddResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphDomainAddResponse=} [properties] Properties to set
                 */
                function GraphDomainAddResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphDomainAddResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @instance
                 */
                GraphDomainAddResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphDomainAddResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainAddResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphDomainAddResponse} GraphDomainAddResponse instance
                 */
                GraphDomainAddResponse.create = function create(properties) {
                    return new GraphDomainAddResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphDomainAddResponse message. Does not implicitly {@link esriPBuffer.graph.GraphDomainAddResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainAddResponse} message GraphDomainAddResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainAddResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphDomainAddResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphDomainAddResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainAddResponse} message GraphDomainAddResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainAddResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphDomainAddResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphDomainAddResponse} GraphDomainAddResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainAddResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphDomainAddResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphDomainAddResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphDomainAddResponse} GraphDomainAddResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainAddResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphDomainAddResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphDomainAddResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphDomainAddResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphDomainAddResponse} GraphDomainAddResponse
                 */
                GraphDomainAddResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphDomainAddResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphDomainAddResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphDomainAddResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphDomainAddResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphDomainAddResponse} message GraphDomainAddResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphDomainAddResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphDomainAddResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphDomainAddResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphDomainAddResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphDomainAddResponse;
            })();
    
            graph.FloatArray = (function() {
    
                /**
                 * Properties of a FloatArray.
                 * @memberof esriPBuffer.graph
                 * @interface IFloatArray
                 * @property {Array.<number>|null} [value] FloatArray value
                 */
    
                /**
                 * Constructs a new FloatArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a FloatArray.
                 * @implements IFloatArray
                 * @constructor
                 * @param {esriPBuffer.graph.IFloatArray=} [properties] Properties to set
                 */
                function FloatArray(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FloatArray value.
                 * @member {Array.<number>} value
                 * @memberof esriPBuffer.graph.FloatArray
                 * @instance
                 */
                FloatArray.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new FloatArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {esriPBuffer.graph.IFloatArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.FloatArray} FloatArray instance
                 */
                FloatArray.create = function create(properties) {
                    return new FloatArray(properties);
                };
    
                /**
                 * Encodes the specified FloatArray message. Does not implicitly {@link esriPBuffer.graph.FloatArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {esriPBuffer.graph.IFloatArray} message FloatArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FloatArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.float(message.value[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified FloatArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.FloatArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {esriPBuffer.graph.IFloatArray} message FloatArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FloatArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FloatArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.FloatArray} FloatArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FloatArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.FloatArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.float());
                            } else
                                message.value.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FloatArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.FloatArray} FloatArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FloatArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FloatArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FloatArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (typeof message.value[i] !== "number")
                                return "value: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a FloatArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.FloatArray} FloatArray
                 */
                FloatArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.FloatArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.FloatArray();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.FloatArray.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = Number(object.value[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FloatArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.FloatArray
                 * @static
                 * @param {esriPBuffer.graph.FloatArray} message FloatArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FloatArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this FloatArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.FloatArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FloatArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FloatArray;
            })();
    
            graph.DoubleArray = (function() {
    
                /**
                 * Properties of a DoubleArray.
                 * @memberof esriPBuffer.graph
                 * @interface IDoubleArray
                 * @property {Array.<number>|null} [value] DoubleArray value
                 */
    
                /**
                 * Constructs a new DoubleArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a DoubleArray.
                 * @implements IDoubleArray
                 * @constructor
                 * @param {esriPBuffer.graph.IDoubleArray=} [properties] Properties to set
                 */
                function DoubleArray(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DoubleArray value.
                 * @member {Array.<number>} value
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @instance
                 */
                DoubleArray.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new DoubleArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {esriPBuffer.graph.IDoubleArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.DoubleArray} DoubleArray instance
                 */
                DoubleArray.create = function create(properties) {
                    return new DoubleArray(properties);
                };
    
                /**
                 * Encodes the specified DoubleArray message. Does not implicitly {@link esriPBuffer.graph.DoubleArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {esriPBuffer.graph.IDoubleArray} message DoubleArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.double(message.value[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified DoubleArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.DoubleArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {esriPBuffer.graph.IDoubleArray} message DoubleArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DoubleArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.DoubleArray} DoubleArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.DoubleArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.double());
                            } else
                                message.value.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DoubleArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.DoubleArray} DoubleArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DoubleArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DoubleArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (typeof message.value[i] !== "number")
                                return "value: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DoubleArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.DoubleArray} DoubleArray
                 */
                DoubleArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.DoubleArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.DoubleArray();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.DoubleArray.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = Number(object.value[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DoubleArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @static
                 * @param {esriPBuffer.graph.DoubleArray} message DoubleArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DoubleArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DoubleArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.DoubleArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DoubleArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DoubleArray;
            })();
    
            graph.Int32Array = (function() {
    
                /**
                 * Properties of an Int32Array.
                 * @memberof esriPBuffer.graph
                 * @interface IInt32Array
                 * @property {Array.<number>|null} [value] Int32Array value
                 */
    
                /**
                 * Constructs a new Int32Array.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an Int32Array.
                 * @implements IInt32Array
                 * @constructor
                 * @param {esriPBuffer.graph.IInt32Array=} [properties] Properties to set
                 */
                function Int32Array(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int32Array value.
                 * @member {Array.<number>} value
                 * @memberof esriPBuffer.graph.Int32Array
                 * @instance
                 */
                Int32Array.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new Int32Array instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {esriPBuffer.graph.IInt32Array=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Int32Array} Int32Array instance
                 */
                Int32Array.create = function create(properties) {
                    return new Int32Array(properties);
                };
    
                /**
                 * Encodes the specified Int32Array message. Does not implicitly {@link esriPBuffer.graph.Int32Array.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {esriPBuffer.graph.IInt32Array} message Int32Array message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int32Array.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.sint32(message.value[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified Int32Array message, length delimited. Does not implicitly {@link esriPBuffer.graph.Int32Array.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {esriPBuffer.graph.IInt32Array} message Int32Array message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int32Array.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Int32Array message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Int32Array} Int32Array
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int32Array.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Int32Array();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.sint32());
                            } else
                                message.value.push(reader.sint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Int32Array message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Int32Array} Int32Array
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int32Array.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Int32Array message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int32Array.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (!$util.isInteger(message.value[i]))
                                return "value: integer[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an Int32Array message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Int32Array} Int32Array
                 */
                Int32Array.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Int32Array)
                        return object;
                    var message = new $root.esriPBuffer.graph.Int32Array();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.Int32Array.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = object.value[i] | 0;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Int32Array message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Int32Array
                 * @static
                 * @param {esriPBuffer.graph.Int32Array} message Int32Array
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Int32Array.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this Int32Array to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Int32Array
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Int32Array.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int32Array;
            })();
    
            graph.Int64Array = (function() {
    
                /**
                 * Properties of an Int64Array.
                 * @memberof esriPBuffer.graph
                 * @interface IInt64Array
                 * @property {Array.<number|Long>|null} [value] Int64Array value
                 */
    
                /**
                 * Constructs a new Int64Array.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an Int64Array.
                 * @implements IInt64Array
                 * @constructor
                 * @param {esriPBuffer.graph.IInt64Array=} [properties] Properties to set
                 */
                function Int64Array(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int64Array value.
                 * @member {Array.<number|Long>} value
                 * @memberof esriPBuffer.graph.Int64Array
                 * @instance
                 */
                Int64Array.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new Int64Array instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {esriPBuffer.graph.IInt64Array=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Int64Array} Int64Array instance
                 */
                Int64Array.create = function create(properties) {
                    return new Int64Array(properties);
                };
    
                /**
                 * Encodes the specified Int64Array message. Does not implicitly {@link esriPBuffer.graph.Int64Array.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {esriPBuffer.graph.IInt64Array} message Int64Array message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64Array.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.sint64(message.value[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified Int64Array message, length delimited. Does not implicitly {@link esriPBuffer.graph.Int64Array.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {esriPBuffer.graph.IInt64Array} message Int64Array message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64Array.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Int64Array message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Int64Array} Int64Array
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64Array.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Int64Array();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.sint64());
                            } else
                                message.value.push(reader.sint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Int64Array message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Int64Array} Int64Array
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64Array.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Int64Array message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int64Array.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                                return "value: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an Int64Array message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Int64Array} Int64Array
                 */
                Int64Array.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Int64Array)
                        return object;
                    var message = new $root.esriPBuffer.graph.Int64Array();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.Int64Array.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            if ($util.Long)
                                (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                            else if (typeof object.value[i] === "string")
                                message.value[i] = parseInt(object.value[i], 10);
                            else if (typeof object.value[i] === "number")
                                message.value[i] = object.value[i];
                            else if (typeof object.value[i] === "object")
                                message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Int64Array message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Int64Array
                 * @static
                 * @param {esriPBuffer.graph.Int64Array} message Int64Array
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Int64Array.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            if (typeof message.value[j] === "number")
                                object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                            else
                                object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this Int64Array to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Int64Array
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Int64Array.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64Array;
            })();
    
            graph.BoolArray = (function() {
    
                /**
                 * Properties of a BoolArray.
                 * @memberof esriPBuffer.graph
                 * @interface IBoolArray
                 * @property {Array.<boolean>|null} [value] BoolArray value
                 */
    
                /**
                 * Constructs a new BoolArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a BoolArray.
                 * @implements IBoolArray
                 * @constructor
                 * @param {esriPBuffer.graph.IBoolArray=} [properties] Properties to set
                 */
                function BoolArray(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BoolArray value.
                 * @member {Array.<boolean>} value
                 * @memberof esriPBuffer.graph.BoolArray
                 * @instance
                 */
                BoolArray.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new BoolArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {esriPBuffer.graph.IBoolArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.BoolArray} BoolArray instance
                 */
                BoolArray.create = function create(properties) {
                    return new BoolArray(properties);
                };
    
                /**
                 * Encodes the specified BoolArray message. Does not implicitly {@link esriPBuffer.graph.BoolArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {esriPBuffer.graph.IBoolArray} message BoolArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoolArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.bool(message.value[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified BoolArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.BoolArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {esriPBuffer.graph.IBoolArray} message BoolArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BoolArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BoolArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.BoolArray} BoolArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoolArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.BoolArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.bool());
                            } else
                                message.value.push(reader.bool());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BoolArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.BoolArray} BoolArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BoolArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BoolArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BoolArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (typeof message.value[i] !== "boolean")
                                return "value: boolean[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a BoolArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.BoolArray} BoolArray
                 */
                BoolArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.BoolArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.BoolArray();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.BoolArray.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = Boolean(object.value[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BoolArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.BoolArray
                 * @static
                 * @param {esriPBuffer.graph.BoolArray} message BoolArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BoolArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this BoolArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.BoolArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BoolArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BoolArray;
            })();
    
            graph.DateTimeArray = (function() {
    
                /**
                 * Properties of a DateTimeArray.
                 * @memberof esriPBuffer.graph
                 * @interface IDateTimeArray
                 * @property {Array.<number|Long>|null} [value] DateTimeArray value
                 */
    
                /**
                 * Constructs a new DateTimeArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a DateTimeArray.
                 * @implements IDateTimeArray
                 * @constructor
                 * @param {esriPBuffer.graph.IDateTimeArray=} [properties] Properties to set
                 */
                function DateTimeArray(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DateTimeArray value.
                 * @member {Array.<number|Long>} value
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @instance
                 */
                DateTimeArray.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new DateTimeArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {esriPBuffer.graph.IDateTimeArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.DateTimeArray} DateTimeArray instance
                 */
                DateTimeArray.create = function create(properties) {
                    return new DateTimeArray(properties);
                };
    
                /**
                 * Encodes the specified DateTimeArray message. Does not implicitly {@link esriPBuffer.graph.DateTimeArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {esriPBuffer.graph.IDateTimeArray} message DateTimeArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DateTimeArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.value.length; ++i)
                            writer.int64(message.value[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified DateTimeArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.DateTimeArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {esriPBuffer.graph.IDateTimeArray} message DateTimeArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DateTimeArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DateTimeArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.DateTimeArray} DateTimeArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DateTimeArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.DateTimeArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.value.push(reader.int64());
                            } else
                                message.value.push(reader.int64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DateTimeArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.DateTimeArray} DateTimeArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DateTimeArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DateTimeArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DateTimeArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                                return "value: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DateTimeArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.DateTimeArray} DateTimeArray
                 */
                DateTimeArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.DateTimeArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.DateTimeArray();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.DateTimeArray.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            if ($util.Long)
                                (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                            else if (typeof object.value[i] === "string")
                                message.value[i] = parseInt(object.value[i], 10);
                            else if (typeof object.value[i] === "number")
                                message.value[i] = object.value[i];
                            else if (typeof object.value[i] === "object")
                                message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DateTimeArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @static
                 * @param {esriPBuffer.graph.DateTimeArray} message DateTimeArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DateTimeArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            if (typeof message.value[j] === "number")
                                object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                            else
                                object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DateTimeArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.DateTimeArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DateTimeArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DateTimeArray;
            })();
    
            graph.NullArray = (function() {
    
                /**
                 * Properties of a NullArray.
                 * @memberof esriPBuffer.graph
                 * @interface INullArray
                 * @property {number|Long|null} [length] NullArray length
                 */
    
                /**
                 * Constructs a new NullArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NullArray.
                 * @implements INullArray
                 * @constructor
                 * @param {esriPBuffer.graph.INullArray=} [properties] Properties to set
                 */
                function NullArray(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NullArray length.
                 * @member {number|Long} length
                 * @memberof esriPBuffer.graph.NullArray
                 * @instance
                 */
                NullArray.prototype.length = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Creates a new NullArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {esriPBuffer.graph.INullArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NullArray} NullArray instance
                 */
                NullArray.create = function create(properties) {
                    return new NullArray(properties);
                };
    
                /**
                 * Encodes the specified NullArray message. Does not implicitly {@link esriPBuffer.graph.NullArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {esriPBuffer.graph.INullArray} message NullArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NullArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.length != null && Object.hasOwnProperty.call(message, "length"))
                        writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.length);
                    return writer;
                };
    
                /**
                 * Encodes the specified NullArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.NullArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {esriPBuffer.graph.INullArray} message NullArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NullArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NullArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NullArray} NullArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NullArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NullArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.length = reader.sint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NullArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NullArray} NullArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NullArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NullArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NullArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (!$util.isInteger(message.length) && !(message.length && $util.isInteger(message.length.low) && $util.isInteger(message.length.high)))
                            return "length: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a NullArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NullArray} NullArray
                 */
                NullArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NullArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.NullArray();
                    if (object.length != null)
                        if ($util.Long)
                            (message.length = $util.Long.fromValue(object.length)).unsigned = false;
                        else if (typeof object.length === "string")
                            message.length = parseInt(object.length, 10);
                        else if (typeof object.length === "number")
                            message.length = object.length;
                        else if (typeof object.length === "object")
                            message.length = new $util.LongBits(object.length.low >>> 0, object.length.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from a NullArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NullArray
                 * @static
                 * @param {esriPBuffer.graph.NullArray} message NullArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NullArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.length = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.length = options.longs === String ? "0" : 0;
                    if (message.length != null && message.hasOwnProperty("length"))
                        if (typeof message.length === "number")
                            object.length = options.longs === String ? String(message.length) : message.length;
                        else
                            object.length = options.longs === String ? $util.Long.prototype.toString.call(message.length) : options.longs === Number ? new $util.LongBits(message.length.low >>> 0, message.length.high >>> 0).toNumber() : message.length;
                    return object;
                };
    
                /**
                 * Converts this NullArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NullArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NullArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NullArray;
            })();
    
            graph.StringArray = (function() {
    
                /**
                 * Properties of a StringArray.
                 * @memberof esriPBuffer.graph
                 * @interface IStringArray
                 * @property {Array.<string>|null} [value] StringArray value
                 */
    
                /**
                 * Constructs a new StringArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a StringArray.
                 * @implements IStringArray
                 * @constructor
                 * @param {esriPBuffer.graph.IStringArray=} [properties] Properties to set
                 */
                function StringArray(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StringArray value.
                 * @member {Array.<string>} value
                 * @memberof esriPBuffer.graph.StringArray
                 * @instance
                 */
                StringArray.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new StringArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {esriPBuffer.graph.IStringArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.StringArray} StringArray instance
                 */
                StringArray.create = function create(properties) {
                    return new StringArray(properties);
                };
    
                /**
                 * Encodes the specified StringArray message. Does not implicitly {@link esriPBuffer.graph.StringArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {esriPBuffer.graph.IStringArray} message StringArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.value[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified StringArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.StringArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {esriPBuffer.graph.IStringArray} message StringArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a StringArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.StringArray} StringArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.StringArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a StringArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.StringArray} StringArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a StringArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i)
                            if (!$util.isString(message.value[i]))
                                return "value: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a StringArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.StringArray} StringArray
                 */
                StringArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.StringArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.StringArray();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.StringArray.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i)
                            message.value[i] = String(object.value[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a StringArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.StringArray
                 * @static
                 * @param {esriPBuffer.graph.StringArray} message StringArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = message.value[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this StringArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.StringArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringArray;
            })();
    
            graph.GeometryValue = (function() {
    
                /**
                 * Properties of a GeometryValue.
                 * @memberof esriPBuffer.graph
                 * @interface IGeometryValue
                 * @property {esriPBuffer.EsriTypes.GeometryType|null} [geometryType] GeometryValue geometryType
                 * @property {esriPBuffer.graph.GeometryValue.IEsriDefaultGeometry|null} [geometry] GeometryValue geometry
                 */
    
                /**
                 * Constructs a new GeometryValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GeometryValue.
                 * @implements IGeometryValue
                 * @constructor
                 * @param {esriPBuffer.graph.IGeometryValue=} [properties] Properties to set
                 */
                function GeometryValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeometryValue geometryType.
                 * @member {esriPBuffer.EsriTypes.GeometryType} geometryType
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @instance
                 */
                GeometryValue.prototype.geometryType = 0;
    
                /**
                 * GeometryValue geometry.
                 * @member {esriPBuffer.graph.GeometryValue.IEsriDefaultGeometry|null|undefined} geometry
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @instance
                 */
                GeometryValue.prototype.geometry = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * GeometryValue compressedGeometry.
                 * @member {"geometry"|undefined} compressedGeometry
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @instance
                 */
                Object.defineProperty(GeometryValue.prototype, "compressedGeometry", {
                    get: $util.oneOfGetter($oneOfFields = ["geometry"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new GeometryValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {esriPBuffer.graph.IGeometryValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GeometryValue} GeometryValue instance
                 */
                GeometryValue.create = function create(properties) {
                    return new GeometryValue(properties);
                };
    
                /**
                 * Encodes the specified GeometryValue message. Does not implicitly {@link esriPBuffer.graph.GeometryValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {esriPBuffer.graph.IGeometryValue} message GeometryValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeometryValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.geometryType != null && Object.hasOwnProperty.call(message, "geometryType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.geometryType);
                    if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                        $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.encode(message.geometry, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GeometryValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.GeometryValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {esriPBuffer.graph.IGeometryValue} message GeometryValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeometryValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GeometryValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GeometryValue} GeometryValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeometryValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GeometryValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.geometryType = reader.int32();
                            break;
                        case 2:
                            message.geometry = $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GeometryValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GeometryValue} GeometryValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeometryValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GeometryValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeometryValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.geometryType != null && message.hasOwnProperty("geometryType"))
                        switch (message.geometryType) {
                        default:
                            return "geometryType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.geometry != null && message.hasOwnProperty("geometry")) {
                        properties.compressedGeometry = 1;
                        {
                            var error = $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.verify(message.geometry);
                            if (error)
                                return "geometry." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GeometryValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GeometryValue} GeometryValue
                 */
                GeometryValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GeometryValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.GeometryValue();
                    switch (object.geometryType) {
                    case "esriGeometryTypePoint":
                    case 0:
                        message.geometryType = 0;
                        break;
                    case "esriGeometryTypeMultipoint":
                    case 1:
                        message.geometryType = 1;
                        break;
                    case "esriGeometryTypePolyline":
                    case 2:
                        message.geometryType = 2;
                        break;
                    case "esriGeometryTypePolygon":
                    case 3:
                        message.geometryType = 3;
                        break;
                    case "esriGeometryTypeMultipatch":
                    case 4:
                        message.geometryType = 4;
                        break;
                    case "esriGeometryTypeEnvelope":
                    case 5:
                        message.geometryType = 5;
                        break;
                    }
                    if (object.geometry != null) {
                        if (typeof object.geometry !== "object")
                            throw TypeError(".esriPBuffer.graph.GeometryValue.geometry: object expected");
                        message.geometry = $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.fromObject(object.geometry);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GeometryValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @static
                 * @param {esriPBuffer.graph.GeometryValue} message GeometryValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeometryValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.geometryType = options.enums === String ? "esriGeometryTypePoint" : 0;
                    if (message.geometryType != null && message.hasOwnProperty("geometryType"))
                        object.geometryType = options.enums === String ? $root.esriPBuffer.EsriTypes.GeometryType[message.geometryType] : message.geometryType;
                    if (message.geometry != null && message.hasOwnProperty("geometry")) {
                        object.geometry = $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.toObject(message.geometry, options);
                        if (options.oneofs)
                            object.compressedGeometry = "geometry";
                    }
                    return object;
                };
    
                /**
                 * Converts this GeometryValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GeometryValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeometryValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GeometryValue.EsriDefaultGeometry = (function() {
    
                    /**
                     * Properties of an EsriDefaultGeometry.
                     * @memberof esriPBuffer.graph.GeometryValue
                     * @interface IEsriDefaultGeometry
                     * @property {boolean|null} [hasZ] EsriDefaultGeometry hasZ
                     * @property {boolean|null} [hasM] EsriDefaultGeometry hasM
                     * @property {Array.<number>|null} [lengths] EsriDefaultGeometry lengths
                     * @property {Array.<number|Long>|null} [coords] EsriDefaultGeometry coords
                     */
    
                    /**
                     * Constructs a new EsriDefaultGeometry.
                     * @memberof esriPBuffer.graph.GeometryValue
                     * @classdesc Represents an EsriDefaultGeometry.
                     * @implements IEsriDefaultGeometry
                     * @constructor
                     * @param {esriPBuffer.graph.GeometryValue.IEsriDefaultGeometry=} [properties] Properties to set
                     */
                    function EsriDefaultGeometry(properties) {
                        this.lengths = [];
                        this.coords = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * EsriDefaultGeometry hasZ.
                     * @member {boolean} hasZ
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @instance
                     */
                    EsriDefaultGeometry.prototype.hasZ = false;
    
                    /**
                     * EsriDefaultGeometry hasM.
                     * @member {boolean} hasM
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @instance
                     */
                    EsriDefaultGeometry.prototype.hasM = false;
    
                    /**
                     * EsriDefaultGeometry lengths.
                     * @member {Array.<number>} lengths
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @instance
                     */
                    EsriDefaultGeometry.prototype.lengths = $util.emptyArray;
    
                    /**
                     * EsriDefaultGeometry coords.
                     * @member {Array.<number|Long>} coords
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @instance
                     */
                    EsriDefaultGeometry.prototype.coords = $util.emptyArray;
    
                    /**
                     * Creates a new EsriDefaultGeometry instance using the specified properties.
                     * @function create
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {esriPBuffer.graph.GeometryValue.IEsriDefaultGeometry=} [properties] Properties to set
                     * @returns {esriPBuffer.graph.GeometryValue.EsriDefaultGeometry} EsriDefaultGeometry instance
                     */
                    EsriDefaultGeometry.create = function create(properties) {
                        return new EsriDefaultGeometry(properties);
                    };
    
                    /**
                     * Encodes the specified EsriDefaultGeometry message. Does not implicitly {@link esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.verify|verify} messages.
                     * @function encode
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {esriPBuffer.graph.GeometryValue.IEsriDefaultGeometry} message EsriDefaultGeometry message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EsriDefaultGeometry.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.hasZ != null && Object.hasOwnProperty.call(message, "hasZ"))
                            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hasZ);
                        if (message.hasM != null && Object.hasOwnProperty.call(message, "hasM"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hasM);
                        if (message.lengths != null && message.lengths.length) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork();
                            for (var i = 0; i < message.lengths.length; ++i)
                                writer.uint32(message.lengths[i]);
                            writer.ldelim();
                        }
                        if (message.coords != null && message.coords.length) {
                            writer.uint32(/* id 4, wireType 2 =*/34).fork();
                            for (var i = 0; i < message.coords.length; ++i)
                                writer.sint64(message.coords[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified EsriDefaultGeometry message, length delimited. Does not implicitly {@link esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {esriPBuffer.graph.GeometryValue.IEsriDefaultGeometry} message EsriDefaultGeometry message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EsriDefaultGeometry.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an EsriDefaultGeometry message from the specified reader or buffer.
                     * @function decode
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {esriPBuffer.graph.GeometryValue.EsriDefaultGeometry} EsriDefaultGeometry
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EsriDefaultGeometry.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.hasZ = reader.bool();
                                break;
                            case 2:
                                message.hasM = reader.bool();
                                break;
                            case 3:
                                if (!(message.lengths && message.lengths.length))
                                    message.lengths = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.lengths.push(reader.uint32());
                                } else
                                    message.lengths.push(reader.uint32());
                                break;
                            case 4:
                                if (!(message.coords && message.coords.length))
                                    message.coords = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.coords.push(reader.sint64());
                                } else
                                    message.coords.push(reader.sint64());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an EsriDefaultGeometry message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {esriPBuffer.graph.GeometryValue.EsriDefaultGeometry} EsriDefaultGeometry
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EsriDefaultGeometry.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an EsriDefaultGeometry message.
                     * @function verify
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EsriDefaultGeometry.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.hasZ != null && message.hasOwnProperty("hasZ"))
                            if (typeof message.hasZ !== "boolean")
                                return "hasZ: boolean expected";
                        if (message.hasM != null && message.hasOwnProperty("hasM"))
                            if (typeof message.hasM !== "boolean")
                                return "hasM: boolean expected";
                        if (message.lengths != null && message.hasOwnProperty("lengths")) {
                            if (!Array.isArray(message.lengths))
                                return "lengths: array expected";
                            for (var i = 0; i < message.lengths.length; ++i)
                                if (!$util.isInteger(message.lengths[i]))
                                    return "lengths: integer[] expected";
                        }
                        if (message.coords != null && message.hasOwnProperty("coords")) {
                            if (!Array.isArray(message.coords))
                                return "coords: array expected";
                            for (var i = 0; i < message.coords.length; ++i)
                                if (!$util.isInteger(message.coords[i]) && !(message.coords[i] && $util.isInteger(message.coords[i].low) && $util.isInteger(message.coords[i].high)))
                                    return "coords: integer|Long[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates an EsriDefaultGeometry message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {esriPBuffer.graph.GeometryValue.EsriDefaultGeometry} EsriDefaultGeometry
                     */
                    EsriDefaultGeometry.fromObject = function fromObject(object) {
                        if (object instanceof $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry)
                            return object;
                        var message = new $root.esriPBuffer.graph.GeometryValue.EsriDefaultGeometry();
                        if (object.hasZ != null)
                            message.hasZ = Boolean(object.hasZ);
                        if (object.hasM != null)
                            message.hasM = Boolean(object.hasM);
                        if (object.lengths) {
                            if (!Array.isArray(object.lengths))
                                throw TypeError(".esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.lengths: array expected");
                            message.lengths = [];
                            for (var i = 0; i < object.lengths.length; ++i)
                                message.lengths[i] = object.lengths[i] >>> 0;
                        }
                        if (object.coords) {
                            if (!Array.isArray(object.coords))
                                throw TypeError(".esriPBuffer.graph.GeometryValue.EsriDefaultGeometry.coords: array expected");
                            message.coords = [];
                            for (var i = 0; i < object.coords.length; ++i)
                                if ($util.Long)
                                    (message.coords[i] = $util.Long.fromValue(object.coords[i])).unsigned = false;
                                else if (typeof object.coords[i] === "string")
                                    message.coords[i] = parseInt(object.coords[i], 10);
                                else if (typeof object.coords[i] === "number")
                                    message.coords[i] = object.coords[i];
                                else if (typeof object.coords[i] === "object")
                                    message.coords[i] = new $util.LongBits(object.coords[i].low >>> 0, object.coords[i].high >>> 0).toNumber();
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an EsriDefaultGeometry message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @static
                     * @param {esriPBuffer.graph.GeometryValue.EsriDefaultGeometry} message EsriDefaultGeometry
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EsriDefaultGeometry.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults) {
                            object.lengths = [];
                            object.coords = [];
                        }
                        if (options.defaults) {
                            object.hasZ = false;
                            object.hasM = false;
                        }
                        if (message.hasZ != null && message.hasOwnProperty("hasZ"))
                            object.hasZ = message.hasZ;
                        if (message.hasM != null && message.hasOwnProperty("hasM"))
                            object.hasM = message.hasM;
                        if (message.lengths && message.lengths.length) {
                            object.lengths = [];
                            for (var j = 0; j < message.lengths.length; ++j)
                                object.lengths[j] = message.lengths[j];
                        }
                        if (message.coords && message.coords.length) {
                            object.coords = [];
                            for (var j = 0; j < message.coords.length; ++j)
                                if (typeof message.coords[j] === "number")
                                    object.coords[j] = options.longs === String ? String(message.coords[j]) : message.coords[j];
                                else
                                    object.coords[j] = options.longs === String ? $util.Long.prototype.toString.call(message.coords[j]) : options.longs === Number ? new $util.LongBits(message.coords[j].low >>> 0, message.coords[j].high >>> 0).toNumber() : message.coords[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this EsriDefaultGeometry to JSON.
                     * @function toJSON
                     * @memberof esriPBuffer.graph.GeometryValue.EsriDefaultGeometry
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EsriDefaultGeometry.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return EsriDefaultGeometry;
                })();
    
                return GeometryValue;
            })();
    
            graph.QuantizationParameters = (function() {
    
                /**
                 * Properties of a QuantizationParameters.
                 * @memberof esriPBuffer.graph
                 * @interface IQuantizationParameters
                 * @property {esriPBuffer.EsriTypes.IEnvelope|null} [extent] QuantizationParameters extent
                 * @property {esriPBuffer.graph.QuantizationParameters.QuantizeMode|null} [mode] QuantizationParameters mode
                 * @property {number|null} [tolerance] QuantizationParameters tolerance
                 */
    
                /**
                 * Constructs a new QuantizationParameters.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a QuantizationParameters.
                 * @implements IQuantizationParameters
                 * @constructor
                 * @param {esriPBuffer.graph.IQuantizationParameters=} [properties] Properties to set
                 */
                function QuantizationParameters(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * QuantizationParameters extent.
                 * @member {esriPBuffer.EsriTypes.IEnvelope|null|undefined} extent
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.extent = null;
    
                /**
                 * QuantizationParameters mode.
                 * @member {esriPBuffer.graph.QuantizationParameters.QuantizeMode} mode
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.mode = 0;
    
                /**
                 * QuantizationParameters tolerance.
                 * @member {number} tolerance
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @instance
                 */
                QuantizationParameters.prototype.tolerance = 0;
    
                /**
                 * Creates a new QuantizationParameters instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.graph.IQuantizationParameters=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.QuantizationParameters} QuantizationParameters instance
                 */
                QuantizationParameters.create = function create(properties) {
                    return new QuantizationParameters(properties);
                };
    
                /**
                 * Encodes the specified QuantizationParameters message. Does not implicitly {@link esriPBuffer.graph.QuantizationParameters.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.graph.IQuantizationParameters} message QuantizationParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuantizationParameters.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.extent != null && Object.hasOwnProperty.call(message, "extent"))
                        $root.esriPBuffer.EsriTypes.Envelope.encode(message.extent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.mode != null && Object.hasOwnProperty.call(message, "mode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
                    if (message.tolerance != null && Object.hasOwnProperty.call(message, "tolerance"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.tolerance);
                    return writer;
                };
    
                /**
                 * Encodes the specified QuantizationParameters message, length delimited. Does not implicitly {@link esriPBuffer.graph.QuantizationParameters.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.graph.IQuantizationParameters} message QuantizationParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                QuantizationParameters.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a QuantizationParameters message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.QuantizationParameters} QuantizationParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuantizationParameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.QuantizationParameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.extent = $root.esriPBuffer.EsriTypes.Envelope.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.mode = reader.int32();
                            break;
                        case 3:
                            message.tolerance = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a QuantizationParameters message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.QuantizationParameters} QuantizationParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                QuantizationParameters.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a QuantizationParameters message.
                 * @function verify
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QuantizationParameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.extent != null && message.hasOwnProperty("extent")) {
                        var error = $root.esriPBuffer.EsriTypes.Envelope.verify(message.extent);
                        if (error)
                            return "extent." + error;
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.tolerance != null && message.hasOwnProperty("tolerance"))
                        if (typeof message.tolerance !== "number")
                            return "tolerance: number expected";
                    return null;
                };
    
                /**
                 * Creates a QuantizationParameters message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.QuantizationParameters} QuantizationParameters
                 */
                QuantizationParameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.QuantizationParameters)
                        return object;
                    var message = new $root.esriPBuffer.graph.QuantizationParameters();
                    if (object.extent != null) {
                        if (typeof object.extent !== "object")
                            throw TypeError(".esriPBuffer.graph.QuantizationParameters.extent: object expected");
                        message.extent = $root.esriPBuffer.EsriTypes.Envelope.fromObject(object.extent);
                    }
                    switch (object.mode) {
                    case "view":
                    case 0:
                        message.mode = 0;
                        break;
                    case "edit":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    if (object.tolerance != null)
                        message.tolerance = Number(object.tolerance);
                    return message;
                };
    
                /**
                 * Creates a plain object from a QuantizationParameters message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @static
                 * @param {esriPBuffer.graph.QuantizationParameters} message QuantizationParameters
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QuantizationParameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.extent = null;
                        object.mode = options.enums === String ? "view" : 0;
                        object.tolerance = 0;
                    }
                    if (message.extent != null && message.hasOwnProperty("extent"))
                        object.extent = $root.esriPBuffer.EsriTypes.Envelope.toObject(message.extent, options);
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.esriPBuffer.graph.QuantizationParameters.QuantizeMode[message.mode] : message.mode;
                    if (message.tolerance != null && message.hasOwnProperty("tolerance"))
                        object.tolerance = options.json && !isFinite(message.tolerance) ? String(message.tolerance) : message.tolerance;
                    return object;
                };
    
                /**
                 * Converts this QuantizationParameters to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.QuantizationParameters
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QuantizationParameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * QuantizeMode enum.
                 * @name esriPBuffer.graph.QuantizationParameters.QuantizeMode
                 * @enum {number}
                 * @property {number} view=0 view value
                 * @property {number} edit=1 edit value
                 */
                QuantizationParameters.QuantizeMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "view"] = 0;
                    values[valuesById[1] = "edit"] = 1;
                    return values;
                })();
    
                return QuantizationParameters;
            })();
    
            graph.Transform = (function() {
    
                /**
                 * Properties of a Transform.
                 * @memberof esriPBuffer.graph
                 * @interface ITransform
                 * @property {esriPBuffer.EsriTypes.IScale|null} [scale] Transform scale
                 * @property {esriPBuffer.EsriTypes.ITranslate|null} [translate] Transform translate
                 */
    
                /**
                 * Constructs a new Transform.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a Transform.
                 * @implements ITransform
                 * @constructor
                 * @param {esriPBuffer.graph.ITransform=} [properties] Properties to set
                 */
                function Transform(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Transform scale.
                 * @member {esriPBuffer.EsriTypes.IScale|null|undefined} scale
                 * @memberof esriPBuffer.graph.Transform
                 * @instance
                 */
                Transform.prototype.scale = null;
    
                /**
                 * Transform translate.
                 * @member {esriPBuffer.EsriTypes.ITranslate|null|undefined} translate
                 * @memberof esriPBuffer.graph.Transform
                 * @instance
                 */
                Transform.prototype.translate = null;
    
                /**
                 * Creates a new Transform instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {esriPBuffer.graph.ITransform=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Transform} Transform instance
                 */
                Transform.create = function create(properties) {
                    return new Transform(properties);
                };
    
                /**
                 * Encodes the specified Transform message. Does not implicitly {@link esriPBuffer.graph.Transform.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {esriPBuffer.graph.ITransform} message Transform message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transform.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                        $root.esriPBuffer.EsriTypes.Scale.encode(message.scale, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.translate != null && Object.hasOwnProperty.call(message, "translate"))
                        $root.esriPBuffer.EsriTypes.Translate.encode(message.translate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Transform message, length delimited. Does not implicitly {@link esriPBuffer.graph.Transform.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {esriPBuffer.graph.ITransform} message Transform message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Transform.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Transform message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Transform} Transform
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transform.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Transform();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.scale = $root.esriPBuffer.EsriTypes.Scale.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.translate = $root.esriPBuffer.EsriTypes.Translate.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Transform message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Transform} Transform
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Transform.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Transform message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Transform.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        var error = $root.esriPBuffer.EsriTypes.Scale.verify(message.scale);
                        if (error)
                            return "scale." + error;
                    }
                    if (message.translate != null && message.hasOwnProperty("translate")) {
                        var error = $root.esriPBuffer.EsriTypes.Translate.verify(message.translate);
                        if (error)
                            return "translate." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a Transform message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Transform} Transform
                 */
                Transform.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Transform)
                        return object;
                    var message = new $root.esriPBuffer.graph.Transform();
                    if (object.scale != null) {
                        if (typeof object.scale !== "object")
                            throw TypeError(".esriPBuffer.graph.Transform.scale: object expected");
                        message.scale = $root.esriPBuffer.EsriTypes.Scale.fromObject(object.scale);
                    }
                    if (object.translate != null) {
                        if (typeof object.translate !== "object")
                            throw TypeError(".esriPBuffer.graph.Transform.translate: object expected");
                        message.translate = $root.esriPBuffer.EsriTypes.Translate.fromObject(object.translate);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Transform message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Transform
                 * @static
                 * @param {esriPBuffer.graph.Transform} message Transform
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Transform.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.scale = null;
                        object.translate = null;
                    }
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        object.scale = $root.esriPBuffer.EsriTypes.Scale.toObject(message.scale, options);
                    if (message.translate != null && message.hasOwnProperty("translate"))
                        object.translate = $root.esriPBuffer.EsriTypes.Translate.toObject(message.translate, options);
                    return object;
                };
    
                /**
                 * Converts this Transform to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Transform
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Transform.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Transform;
            })();
    
            graph.GeometryArray = (function() {
    
                /**
                 * Properties of a GeometryArray.
                 * @memberof esriPBuffer.graph
                 * @interface IGeometryArray
                 * @property {Array.<esriPBuffer.graph.IGeometryValue>|null} [value] GeometryArray value
                 */
    
                /**
                 * Constructs a new GeometryArray.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GeometryArray.
                 * @implements IGeometryArray
                 * @constructor
                 * @param {esriPBuffer.graph.IGeometryArray=} [properties] Properties to set
                 */
                function GeometryArray(properties) {
                    this.value = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GeometryArray value.
                 * @member {Array.<esriPBuffer.graph.IGeometryValue>} value
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @instance
                 */
                GeometryArray.prototype.value = $util.emptyArray;
    
                /**
                 * Creates a new GeometryArray instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {esriPBuffer.graph.IGeometryArray=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GeometryArray} GeometryArray instance
                 */
                GeometryArray.create = function create(properties) {
                    return new GeometryArray(properties);
                };
    
                /**
                 * Encodes the specified GeometryArray message. Does not implicitly {@link esriPBuffer.graph.GeometryArray.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {esriPBuffer.graph.IGeometryArray} message GeometryArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeometryArray.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.value != null && message.value.length)
                        for (var i = 0; i < message.value.length; ++i)
                            $root.esriPBuffer.graph.GeometryValue.encode(message.value[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GeometryArray message, length delimited. Does not implicitly {@link esriPBuffer.graph.GeometryArray.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {esriPBuffer.graph.IGeometryArray} message GeometryArray message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GeometryArray.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GeometryArray message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GeometryArray} GeometryArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeometryArray.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GeometryArray();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.esriPBuffer.graph.GeometryValue.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GeometryArray message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GeometryArray} GeometryArray
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GeometryArray.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GeometryArray message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GeometryArray.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (!Array.isArray(message.value))
                            return "value: array expected";
                        for (var i = 0; i < message.value.length; ++i) {
                            var error = $root.esriPBuffer.graph.GeometryValue.verify(message.value[i]);
                            if (error)
                                return "value." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GeometryArray message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GeometryArray} GeometryArray
                 */
                GeometryArray.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GeometryArray)
                        return object;
                    var message = new $root.esriPBuffer.graph.GeometryArray();
                    if (object.value) {
                        if (!Array.isArray(object.value))
                            throw TypeError(".esriPBuffer.graph.GeometryArray.value: array expected");
                        message.value = [];
                        for (var i = 0; i < object.value.length; ++i) {
                            if (typeof object.value[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GeometryArray.value: object expected");
                            message.value[i] = $root.esriPBuffer.graph.GeometryValue.fromObject(object.value[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GeometryArray message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @static
                 * @param {esriPBuffer.graph.GeometryArray} message GeometryArray
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GeometryArray.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.value = [];
                    if (message.value && message.value.length) {
                        object.value = [];
                        for (var j = 0; j < message.value.length; ++j)
                            object.value[j] = $root.esriPBuffer.graph.GeometryValue.toObject(message.value[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GeometryArray to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GeometryArray
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GeometryArray.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GeometryArray;
            })();
    
            graph.PrimitiveValue = (function() {
    
                /**
                 * Properties of a PrimitiveValue.
                 * @memberof esriPBuffer.graph
                 * @interface IPrimitiveValue
                 * @property {string|null} [stringValue] PrimitiveValue stringValue
                 * @property {number|null} [floatValue] PrimitiveValue floatValue
                 * @property {number|null} [floatCompressedAsInt32] PrimitiveValue floatCompressedAsInt32
                 * @property {number|null} [doubleValue] PrimitiveValue doubleValue
                 * @property {number|null} [doubleCompressedAsFloat] PrimitiveValue doubleCompressedAsFloat
                 * @property {number|Long|null} [doubleCompressedAsInt64] PrimitiveValue doubleCompressedAsInt64
                 * @property {number|Long|null} [sint64Value] PrimitiveValue sint64Value
                 * @property {boolean|null} [boolValue] PrimitiveValue boolValue
                 * @property {Uint8Array|null} [uuidValue] PrimitiveValue uuidValue
                 * @property {esriPBuffer.graph.IGeometryValue|null} [geometryValue] PrimitiveValue geometryValue
                 * @property {boolean|null} [nullTag] PrimitiveValue nullTag
                 * @property {number|Long|null} [datetimeValue] PrimitiveValue datetimeValue
                 */
    
                /**
                 * Constructs a new PrimitiveValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a PrimitiveValue.
                 * @implements IPrimitiveValue
                 * @constructor
                 * @param {esriPBuffer.graph.IPrimitiveValue=} [properties] Properties to set
                 */
                function PrimitiveValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PrimitiveValue stringValue.
                 * @member {string|null|undefined} stringValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.stringValue = null;
    
                /**
                 * PrimitiveValue floatValue.
                 * @member {number|null|undefined} floatValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.floatValue = null;
    
                /**
                 * PrimitiveValue floatCompressedAsInt32.
                 * @member {number|null|undefined} floatCompressedAsInt32
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.floatCompressedAsInt32 = null;
    
                /**
                 * PrimitiveValue doubleValue.
                 * @member {number|null|undefined} doubleValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.doubleValue = null;
    
                /**
                 * PrimitiveValue doubleCompressedAsFloat.
                 * @member {number|null|undefined} doubleCompressedAsFloat
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.doubleCompressedAsFloat = null;
    
                /**
                 * PrimitiveValue doubleCompressedAsInt64.
                 * @member {number|Long|null|undefined} doubleCompressedAsInt64
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.doubleCompressedAsInt64 = null;
    
                /**
                 * PrimitiveValue sint64Value.
                 * @member {number|Long|null|undefined} sint64Value
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.sint64Value = null;
    
                /**
                 * PrimitiveValue boolValue.
                 * @member {boolean|null|undefined} boolValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.boolValue = null;
    
                /**
                 * PrimitiveValue uuidValue.
                 * @member {Uint8Array|null|undefined} uuidValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.uuidValue = null;
    
                /**
                 * PrimitiveValue geometryValue.
                 * @member {esriPBuffer.graph.IGeometryValue|null|undefined} geometryValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.geometryValue = null;
    
                /**
                 * PrimitiveValue nullTag.
                 * @member {boolean|null|undefined} nullTag
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.nullTag = null;
    
                /**
                 * PrimitiveValue datetimeValue.
                 * @member {number|Long|null|undefined} datetimeValue
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                PrimitiveValue.prototype.datetimeValue = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * PrimitiveValue valueType.
                 * @member {"stringValue"|"floatValue"|"floatCompressedAsInt32"|"doubleValue"|"doubleCompressedAsFloat"|"doubleCompressedAsInt64"|"sint64Value"|"boolValue"|"uuidValue"|"geometryValue"|"nullTag"|"datetimeValue"|undefined} valueType
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 */
                Object.defineProperty(PrimitiveValue.prototype, "valueType", {
                    get: $util.oneOfGetter($oneOfFields = ["stringValue", "floatValue", "floatCompressedAsInt32", "doubleValue", "doubleCompressedAsFloat", "doubleCompressedAsInt64", "sint64Value", "boolValue", "uuidValue", "geometryValue", "nullTag", "datetimeValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new PrimitiveValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {esriPBuffer.graph.IPrimitiveValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.PrimitiveValue} PrimitiveValue instance
                 */
                PrimitiveValue.create = function create(properties) {
                    return new PrimitiveValue(properties);
                };
    
                /**
                 * Encodes the specified PrimitiveValue message. Does not implicitly {@link esriPBuffer.graph.PrimitiveValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {esriPBuffer.graph.IPrimitiveValue} message PrimitiveValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrimitiveValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);
                    if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.floatValue);
                    if (message.floatCompressedAsInt32 != null && Object.hasOwnProperty.call(message, "floatCompressedAsInt32"))
                        writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.floatCompressedAsInt32);
                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                        writer.uint32(/* id 4, wireType 1 =*/33).double(message.doubleValue);
                    if (message.doubleCompressedAsFloat != null && Object.hasOwnProperty.call(message, "doubleCompressedAsFloat"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.doubleCompressedAsFloat);
                    if (message.doubleCompressedAsInt64 != null && Object.hasOwnProperty.call(message, "doubleCompressedAsInt64"))
                        writer.uint32(/* id 6, wireType 0 =*/48).sint64(message.doubleCompressedAsInt64);
                    if (message.sint64Value != null && Object.hasOwnProperty.call(message, "sint64Value"))
                        writer.uint32(/* id 7, wireType 0 =*/56).sint64(message.sint64Value);
                    if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.boolValue);
                    if (message.uuidValue != null && Object.hasOwnProperty.call(message, "uuidValue"))
                        writer.uint32(/* id 9, wireType 2 =*/74).bytes(message.uuidValue);
                    if (message.geometryValue != null && Object.hasOwnProperty.call(message, "geometryValue"))
                        $root.esriPBuffer.graph.GeometryValue.encode(message.geometryValue, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.nullTag != null && Object.hasOwnProperty.call(message, "nullTag"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.nullTag);
                    if (message.datetimeValue != null && Object.hasOwnProperty.call(message, "datetimeValue"))
                        writer.uint32(/* id 13, wireType 0 =*/104).int64(message.datetimeValue);
                    return writer;
                };
    
                /**
                 * Encodes the specified PrimitiveValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.PrimitiveValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {esriPBuffer.graph.IPrimitiveValue} message PrimitiveValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PrimitiveValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PrimitiveValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.PrimitiveValue} PrimitiveValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrimitiveValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.PrimitiveValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringValue = reader.string();
                            break;
                        case 2:
                            message.floatValue = reader.float();
                            break;
                        case 3:
                            message.floatCompressedAsInt32 = reader.sint32();
                            break;
                        case 4:
                            message.doubleValue = reader.double();
                            break;
                        case 5:
                            message.doubleCompressedAsFloat = reader.float();
                            break;
                        case 6:
                            message.doubleCompressedAsInt64 = reader.sint64();
                            break;
                        case 7:
                            message.sint64Value = reader.sint64();
                            break;
                        case 8:
                            message.boolValue = reader.bool();
                            break;
                        case 9:
                            message.uuidValue = reader.bytes();
                            break;
                        case 11:
                            message.geometryValue = $root.esriPBuffer.graph.GeometryValue.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.nullTag = reader.bool();
                            break;
                        case 13:
                            message.datetimeValue = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PrimitiveValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.PrimitiveValue} PrimitiveValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PrimitiveValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PrimitiveValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PrimitiveValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        properties.valueType = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.floatValue !== "number")
                            return "floatValue: number expected";
                    }
                    if (message.floatCompressedAsInt32 != null && message.hasOwnProperty("floatCompressedAsInt32")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.floatCompressedAsInt32))
                            return "floatCompressedAsInt32: integer expected";
                    }
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.doubleValue !== "number")
                            return "doubleValue: number expected";
                    }
                    if (message.doubleCompressedAsFloat != null && message.hasOwnProperty("doubleCompressedAsFloat")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.doubleCompressedAsFloat !== "number")
                            return "doubleCompressedAsFloat: number expected";
                    }
                    if (message.doubleCompressedAsInt64 != null && message.hasOwnProperty("doubleCompressedAsInt64")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.doubleCompressedAsInt64) && !(message.doubleCompressedAsInt64 && $util.isInteger(message.doubleCompressedAsInt64.low) && $util.isInteger(message.doubleCompressedAsInt64.high)))
                            return "doubleCompressedAsInt64: integer|Long expected";
                    }
                    if (message.sint64Value != null && message.hasOwnProperty("sint64Value")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.sint64Value) && !(message.sint64Value && $util.isInteger(message.sint64Value.low) && $util.isInteger(message.sint64Value.high)))
                            return "sint64Value: integer|Long expected";
                    }
                    if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.boolValue !== "boolean")
                            return "boolValue: boolean expected";
                    }
                    if (message.uuidValue != null && message.hasOwnProperty("uuidValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!(message.uuidValue && typeof message.uuidValue.length === "number" || $util.isString(message.uuidValue)))
                            return "uuidValue: buffer expected";
                    }
                    if (message.geometryValue != null && message.hasOwnProperty("geometryValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.GeometryValue.verify(message.geometryValue);
                            if (error)
                                return "geometryValue." + error;
                        }
                    }
                    if (message.nullTag != null && message.hasOwnProperty("nullTag")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (typeof message.nullTag !== "boolean")
                            return "nullTag: boolean expected";
                    }
                    if (message.datetimeValue != null && message.hasOwnProperty("datetimeValue")) {
                        if (properties.valueType === 1)
                            return "valueType: multiple values";
                        properties.valueType = 1;
                        if (!$util.isInteger(message.datetimeValue) && !(message.datetimeValue && $util.isInteger(message.datetimeValue.low) && $util.isInteger(message.datetimeValue.high)))
                            return "datetimeValue: integer|Long expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a PrimitiveValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.PrimitiveValue} PrimitiveValue
                 */
                PrimitiveValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.PrimitiveValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.PrimitiveValue();
                    if (object.stringValue != null)
                        message.stringValue = String(object.stringValue);
                    if (object.floatValue != null)
                        message.floatValue = Number(object.floatValue);
                    if (object.floatCompressedAsInt32 != null)
                        message.floatCompressedAsInt32 = object.floatCompressedAsInt32 | 0;
                    if (object.doubleValue != null)
                        message.doubleValue = Number(object.doubleValue);
                    if (object.doubleCompressedAsFloat != null)
                        message.doubleCompressedAsFloat = Number(object.doubleCompressedAsFloat);
                    if (object.doubleCompressedAsInt64 != null)
                        if ($util.Long)
                            (message.doubleCompressedAsInt64 = $util.Long.fromValue(object.doubleCompressedAsInt64)).unsigned = false;
                        else if (typeof object.doubleCompressedAsInt64 === "string")
                            message.doubleCompressedAsInt64 = parseInt(object.doubleCompressedAsInt64, 10);
                        else if (typeof object.doubleCompressedAsInt64 === "number")
                            message.doubleCompressedAsInt64 = object.doubleCompressedAsInt64;
                        else if (typeof object.doubleCompressedAsInt64 === "object")
                            message.doubleCompressedAsInt64 = new $util.LongBits(object.doubleCompressedAsInt64.low >>> 0, object.doubleCompressedAsInt64.high >>> 0).toNumber();
                    if (object.sint64Value != null)
                        if ($util.Long)
                            (message.sint64Value = $util.Long.fromValue(object.sint64Value)).unsigned = false;
                        else if (typeof object.sint64Value === "string")
                            message.sint64Value = parseInt(object.sint64Value, 10);
                        else if (typeof object.sint64Value === "number")
                            message.sint64Value = object.sint64Value;
                        else if (typeof object.sint64Value === "object")
                            message.sint64Value = new $util.LongBits(object.sint64Value.low >>> 0, object.sint64Value.high >>> 0).toNumber();
                    if (object.boolValue != null)
                        message.boolValue = Boolean(object.boolValue);
                    if (object.uuidValue != null)
                        if (typeof object.uuidValue === "string")
                            $util.base64.decode(object.uuidValue, message.uuidValue = $util.newBuffer($util.base64.length(object.uuidValue)), 0);
                        else if (object.uuidValue.length)
                            message.uuidValue = object.uuidValue;
                    if (object.geometryValue != null) {
                        if (typeof object.geometryValue !== "object")
                            throw TypeError(".esriPBuffer.graph.PrimitiveValue.geometryValue: object expected");
                        message.geometryValue = $root.esriPBuffer.graph.GeometryValue.fromObject(object.geometryValue);
                    }
                    if (object.nullTag != null)
                        message.nullTag = Boolean(object.nullTag);
                    if (object.datetimeValue != null)
                        if ($util.Long)
                            (message.datetimeValue = $util.Long.fromValue(object.datetimeValue)).unsigned = false;
                        else if (typeof object.datetimeValue === "string")
                            message.datetimeValue = parseInt(object.datetimeValue, 10);
                        else if (typeof object.datetimeValue === "number")
                            message.datetimeValue = object.datetimeValue;
                        else if (typeof object.datetimeValue === "object")
                            message.datetimeValue = new $util.LongBits(object.datetimeValue.low >>> 0, object.datetimeValue.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from a PrimitiveValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @static
                 * @param {esriPBuffer.graph.PrimitiveValue} message PrimitiveValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PrimitiveValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        object.stringValue = message.stringValue;
                        if (options.oneofs)
                            object.valueType = "stringValue";
                    }
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                        if (options.oneofs)
                            object.valueType = "floatValue";
                    }
                    if (message.floatCompressedAsInt32 != null && message.hasOwnProperty("floatCompressedAsInt32")) {
                        object.floatCompressedAsInt32 = message.floatCompressedAsInt32;
                        if (options.oneofs)
                            object.valueType = "floatCompressedAsInt32";
                    }
                    if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                        object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                        if (options.oneofs)
                            object.valueType = "doubleValue";
                    }
                    if (message.doubleCompressedAsFloat != null && message.hasOwnProperty("doubleCompressedAsFloat")) {
                        object.doubleCompressedAsFloat = options.json && !isFinite(message.doubleCompressedAsFloat) ? String(message.doubleCompressedAsFloat) : message.doubleCompressedAsFloat;
                        if (options.oneofs)
                            object.valueType = "doubleCompressedAsFloat";
                    }
                    if (message.doubleCompressedAsInt64 != null && message.hasOwnProperty("doubleCompressedAsInt64")) {
                        if (typeof message.doubleCompressedAsInt64 === "number")
                            object.doubleCompressedAsInt64 = options.longs === String ? String(message.doubleCompressedAsInt64) : message.doubleCompressedAsInt64;
                        else
                            object.doubleCompressedAsInt64 = options.longs === String ? $util.Long.prototype.toString.call(message.doubleCompressedAsInt64) : options.longs === Number ? new $util.LongBits(message.doubleCompressedAsInt64.low >>> 0, message.doubleCompressedAsInt64.high >>> 0).toNumber() : message.doubleCompressedAsInt64;
                        if (options.oneofs)
                            object.valueType = "doubleCompressedAsInt64";
                    }
                    if (message.sint64Value != null && message.hasOwnProperty("sint64Value")) {
                        if (typeof message.sint64Value === "number")
                            object.sint64Value = options.longs === String ? String(message.sint64Value) : message.sint64Value;
                        else
                            object.sint64Value = options.longs === String ? $util.Long.prototype.toString.call(message.sint64Value) : options.longs === Number ? new $util.LongBits(message.sint64Value.low >>> 0, message.sint64Value.high >>> 0).toNumber() : message.sint64Value;
                        if (options.oneofs)
                            object.valueType = "sint64Value";
                    }
                    if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                        object.boolValue = message.boolValue;
                        if (options.oneofs)
                            object.valueType = "boolValue";
                    }
                    if (message.uuidValue != null && message.hasOwnProperty("uuidValue")) {
                        object.uuidValue = options.bytes === String ? $util.base64.encode(message.uuidValue, 0, message.uuidValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.uuidValue) : message.uuidValue;
                        if (options.oneofs)
                            object.valueType = "uuidValue";
                    }
                    if (message.geometryValue != null && message.hasOwnProperty("geometryValue")) {
                        object.geometryValue = $root.esriPBuffer.graph.GeometryValue.toObject(message.geometryValue, options);
                        if (options.oneofs)
                            object.valueType = "geometryValue";
                    }
                    if (message.nullTag != null && message.hasOwnProperty("nullTag")) {
                        object.nullTag = message.nullTag;
                        if (options.oneofs)
                            object.valueType = "nullTag";
                    }
                    if (message.datetimeValue != null && message.hasOwnProperty("datetimeValue")) {
                        if (typeof message.datetimeValue === "number")
                            object.datetimeValue = options.longs === String ? String(message.datetimeValue) : message.datetimeValue;
                        else
                            object.datetimeValue = options.longs === String ? $util.Long.prototype.toString.call(message.datetimeValue) : options.longs === Number ? new $util.LongBits(message.datetimeValue.low >>> 0, message.datetimeValue.high >>> 0).toNumber() : message.datetimeValue;
                        if (options.oneofs)
                            object.valueType = "datetimeValue";
                    }
                    return object;
                };
    
                /**
                 * Converts this PrimitiveValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.PrimitiveValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PrimitiveValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PrimitiveValue;
            })();
    
            graph.ObjectValue = (function() {
    
                /**
                 * Properties of an ObjectValue.
                 * @memberof esriPBuffer.graph
                 * @interface IObjectValue
                 * @property {Object.<string,esriPBuffer.graph.IAnyValue>|null} [properties] ObjectValue properties
                 */
    
                /**
                 * Constructs a new ObjectValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an ObjectValue.
                 * @implements IObjectValue
                 * @constructor
                 * @param {esriPBuffer.graph.IObjectValue=} [properties] Properties to set
                 */
                function ObjectValue(properties) {
                    this.properties = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ObjectValue properties.
                 * @member {Object.<string,esriPBuffer.graph.IAnyValue>} properties
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @instance
                 */
                ObjectValue.prototype.properties = $util.emptyObject;
    
                /**
                 * Creates a new ObjectValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {esriPBuffer.graph.IObjectValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.ObjectValue} ObjectValue instance
                 */
                ObjectValue.create = function create(properties) {
                    return new ObjectValue(properties);
                };
    
                /**
                 * Encodes the specified ObjectValue message. Does not implicitly {@link esriPBuffer.graph.ObjectValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {esriPBuffer.graph.IObjectValue} message ObjectValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.AnyValue.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified ObjectValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.ObjectValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {esriPBuffer.graph.IObjectValue} message ObjectValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ObjectValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ObjectValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.ObjectValue} ObjectValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.ObjectValue(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.properties === $util.emptyObject)
                                message.properties = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.properties[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ObjectValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.ObjectValue} ObjectValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ObjectValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ObjectValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ObjectValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!$util.isObject(message.properties))
                            return "properties: object expected";
                        var key = Object.keys(message.properties);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.properties[key[i]]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an ObjectValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.ObjectValue} ObjectValue
                 */
                ObjectValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.ObjectValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.ObjectValue();
                    if (object.properties) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".esriPBuffer.graph.ObjectValue.properties: object expected");
                        message.properties = {};
                        for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                            if (typeof object.properties[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.ObjectValue.properties: object expected");
                            message.properties[keys[i]] = $root.esriPBuffer.graph.AnyValue.fromObject(object.properties[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ObjectValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @static
                 * @param {esriPBuffer.graph.ObjectValue} message ObjectValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ObjectValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.properties = {};
                    var keys2;
                    if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                        object.properties = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.properties[keys2[j]] = $root.esriPBuffer.graph.AnyValue.toObject(message.properties[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ObjectValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.ObjectValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ObjectValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ObjectValue;
            })();
    
            graph.EntityValue = (function() {
    
                /**
                 * Properties of an EntityValue.
                 * @memberof esriPBuffer.graph
                 * @interface IEntityValue
                 * @property {string|null} [label] EntityValue label
                 * @property {Object.<string,esriPBuffer.graph.IAnyValue>|null} [properties] EntityValue properties
                 */
    
                /**
                 * Constructs a new EntityValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an EntityValue.
                 * @implements IEntityValue
                 * @constructor
                 * @param {esriPBuffer.graph.IEntityValue=} [properties] Properties to set
                 */
                function EntityValue(properties) {
                    this.properties = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EntityValue label.
                 * @member {string} label
                 * @memberof esriPBuffer.graph.EntityValue
                 * @instance
                 */
                EntityValue.prototype.label = "";
    
                /**
                 * EntityValue properties.
                 * @member {Object.<string,esriPBuffer.graph.IAnyValue>} properties
                 * @memberof esriPBuffer.graph.EntityValue
                 * @instance
                 */
                EntityValue.prototype.properties = $util.emptyObject;
    
                /**
                 * Creates a new EntityValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {esriPBuffer.graph.IEntityValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.EntityValue} EntityValue instance
                 */
                EntityValue.create = function create(properties) {
                    return new EntityValue(properties);
                };
    
                /**
                 * Encodes the specified EntityValue message. Does not implicitly {@link esriPBuffer.graph.EntityValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {esriPBuffer.graph.IEntityValue} message EntityValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EntityValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.AnyValue.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified EntityValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.EntityValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {esriPBuffer.graph.IEntityValue} message EntityValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EntityValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EntityValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.EntityValue} EntityValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EntityValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.EntityValue(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.label = reader.string();
                            break;
                        case 2:
                            if (message.properties === $util.emptyObject)
                                message.properties = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.properties[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EntityValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.EntityValue} EntityValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EntityValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EntityValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EntityValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!$util.isObject(message.properties))
                            return "properties: object expected";
                        var key = Object.keys(message.properties);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.properties[key[i]]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EntityValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.EntityValue} EntityValue
                 */
                EntityValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.EntityValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.EntityValue();
                    if (object.label != null)
                        message.label = String(object.label);
                    if (object.properties) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".esriPBuffer.graph.EntityValue.properties: object expected");
                        message.properties = {};
                        for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                            if (typeof object.properties[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.EntityValue.properties: object expected");
                            message.properties[keys[i]] = $root.esriPBuffer.graph.AnyValue.fromObject(object.properties[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EntityValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.EntityValue
                 * @static
                 * @param {esriPBuffer.graph.EntityValue} message EntityValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EntityValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.properties = {};
                    if (options.defaults)
                        object.label = "";
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    var keys2;
                    if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                        object.properties = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.properties[keys2[j]] = $root.esriPBuffer.graph.AnyValue.toObject(message.properties[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EntityValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.EntityValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EntityValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EntityValue;
            })();
    
            graph.RelationshipValue = (function() {
    
                /**
                 * Properties of a RelationshipValue.
                 * @memberof esriPBuffer.graph
                 * @interface IRelationshipValue
                 * @property {string|null} [type] RelationshipValue type
                 * @property {Object.<string,esriPBuffer.graph.IAnyValue>|null} [properties] RelationshipValue properties
                 */
    
                /**
                 * Constructs a new RelationshipValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a RelationshipValue.
                 * @implements IRelationshipValue
                 * @constructor
                 * @param {esriPBuffer.graph.IRelationshipValue=} [properties] Properties to set
                 */
                function RelationshipValue(properties) {
                    this.properties = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RelationshipValue type.
                 * @member {string} type
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @instance
                 */
                RelationshipValue.prototype.type = "";
    
                /**
                 * RelationshipValue properties.
                 * @member {Object.<string,esriPBuffer.graph.IAnyValue>} properties
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @instance
                 */
                RelationshipValue.prototype.properties = $util.emptyObject;
    
                /**
                 * Creates a new RelationshipValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.RelationshipValue} RelationshipValue instance
                 */
                RelationshipValue.create = function create(properties) {
                    return new RelationshipValue(properties);
                };
    
                /**
                 * Encodes the specified RelationshipValue message. Does not implicitly {@link esriPBuffer.graph.RelationshipValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipValue} message RelationshipValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.type);
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.AnyValue.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified RelationshipValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.RelationshipValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipValue} message RelationshipValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RelationshipValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.RelationshipValue} RelationshipValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.RelationshipValue(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.string();
                            break;
                        case 2:
                            if (message.properties === $util.emptyObject)
                                message.properties = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.properties[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RelationshipValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.RelationshipValue} RelationshipValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RelationshipValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RelationshipValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!$util.isObject(message.properties))
                            return "properties: object expected";
                        var key = Object.keys(message.properties);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.properties[key[i]]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a RelationshipValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.RelationshipValue} RelationshipValue
                 */
                RelationshipValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.RelationshipValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.RelationshipValue();
                    if (object.type != null)
                        message.type = String(object.type);
                    if (object.properties) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".esriPBuffer.graph.RelationshipValue.properties: object expected");
                        message.properties = {};
                        for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                            if (typeof object.properties[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.RelationshipValue.properties: object expected");
                            message.properties[keys[i]] = $root.esriPBuffer.graph.AnyValue.fromObject(object.properties[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a RelationshipValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @static
                 * @param {esriPBuffer.graph.RelationshipValue} message RelationshipValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RelationshipValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.properties = {};
                    if (options.defaults)
                        object.type = "";
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    var keys2;
                    if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                        object.properties = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.properties[keys2[j]] = $root.esriPBuffer.graph.AnyValue.toObject(message.properties[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this RelationshipValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.RelationshipValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RelationshipValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RelationshipValue;
            })();
    
            graph.PathValue = (function() {
    
                /**
                 * Properties of a PathValue.
                 * @memberof esriPBuffer.graph
                 * @interface IPathValue
                 * @property {Array.<esriPBuffer.graph.IEntityValue>|null} [entities] PathValue entities
                 * @property {Array.<esriPBuffer.graph.IRelationshipValue>|null} [relationships] PathValue relationships
                 */
    
                /**
                 * Constructs a new PathValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a PathValue.
                 * @implements IPathValue
                 * @constructor
                 * @param {esriPBuffer.graph.IPathValue=} [properties] Properties to set
                 */
                function PathValue(properties) {
                    this.entities = [];
                    this.relationships = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PathValue entities.
                 * @member {Array.<esriPBuffer.graph.IEntityValue>} entities
                 * @memberof esriPBuffer.graph.PathValue
                 * @instance
                 */
                PathValue.prototype.entities = $util.emptyArray;
    
                /**
                 * PathValue relationships.
                 * @member {Array.<esriPBuffer.graph.IRelationshipValue>} relationships
                 * @memberof esriPBuffer.graph.PathValue
                 * @instance
                 */
                PathValue.prototype.relationships = $util.emptyArray;
    
                /**
                 * Creates a new PathValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {esriPBuffer.graph.IPathValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.PathValue} PathValue instance
                 */
                PathValue.create = function create(properties) {
                    return new PathValue(properties);
                };
    
                /**
                 * Encodes the specified PathValue message. Does not implicitly {@link esriPBuffer.graph.PathValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {esriPBuffer.graph.IPathValue} message PathValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PathValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entities != null && message.entities.length)
                        for (var i = 0; i < message.entities.length; ++i)
                            $root.esriPBuffer.graph.EntityValue.encode(message.entities[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.relationships != null && message.relationships.length)
                        for (var i = 0; i < message.relationships.length; ++i)
                            $root.esriPBuffer.graph.RelationshipValue.encode(message.relationships[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PathValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.PathValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {esriPBuffer.graph.IPathValue} message PathValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PathValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PathValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.PathValue} PathValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PathValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.PathValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entities && message.entities.length))
                                message.entities = [];
                            message.entities.push($root.esriPBuffer.graph.EntityValue.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.relationships && message.relationships.length))
                                message.relationships = [];
                            message.relationships.push($root.esriPBuffer.graph.RelationshipValue.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PathValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.PathValue} PathValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PathValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PathValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PathValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entities != null && message.hasOwnProperty("entities")) {
                        if (!Array.isArray(message.entities))
                            return "entities: array expected";
                        for (var i = 0; i < message.entities.length; ++i) {
                            var error = $root.esriPBuffer.graph.EntityValue.verify(message.entities[i]);
                            if (error)
                                return "entities." + error;
                        }
                    }
                    if (message.relationships != null && message.hasOwnProperty("relationships")) {
                        if (!Array.isArray(message.relationships))
                            return "relationships: array expected";
                        for (var i = 0; i < message.relationships.length; ++i) {
                            var error = $root.esriPBuffer.graph.RelationshipValue.verify(message.relationships[i]);
                            if (error)
                                return "relationships." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a PathValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.PathValue} PathValue
                 */
                PathValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.PathValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.PathValue();
                    if (object.entities) {
                        if (!Array.isArray(object.entities))
                            throw TypeError(".esriPBuffer.graph.PathValue.entities: array expected");
                        message.entities = [];
                        for (var i = 0; i < object.entities.length; ++i) {
                            if (typeof object.entities[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.PathValue.entities: object expected");
                            message.entities[i] = $root.esriPBuffer.graph.EntityValue.fromObject(object.entities[i]);
                        }
                    }
                    if (object.relationships) {
                        if (!Array.isArray(object.relationships))
                            throw TypeError(".esriPBuffer.graph.PathValue.relationships: array expected");
                        message.relationships = [];
                        for (var i = 0; i < object.relationships.length; ++i) {
                            if (typeof object.relationships[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.PathValue.relationships: object expected");
                            message.relationships[i] = $root.esriPBuffer.graph.RelationshipValue.fromObject(object.relationships[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PathValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.PathValue
                 * @static
                 * @param {esriPBuffer.graph.PathValue} message PathValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PathValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.entities = [];
                        object.relationships = [];
                    }
                    if (message.entities && message.entities.length) {
                        object.entities = [];
                        for (var j = 0; j < message.entities.length; ++j)
                            object.entities[j] = $root.esriPBuffer.graph.EntityValue.toObject(message.entities[j], options);
                    }
                    if (message.relationships && message.relationships.length) {
                        object.relationships = [];
                        for (var j = 0; j < message.relationships.length; ++j)
                            object.relationships[j] = $root.esriPBuffer.graph.RelationshipValue.toObject(message.relationships[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this PathValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.PathValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PathValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PathValue;
            })();
    
            graph.ArrayValue = (function() {
    
                /**
                 * Properties of an ArrayValue.
                 * @memberof esriPBuffer.graph
                 * @interface IArrayValue
                 * @property {Array.<esriPBuffer.graph.IAnyValue>|null} [values] ArrayValue values
                 */
    
                /**
                 * Constructs a new ArrayValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an ArrayValue.
                 * @implements IArrayValue
                 * @constructor
                 * @param {esriPBuffer.graph.IArrayValue=} [properties] Properties to set
                 */
                function ArrayValue(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ArrayValue values.
                 * @member {Array.<esriPBuffer.graph.IAnyValue>} values
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @instance
                 */
                ArrayValue.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new ArrayValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {esriPBuffer.graph.IArrayValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.ArrayValue} ArrayValue instance
                 */
                ArrayValue.create = function create(properties) {
                    return new ArrayValue(properties);
                };
    
                /**
                 * Encodes the specified ArrayValue message. Does not implicitly {@link esriPBuffer.graph.ArrayValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {esriPBuffer.graph.IArrayValue} message ArrayValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            $root.esriPBuffer.graph.AnyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ArrayValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.ArrayValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {esriPBuffer.graph.IArrayValue} message ArrayValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ArrayValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.ArrayValue} ArrayValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.ArrayValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ArrayValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.ArrayValue} ArrayValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ArrayValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArrayValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an ArrayValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.ArrayValue} ArrayValue
                 */
                ArrayValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.ArrayValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.ArrayValue();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".esriPBuffer.graph.ArrayValue.values: array expected");
                        message.values = [];
                        for (var i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.ArrayValue.values: object expected");
                            message.values[i] = $root.esriPBuffer.graph.AnyValue.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ArrayValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @static
                 * @param {esriPBuffer.graph.ArrayValue} message ArrayValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArrayValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (var j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.esriPBuffer.graph.AnyValue.toObject(message.values[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this ArrayValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.ArrayValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArrayValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ArrayValue;
            })();
    
            graph.AnyValue = (function() {
    
                /**
                 * Properties of an AnyValue.
                 * @memberof esriPBuffer.graph
                 * @interface IAnyValue
                 * @property {esriPBuffer.graph.IPrimitiveValue|null} [primitiveValue] AnyValue primitiveValue
                 * @property {esriPBuffer.graph.IArrayValue|null} [arrayValue] AnyValue arrayValue
                 * @property {esriPBuffer.graph.IObjectValue|null} [objectValue] AnyValue objectValue
                 * @property {esriPBuffer.graph.IEntityValue|null} [entityValue] AnyValue entityValue
                 * @property {esriPBuffer.graph.IRelationshipValue|null} [relationshipValue] AnyValue relationshipValue
                 * @property {esriPBuffer.graph.IPathValue|null} [pathValue] AnyValue pathValue
                 * @property {esriPBuffer.graph.IFloatArray|null} [floatArray] AnyValue floatArray
                 * @property {esriPBuffer.graph.IInt32Array|null} [floatCompressedAsInt32Array] AnyValue floatCompressedAsInt32Array
                 * @property {esriPBuffer.graph.IDoubleArray|null} [doubleArray] AnyValue doubleArray
                 * @property {esriPBuffer.graph.IFloatArray|null} [doubleCompressedAsFloatArray] AnyValue doubleCompressedAsFloatArray
                 * @property {esriPBuffer.graph.IInt64Array|null} [doubleCompressedAsInt64Array] AnyValue doubleCompressedAsInt64Array
                 * @property {esriPBuffer.graph.IInt64Array|null} [sint64Array] AnyValue sint64Array
                 * @property {esriPBuffer.graph.IBoolArray|null} [boolArray] AnyValue boolArray
                 * @property {esriPBuffer.graph.INullArray|null} [nullArray] AnyValue nullArray
                 * @property {Uint8Array|null} [uuidArray] AnyValue uuidArray
                 * @property {esriPBuffer.graph.IDateTimeArray|null} [dateArray] AnyValue dateArray
                 * @property {esriPBuffer.graph.IStringArray|null} [stringArray] AnyValue stringArray
                 * @property {esriPBuffer.graph.IGeometryArray|null} [geometryArray] AnyValue geometryArray
                 */
    
                /**
                 * Constructs a new AnyValue.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an AnyValue.
                 * @implements IAnyValue
                 * @constructor
                 * @param {esriPBuffer.graph.IAnyValue=} [properties] Properties to set
                 */
                function AnyValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * AnyValue primitiveValue.
                 * @member {esriPBuffer.graph.IPrimitiveValue|null|undefined} primitiveValue
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.primitiveValue = null;
    
                /**
                 * AnyValue arrayValue.
                 * @member {esriPBuffer.graph.IArrayValue|null|undefined} arrayValue
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.arrayValue = null;
    
                /**
                 * AnyValue objectValue.
                 * @member {esriPBuffer.graph.IObjectValue|null|undefined} objectValue
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.objectValue = null;
    
                /**
                 * AnyValue entityValue.
                 * @member {esriPBuffer.graph.IEntityValue|null|undefined} entityValue
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.entityValue = null;
    
                /**
                 * AnyValue relationshipValue.
                 * @member {esriPBuffer.graph.IRelationshipValue|null|undefined} relationshipValue
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.relationshipValue = null;
    
                /**
                 * AnyValue pathValue.
                 * @member {esriPBuffer.graph.IPathValue|null|undefined} pathValue
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.pathValue = null;
    
                /**
                 * AnyValue floatArray.
                 * @member {esriPBuffer.graph.IFloatArray|null|undefined} floatArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.floatArray = null;
    
                /**
                 * AnyValue floatCompressedAsInt32Array.
                 * @member {esriPBuffer.graph.IInt32Array|null|undefined} floatCompressedAsInt32Array
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.floatCompressedAsInt32Array = null;
    
                /**
                 * AnyValue doubleArray.
                 * @member {esriPBuffer.graph.IDoubleArray|null|undefined} doubleArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.doubleArray = null;
    
                /**
                 * AnyValue doubleCompressedAsFloatArray.
                 * @member {esriPBuffer.graph.IFloatArray|null|undefined} doubleCompressedAsFloatArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.doubleCompressedAsFloatArray = null;
    
                /**
                 * AnyValue doubleCompressedAsInt64Array.
                 * @member {esriPBuffer.graph.IInt64Array|null|undefined} doubleCompressedAsInt64Array
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.doubleCompressedAsInt64Array = null;
    
                /**
                 * AnyValue sint64Array.
                 * @member {esriPBuffer.graph.IInt64Array|null|undefined} sint64Array
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.sint64Array = null;
    
                /**
                 * AnyValue boolArray.
                 * @member {esriPBuffer.graph.IBoolArray|null|undefined} boolArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.boolArray = null;
    
                /**
                 * AnyValue nullArray.
                 * @member {esriPBuffer.graph.INullArray|null|undefined} nullArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.nullArray = null;
    
                /**
                 * AnyValue uuidArray.
                 * @member {Uint8Array|null|undefined} uuidArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.uuidArray = null;
    
                /**
                 * AnyValue dateArray.
                 * @member {esriPBuffer.graph.IDateTimeArray|null|undefined} dateArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.dateArray = null;
    
                /**
                 * AnyValue stringArray.
                 * @member {esriPBuffer.graph.IStringArray|null|undefined} stringArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.stringArray = null;
    
                /**
                 * AnyValue geometryArray.
                 * @member {esriPBuffer.graph.IGeometryArray|null|undefined} geometryArray
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                AnyValue.prototype.geometryArray = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * AnyValue anyValueType.
                 * @member {"primitiveValue"|"arrayValue"|"objectValue"|"entityValue"|"relationshipValue"|"pathValue"|"floatArray"|"floatCompressedAsInt32Array"|"doubleArray"|"doubleCompressedAsFloatArray"|"doubleCompressedAsInt64Array"|"sint64Array"|"boolArray"|"nullArray"|"uuidArray"|"dateArray"|"stringArray"|"geometryArray"|undefined} anyValueType
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 */
                Object.defineProperty(AnyValue.prototype, "anyValueType", {
                    get: $util.oneOfGetter($oneOfFields = ["primitiveValue", "arrayValue", "objectValue", "entityValue", "relationshipValue", "pathValue", "floatArray", "floatCompressedAsInt32Array", "doubleArray", "doubleCompressedAsFloatArray", "doubleCompressedAsInt64Array", "sint64Array", "boolArray", "nullArray", "uuidArray", "dateArray", "stringArray", "geometryArray"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new AnyValue instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {esriPBuffer.graph.IAnyValue=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.AnyValue} AnyValue instance
                 */
                AnyValue.create = function create(properties) {
                    return new AnyValue(properties);
                };
    
                /**
                 * Encodes the specified AnyValue message. Does not implicitly {@link esriPBuffer.graph.AnyValue.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {esriPBuffer.graph.IAnyValue} message AnyValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AnyValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.primitiveValue != null && Object.hasOwnProperty.call(message, "primitiveValue"))
                        $root.esriPBuffer.graph.PrimitiveValue.encode(message.primitiveValue, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.arrayValue != null && Object.hasOwnProperty.call(message, "arrayValue"))
                        $root.esriPBuffer.graph.ArrayValue.encode(message.arrayValue, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.objectValue != null && Object.hasOwnProperty.call(message, "objectValue"))
                        $root.esriPBuffer.graph.ObjectValue.encode(message.objectValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.entityValue != null && Object.hasOwnProperty.call(message, "entityValue"))
                        $root.esriPBuffer.graph.EntityValue.encode(message.entityValue, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.relationshipValue != null && Object.hasOwnProperty.call(message, "relationshipValue"))
                        $root.esriPBuffer.graph.RelationshipValue.encode(message.relationshipValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.pathValue != null && Object.hasOwnProperty.call(message, "pathValue"))
                        $root.esriPBuffer.graph.PathValue.encode(message.pathValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.floatArray != null && Object.hasOwnProperty.call(message, "floatArray"))
                        $root.esriPBuffer.graph.FloatArray.encode(message.floatArray, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.floatCompressedAsInt32Array != null && Object.hasOwnProperty.call(message, "floatCompressedAsInt32Array"))
                        $root.esriPBuffer.graph.Int32Array.encode(message.floatCompressedAsInt32Array, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    if (message.doubleArray != null && Object.hasOwnProperty.call(message, "doubleArray"))
                        $root.esriPBuffer.graph.DoubleArray.encode(message.doubleArray, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                    if (message.doubleCompressedAsFloatArray != null && Object.hasOwnProperty.call(message, "doubleCompressedAsFloatArray"))
                        $root.esriPBuffer.graph.FloatArray.encode(message.doubleCompressedAsFloatArray, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.doubleCompressedAsInt64Array != null && Object.hasOwnProperty.call(message, "doubleCompressedAsInt64Array"))
                        $root.esriPBuffer.graph.Int64Array.encode(message.doubleCompressedAsInt64Array, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.sint64Array != null && Object.hasOwnProperty.call(message, "sint64Array"))
                        $root.esriPBuffer.graph.Int64Array.encode(message.sint64Array, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.boolArray != null && Object.hasOwnProperty.call(message, "boolArray"))
                        $root.esriPBuffer.graph.BoolArray.encode(message.boolArray, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                    if (message.nullArray != null && Object.hasOwnProperty.call(message, "nullArray"))
                        $root.esriPBuffer.graph.NullArray.encode(message.nullArray, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.uuidArray != null && Object.hasOwnProperty.call(message, "uuidArray"))
                        writer.uint32(/* id 15, wireType 2 =*/122).bytes(message.uuidArray);
                    if (message.stringArray != null && Object.hasOwnProperty.call(message, "stringArray"))
                        $root.esriPBuffer.graph.StringArray.encode(message.stringArray, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.geometryArray != null && Object.hasOwnProperty.call(message, "geometryArray"))
                        $root.esriPBuffer.graph.GeometryArray.encode(message.geometryArray, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    if (message.dateArray != null && Object.hasOwnProperty.call(message, "dateArray"))
                        $root.esriPBuffer.graph.DateTimeArray.encode(message.dateArray, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified AnyValue message, length delimited. Does not implicitly {@link esriPBuffer.graph.AnyValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {esriPBuffer.graph.IAnyValue} message AnyValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AnyValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an AnyValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.AnyValue} AnyValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AnyValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.AnyValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.primitiveValue = $root.esriPBuffer.graph.PrimitiveValue.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.arrayValue = $root.esriPBuffer.graph.ArrayValue.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.objectValue = $root.esriPBuffer.graph.ObjectValue.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.entityValue = $root.esriPBuffer.graph.EntityValue.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.relationshipValue = $root.esriPBuffer.graph.RelationshipValue.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.pathValue = $root.esriPBuffer.graph.PathValue.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.floatArray = $root.esriPBuffer.graph.FloatArray.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.floatCompressedAsInt32Array = $root.esriPBuffer.graph.Int32Array.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.doubleArray = $root.esriPBuffer.graph.DoubleArray.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.doubleCompressedAsFloatArray = $root.esriPBuffer.graph.FloatArray.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.doubleCompressedAsInt64Array = $root.esriPBuffer.graph.Int64Array.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.sint64Array = $root.esriPBuffer.graph.Int64Array.decode(reader, reader.uint32());
                            break;
                        case 13:
                            message.boolArray = $root.esriPBuffer.graph.BoolArray.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.nullArray = $root.esriPBuffer.graph.NullArray.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.uuidArray = reader.bytes();
                            break;
                        case 19:
                            message.dateArray = $root.esriPBuffer.graph.DateTimeArray.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.stringArray = $root.esriPBuffer.graph.StringArray.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.geometryArray = $root.esriPBuffer.graph.GeometryArray.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an AnyValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.AnyValue} AnyValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AnyValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an AnyValue message.
                 * @function verify
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AnyValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.primitiveValue != null && message.hasOwnProperty("primitiveValue")) {
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.PrimitiveValue.verify(message.primitiveValue);
                            if (error)
                                return "primitiveValue." + error;
                        }
                    }
                    if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.ArrayValue.verify(message.arrayValue);
                            if (error)
                                return "arrayValue." + error;
                        }
                    }
                    if (message.objectValue != null && message.hasOwnProperty("objectValue")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.ObjectValue.verify(message.objectValue);
                            if (error)
                                return "objectValue." + error;
                        }
                    }
                    if (message.entityValue != null && message.hasOwnProperty("entityValue")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.EntityValue.verify(message.entityValue);
                            if (error)
                                return "entityValue." + error;
                        }
                    }
                    if (message.relationshipValue != null && message.hasOwnProperty("relationshipValue")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.RelationshipValue.verify(message.relationshipValue);
                            if (error)
                                return "relationshipValue." + error;
                        }
                    }
                    if (message.pathValue != null && message.hasOwnProperty("pathValue")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.PathValue.verify(message.pathValue);
                            if (error)
                                return "pathValue." + error;
                        }
                    }
                    if (message.floatArray != null && message.hasOwnProperty("floatArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.FloatArray.verify(message.floatArray);
                            if (error)
                                return "floatArray." + error;
                        }
                    }
                    if (message.floatCompressedAsInt32Array != null && message.hasOwnProperty("floatCompressedAsInt32Array")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.Int32Array.verify(message.floatCompressedAsInt32Array);
                            if (error)
                                return "floatCompressedAsInt32Array." + error;
                        }
                    }
                    if (message.doubleArray != null && message.hasOwnProperty("doubleArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.DoubleArray.verify(message.doubleArray);
                            if (error)
                                return "doubleArray." + error;
                        }
                    }
                    if (message.doubleCompressedAsFloatArray != null && message.hasOwnProperty("doubleCompressedAsFloatArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.FloatArray.verify(message.doubleCompressedAsFloatArray);
                            if (error)
                                return "doubleCompressedAsFloatArray." + error;
                        }
                    }
                    if (message.doubleCompressedAsInt64Array != null && message.hasOwnProperty("doubleCompressedAsInt64Array")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.Int64Array.verify(message.doubleCompressedAsInt64Array);
                            if (error)
                                return "doubleCompressedAsInt64Array." + error;
                        }
                    }
                    if (message.sint64Array != null && message.hasOwnProperty("sint64Array")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.Int64Array.verify(message.sint64Array);
                            if (error)
                                return "sint64Array." + error;
                        }
                    }
                    if (message.boolArray != null && message.hasOwnProperty("boolArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.BoolArray.verify(message.boolArray);
                            if (error)
                                return "boolArray." + error;
                        }
                    }
                    if (message.nullArray != null && message.hasOwnProperty("nullArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.NullArray.verify(message.nullArray);
                            if (error)
                                return "nullArray." + error;
                        }
                    }
                    if (message.uuidArray != null && message.hasOwnProperty("uuidArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        if (!(message.uuidArray && typeof message.uuidArray.length === "number" || $util.isString(message.uuidArray)))
                            return "uuidArray: buffer expected";
                    }
                    if (message.dateArray != null && message.hasOwnProperty("dateArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.DateTimeArray.verify(message.dateArray);
                            if (error)
                                return "dateArray." + error;
                        }
                    }
                    if (message.stringArray != null && message.hasOwnProperty("stringArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.StringArray.verify(message.stringArray);
                            if (error)
                                return "stringArray." + error;
                        }
                    }
                    if (message.geometryArray != null && message.hasOwnProperty("geometryArray")) {
                        if (properties.anyValueType === 1)
                            return "anyValueType: multiple values";
                        properties.anyValueType = 1;
                        {
                            var error = $root.esriPBuffer.graph.GeometryArray.verify(message.geometryArray);
                            if (error)
                                return "geometryArray." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an AnyValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.AnyValue} AnyValue
                 */
                AnyValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.AnyValue)
                        return object;
                    var message = new $root.esriPBuffer.graph.AnyValue();
                    if (object.primitiveValue != null) {
                        if (typeof object.primitiveValue !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.primitiveValue: object expected");
                        message.primitiveValue = $root.esriPBuffer.graph.PrimitiveValue.fromObject(object.primitiveValue);
                    }
                    if (object.arrayValue != null) {
                        if (typeof object.arrayValue !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.arrayValue: object expected");
                        message.arrayValue = $root.esriPBuffer.graph.ArrayValue.fromObject(object.arrayValue);
                    }
                    if (object.objectValue != null) {
                        if (typeof object.objectValue !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.objectValue: object expected");
                        message.objectValue = $root.esriPBuffer.graph.ObjectValue.fromObject(object.objectValue);
                    }
                    if (object.entityValue != null) {
                        if (typeof object.entityValue !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.entityValue: object expected");
                        message.entityValue = $root.esriPBuffer.graph.EntityValue.fromObject(object.entityValue);
                    }
                    if (object.relationshipValue != null) {
                        if (typeof object.relationshipValue !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.relationshipValue: object expected");
                        message.relationshipValue = $root.esriPBuffer.graph.RelationshipValue.fromObject(object.relationshipValue);
                    }
                    if (object.pathValue != null) {
                        if (typeof object.pathValue !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.pathValue: object expected");
                        message.pathValue = $root.esriPBuffer.graph.PathValue.fromObject(object.pathValue);
                    }
                    if (object.floatArray != null) {
                        if (typeof object.floatArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.floatArray: object expected");
                        message.floatArray = $root.esriPBuffer.graph.FloatArray.fromObject(object.floatArray);
                    }
                    if (object.floatCompressedAsInt32Array != null) {
                        if (typeof object.floatCompressedAsInt32Array !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.floatCompressedAsInt32Array: object expected");
                        message.floatCompressedAsInt32Array = $root.esriPBuffer.graph.Int32Array.fromObject(object.floatCompressedAsInt32Array);
                    }
                    if (object.doubleArray != null) {
                        if (typeof object.doubleArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.doubleArray: object expected");
                        message.doubleArray = $root.esriPBuffer.graph.DoubleArray.fromObject(object.doubleArray);
                    }
                    if (object.doubleCompressedAsFloatArray != null) {
                        if (typeof object.doubleCompressedAsFloatArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.doubleCompressedAsFloatArray: object expected");
                        message.doubleCompressedAsFloatArray = $root.esriPBuffer.graph.FloatArray.fromObject(object.doubleCompressedAsFloatArray);
                    }
                    if (object.doubleCompressedAsInt64Array != null) {
                        if (typeof object.doubleCompressedAsInt64Array !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.doubleCompressedAsInt64Array: object expected");
                        message.doubleCompressedAsInt64Array = $root.esriPBuffer.graph.Int64Array.fromObject(object.doubleCompressedAsInt64Array);
                    }
                    if (object.sint64Array != null) {
                        if (typeof object.sint64Array !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.sint64Array: object expected");
                        message.sint64Array = $root.esriPBuffer.graph.Int64Array.fromObject(object.sint64Array);
                    }
                    if (object.boolArray != null) {
                        if (typeof object.boolArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.boolArray: object expected");
                        message.boolArray = $root.esriPBuffer.graph.BoolArray.fromObject(object.boolArray);
                    }
                    if (object.nullArray != null) {
                        if (typeof object.nullArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.nullArray: object expected");
                        message.nullArray = $root.esriPBuffer.graph.NullArray.fromObject(object.nullArray);
                    }
                    if (object.uuidArray != null)
                        if (typeof object.uuidArray === "string")
                            $util.base64.decode(object.uuidArray, message.uuidArray = $util.newBuffer($util.base64.length(object.uuidArray)), 0);
                        else if (object.uuidArray.length)
                            message.uuidArray = object.uuidArray;
                    if (object.dateArray != null) {
                        if (typeof object.dateArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.dateArray: object expected");
                        message.dateArray = $root.esriPBuffer.graph.DateTimeArray.fromObject(object.dateArray);
                    }
                    if (object.stringArray != null) {
                        if (typeof object.stringArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.stringArray: object expected");
                        message.stringArray = $root.esriPBuffer.graph.StringArray.fromObject(object.stringArray);
                    }
                    if (object.geometryArray != null) {
                        if (typeof object.geometryArray !== "object")
                            throw TypeError(".esriPBuffer.graph.AnyValue.geometryArray: object expected");
                        message.geometryArray = $root.esriPBuffer.graph.GeometryArray.fromObject(object.geometryArray);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an AnyValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.AnyValue
                 * @static
                 * @param {esriPBuffer.graph.AnyValue} message AnyValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AnyValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.primitiveValue != null && message.hasOwnProperty("primitiveValue")) {
                        object.primitiveValue = $root.esriPBuffer.graph.PrimitiveValue.toObject(message.primitiveValue, options);
                        if (options.oneofs)
                            object.anyValueType = "primitiveValue";
                    }
                    if (message.arrayValue != null && message.hasOwnProperty("arrayValue")) {
                        object.arrayValue = $root.esriPBuffer.graph.ArrayValue.toObject(message.arrayValue, options);
                        if (options.oneofs)
                            object.anyValueType = "arrayValue";
                    }
                    if (message.objectValue != null && message.hasOwnProperty("objectValue")) {
                        object.objectValue = $root.esriPBuffer.graph.ObjectValue.toObject(message.objectValue, options);
                        if (options.oneofs)
                            object.anyValueType = "objectValue";
                    }
                    if (message.entityValue != null && message.hasOwnProperty("entityValue")) {
                        object.entityValue = $root.esriPBuffer.graph.EntityValue.toObject(message.entityValue, options);
                        if (options.oneofs)
                            object.anyValueType = "entityValue";
                    }
                    if (message.relationshipValue != null && message.hasOwnProperty("relationshipValue")) {
                        object.relationshipValue = $root.esriPBuffer.graph.RelationshipValue.toObject(message.relationshipValue, options);
                        if (options.oneofs)
                            object.anyValueType = "relationshipValue";
                    }
                    if (message.pathValue != null && message.hasOwnProperty("pathValue")) {
                        object.pathValue = $root.esriPBuffer.graph.PathValue.toObject(message.pathValue, options);
                        if (options.oneofs)
                            object.anyValueType = "pathValue";
                    }
                    if (message.floatArray != null && message.hasOwnProperty("floatArray")) {
                        object.floatArray = $root.esriPBuffer.graph.FloatArray.toObject(message.floatArray, options);
                        if (options.oneofs)
                            object.anyValueType = "floatArray";
                    }
                    if (message.floatCompressedAsInt32Array != null && message.hasOwnProperty("floatCompressedAsInt32Array")) {
                        object.floatCompressedAsInt32Array = $root.esriPBuffer.graph.Int32Array.toObject(message.floatCompressedAsInt32Array, options);
                        if (options.oneofs)
                            object.anyValueType = "floatCompressedAsInt32Array";
                    }
                    if (message.doubleArray != null && message.hasOwnProperty("doubleArray")) {
                        object.doubleArray = $root.esriPBuffer.graph.DoubleArray.toObject(message.doubleArray, options);
                        if (options.oneofs)
                            object.anyValueType = "doubleArray";
                    }
                    if (message.doubleCompressedAsFloatArray != null && message.hasOwnProperty("doubleCompressedAsFloatArray")) {
                        object.doubleCompressedAsFloatArray = $root.esriPBuffer.graph.FloatArray.toObject(message.doubleCompressedAsFloatArray, options);
                        if (options.oneofs)
                            object.anyValueType = "doubleCompressedAsFloatArray";
                    }
                    if (message.doubleCompressedAsInt64Array != null && message.hasOwnProperty("doubleCompressedAsInt64Array")) {
                        object.doubleCompressedAsInt64Array = $root.esriPBuffer.graph.Int64Array.toObject(message.doubleCompressedAsInt64Array, options);
                        if (options.oneofs)
                            object.anyValueType = "doubleCompressedAsInt64Array";
                    }
                    if (message.sint64Array != null && message.hasOwnProperty("sint64Array")) {
                        object.sint64Array = $root.esriPBuffer.graph.Int64Array.toObject(message.sint64Array, options);
                        if (options.oneofs)
                            object.anyValueType = "sint64Array";
                    }
                    if (message.boolArray != null && message.hasOwnProperty("boolArray")) {
                        object.boolArray = $root.esriPBuffer.graph.BoolArray.toObject(message.boolArray, options);
                        if (options.oneofs)
                            object.anyValueType = "boolArray";
                    }
                    if (message.nullArray != null && message.hasOwnProperty("nullArray")) {
                        object.nullArray = $root.esriPBuffer.graph.NullArray.toObject(message.nullArray, options);
                        if (options.oneofs)
                            object.anyValueType = "nullArray";
                    }
                    if (message.uuidArray != null && message.hasOwnProperty("uuidArray")) {
                        object.uuidArray = options.bytes === String ? $util.base64.encode(message.uuidArray, 0, message.uuidArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.uuidArray) : message.uuidArray;
                        if (options.oneofs)
                            object.anyValueType = "uuidArray";
                    }
                    if (message.stringArray != null && message.hasOwnProperty("stringArray")) {
                        object.stringArray = $root.esriPBuffer.graph.StringArray.toObject(message.stringArray, options);
                        if (options.oneofs)
                            object.anyValueType = "stringArray";
                    }
                    if (message.geometryArray != null && message.hasOwnProperty("geometryArray")) {
                        object.geometryArray = $root.esriPBuffer.graph.GeometryArray.toObject(message.geometryArray, options);
                        if (options.oneofs)
                            object.anyValueType = "geometryArray";
                    }
                    if (message.dateArray != null && message.hasOwnProperty("dateArray")) {
                        object.dateArray = $root.esriPBuffer.graph.DateTimeArray.toObject(message.dateArray, options);
                        if (options.oneofs)
                            object.anyValueType = "dateArray";
                    }
                    return object;
                };
    
                /**
                 * Converts this AnyValue to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.AnyValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AnyValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return AnyValue;
            })();
    
            graph.Error = (function() {
    
                /**
                 * Properties of an Error.
                 * @memberof esriPBuffer.graph
                 * @interface IError
                 * @property {number|Long|null} [errorCode] Error errorCode
                 * @property {string|null} [errorMessage] Error errorMessage
                 */
    
                /**
                 * Constructs a new Error.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an Error.
                 * @implements IError
                 * @constructor
                 * @param {esriPBuffer.graph.IError=} [properties] Properties to set
                 */
                function Error(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Error errorCode.
                 * @member {number|Long} errorCode
                 * @memberof esriPBuffer.graph.Error
                 * @instance
                 */
                Error.prototype.errorCode = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Error errorMessage.
                 * @member {string} errorMessage
                 * @memberof esriPBuffer.graph.Error
                 * @instance
                 */
                Error.prototype.errorMessage = "";
    
                /**
                 * Creates a new Error instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {esriPBuffer.graph.IError=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Error} Error instance
                 */
                Error.create = function create(properties) {
                    return new Error(properties);
                };
    
                /**
                 * Encodes the specified Error message. Does not implicitly {@link esriPBuffer.graph.Error.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {esriPBuffer.graph.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.errorCode != null && Object.hasOwnProperty.call(message, "errorCode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.errorCode);
                    if (message.errorMessage != null && Object.hasOwnProperty.call(message, "errorMessage"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.errorMessage);
                    return writer;
                };
    
                /**
                 * Encodes the specified Error message, length delimited. Does not implicitly {@link esriPBuffer.graph.Error.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {esriPBuffer.graph.IError} message Error message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Error.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Error message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Error();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.errorCode = reader.sint64();
                            break;
                        case 2:
                            message.errorMessage = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Error message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Error} Error
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Error.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Error message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Error.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                        if (!$util.isInteger(message.errorCode) && !(message.errorCode && $util.isInteger(message.errorCode.low) && $util.isInteger(message.errorCode.high)))
                            return "errorCode: integer|Long expected";
                    if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                        if (!$util.isString(message.errorMessage))
                            return "errorMessage: string expected";
                    return null;
                };
    
                /**
                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Error} Error
                 */
                Error.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Error)
                        return object;
                    var message = new $root.esriPBuffer.graph.Error();
                    if (object.errorCode != null)
                        if ($util.Long)
                            (message.errorCode = $util.Long.fromValue(object.errorCode)).unsigned = false;
                        else if (typeof object.errorCode === "string")
                            message.errorCode = parseInt(object.errorCode, 10);
                        else if (typeof object.errorCode === "number")
                            message.errorCode = object.errorCode;
                        else if (typeof object.errorCode === "object")
                            message.errorCode = new $util.LongBits(object.errorCode.low >>> 0, object.errorCode.high >>> 0).toNumber();
                    if (object.errorMessage != null)
                        message.errorMessage = String(object.errorMessage);
                    return message;
                };
    
                /**
                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Error
                 * @static
                 * @param {esriPBuffer.graph.Error} message Error
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Error.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.errorCode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.errorCode = options.longs === String ? "0" : 0;
                        object.errorMessage = "";
                    }
                    if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                        if (typeof message.errorCode === "number")
                            object.errorCode = options.longs === String ? String(message.errorCode) : message.errorCode;
                        else
                            object.errorCode = options.longs === String ? $util.Long.prototype.toString.call(message.errorCode) : options.longs === Number ? new $util.LongBits(message.errorCode.low >>> 0, message.errorCode.high >>> 0).toNumber() : message.errorCode;
                    if (message.errorMessage != null && message.hasOwnProperty("errorMessage"))
                        object.errorMessage = message.errorMessage;
                    return object;
                };
    
                /**
                 * Converts this Error to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Error
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Error.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Error;
            })();
    
            graph.GraphPropertyAddsRequest = (function() {
    
                /**
                 * Properties of a GraphPropertyAddsRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyAddsRequest
                 * @property {Array.<esriPBuffer.graph.IGraphProperty>|null} [graphProperties] GraphPropertyAddsRequest graphProperties
                 */
    
                /**
                 * Constructs a new GraphPropertyAddsRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyAddsRequest.
                 * @implements IGraphPropertyAddsRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyAddsRequest=} [properties] Properties to set
                 */
                function GraphPropertyAddsRequest(properties) {
                    this.graphProperties = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyAddsRequest graphProperties.
                 * @member {Array.<esriPBuffer.graph.IGraphProperty>} graphProperties
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @instance
                 */
                GraphPropertyAddsRequest.prototype.graphProperties = $util.emptyArray;
    
                /**
                 * Creates a new GraphPropertyAddsRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddsRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyAddsRequest} GraphPropertyAddsRequest instance
                 */
                GraphPropertyAddsRequest.create = function create(properties) {
                    return new GraphPropertyAddsRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyAddsRequest message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyAddsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddsRequest} message GraphPropertyAddsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyAddsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.graphProperties != null && message.graphProperties.length)
                        for (var i = 0; i < message.graphProperties.length; ++i)
                            $root.esriPBuffer.graph.GraphProperty.encode(message.graphProperties[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyAddsRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyAddsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddsRequest} message GraphPropertyAddsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyAddsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyAddsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyAddsRequest} GraphPropertyAddsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyAddsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyAddsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.graphProperties && message.graphProperties.length))
                                message.graphProperties = [];
                            message.graphProperties.push($root.esriPBuffer.graph.GraphProperty.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyAddsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyAddsRequest} GraphPropertyAddsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyAddsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyAddsRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyAddsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.graphProperties != null && message.hasOwnProperty("graphProperties")) {
                        if (!Array.isArray(message.graphProperties))
                            return "graphProperties: array expected";
                        for (var i = 0; i < message.graphProperties.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphProperty.verify(message.graphProperties[i]);
                            if (error)
                                return "graphProperties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyAddsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyAddsRequest} GraphPropertyAddsRequest
                 */
                GraphPropertyAddsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyAddsRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyAddsRequest();
                    if (object.graphProperties) {
                        if (!Array.isArray(object.graphProperties))
                            throw TypeError(".esriPBuffer.graph.GraphPropertyAddsRequest.graphProperties: array expected");
                        message.graphProperties = [];
                        for (var i = 0; i < object.graphProperties.length; ++i) {
                            if (typeof object.graphProperties[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphPropertyAddsRequest.graphProperties: object expected");
                            message.graphProperties[i] = $root.esriPBuffer.graph.GraphProperty.fromObject(object.graphProperties[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyAddsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyAddsRequest} message GraphPropertyAddsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyAddsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.graphProperties = [];
                    if (message.graphProperties && message.graphProperties.length) {
                        object.graphProperties = [];
                        for (var j = 0; j < message.graphProperties.length; ++j)
                            object.graphProperties[j] = $root.esriPBuffer.graph.GraphProperty.toObject(message.graphProperties[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyAddsRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyAddsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyAddsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyAddsRequest;
            })();
    
            /**
             * esriGraphNamedObjectRole enum.
             * @name esriPBuffer.graph.esriGraphNamedObjectRole
             * @enum {number}
             * @property {number} esriGraphNamedObjectRegular=0 esriGraphNamedObjectRegular value
             * @property {number} esriGraphNamedObjectProvenance=1 esriGraphNamedObjectProvenance value
             * @property {number} esriGraphNamedObjectDocument=2 esriGraphNamedObjectDocument value
             */
            graph.esriGraphNamedObjectRole = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "esriGraphNamedObjectRegular"] = 0;
                values[valuesById[1] = "esriGraphNamedObjectProvenance"] = 1;
                values[valuesById[2] = "esriGraphNamedObjectDocument"] = 2;
                return values;
            })();
    
            graph.NamedObjectType = (function() {
    
                /**
                 * Properties of a NamedObjectType.
                 * @memberof esriPBuffer.graph
                 * @interface INamedObjectType
                 * @property {string|null} [name] NamedObjectType name
                 * @property {string|null} [alias] NamedObjectType alias
                 * @property {esriPBuffer.graph.esriGraphNamedObjectRole|null} [role] NamedObjectType role
                 * @property {Array.<esriPBuffer.graph.IGraphProperty>|null} [properties] NamedObjectType properties
                 * @property {Array.<esriPBuffer.EsriTypes.IFieldIndex>|null} [fieldIndexes] NamedObjectType fieldIndexes
                 * @property {boolean|null} [strict] NamedObjectType strict
                 */
    
                /**
                 * Constructs a new NamedObjectType.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NamedObjectType.
                 * @implements INamedObjectType
                 * @constructor
                 * @param {esriPBuffer.graph.INamedObjectType=} [properties] Properties to set
                 */
                function NamedObjectType(properties) {
                    this.properties = [];
                    this.fieldIndexes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedObjectType name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 */
                NamedObjectType.prototype.name = "";
    
                /**
                 * NamedObjectType alias.
                 * @member {string} alias
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 */
                NamedObjectType.prototype.alias = "";
    
                /**
                 * NamedObjectType role.
                 * @member {esriPBuffer.graph.esriGraphNamedObjectRole} role
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 */
                NamedObjectType.prototype.role = 0;
    
                /**
                 * NamedObjectType properties.
                 * @member {Array.<esriPBuffer.graph.IGraphProperty>} properties
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 */
                NamedObjectType.prototype.properties = $util.emptyArray;
    
                /**
                 * NamedObjectType fieldIndexes.
                 * @member {Array.<esriPBuffer.EsriTypes.IFieldIndex>} fieldIndexes
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 */
                NamedObjectType.prototype.fieldIndexes = $util.emptyArray;
    
                /**
                 * NamedObjectType strict.
                 * @member {boolean} strict
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 */
                NamedObjectType.prototype.strict = false;
    
                /**
                 * Creates a new NamedObjectType instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectType=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NamedObjectType} NamedObjectType instance
                 */
                NamedObjectType.create = function create(properties) {
                    return new NamedObjectType(properties);
                };
    
                /**
                 * Encodes the specified NamedObjectType message. Does not implicitly {@link esriPBuffer.graph.NamedObjectType.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectType} message NamedObjectType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
                    if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.role);
                    if (message.properties != null && message.properties.length)
                        for (var i = 0; i < message.properties.length; ++i)
                            $root.esriPBuffer.graph.GraphProperty.encode(message.properties[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.fieldIndexes != null && message.fieldIndexes.length)
                        for (var i = 0; i < message.fieldIndexes.length; ++i)
                            $root.esriPBuffer.EsriTypes.FieldIndex.encode(message.fieldIndexes[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.strict != null && Object.hasOwnProperty.call(message, "strict"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.strict);
                    return writer;
                };
    
                /**
                 * Encodes the specified NamedObjectType message, length delimited. Does not implicitly {@link esriPBuffer.graph.NamedObjectType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectType} message NamedObjectType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NamedObjectType message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NamedObjectType} NamedObjectType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NamedObjectType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.alias = reader.string();
                            break;
                        case 4:
                            message.role = reader.int32();
                            break;
                        case 5:
                            if (!(message.properties && message.properties.length))
                                message.properties = [];
                            message.properties.push($root.esriPBuffer.graph.GraphProperty.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.fieldIndexes && message.fieldIndexes.length))
                                message.fieldIndexes = [];
                            message.fieldIndexes.push($root.esriPBuffer.EsriTypes.FieldIndex.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.strict = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NamedObjectType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NamedObjectType} NamedObjectType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NamedObjectType message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedObjectType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.alias != null && message.hasOwnProperty("alias"))
                        if (!$util.isString(message.alias))
                            return "alias: string expected";
                    if (message.role != null && message.hasOwnProperty("role"))
                        switch (message.role) {
                        default:
                            return "role: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!Array.isArray(message.properties))
                            return "properties: array expected";
                        for (var i = 0; i < message.properties.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphProperty.verify(message.properties[i]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    if (message.fieldIndexes != null && message.hasOwnProperty("fieldIndexes")) {
                        if (!Array.isArray(message.fieldIndexes))
                            return "fieldIndexes: array expected";
                        for (var i = 0; i < message.fieldIndexes.length; ++i) {
                            var error = $root.esriPBuffer.EsriTypes.FieldIndex.verify(message.fieldIndexes[i]);
                            if (error)
                                return "fieldIndexes." + error;
                        }
                    }
                    if (message.strict != null && message.hasOwnProperty("strict"))
                        if (typeof message.strict !== "boolean")
                            return "strict: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a NamedObjectType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NamedObjectType} NamedObjectType
                 */
                NamedObjectType.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NamedObjectType)
                        return object;
                    var message = new $root.esriPBuffer.graph.NamedObjectType();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.alias != null)
                        message.alias = String(object.alias);
                    switch (object.role) {
                    case "esriGraphNamedObjectRegular":
                    case 0:
                        message.role = 0;
                        break;
                    case "esriGraphNamedObjectProvenance":
                    case 1:
                        message.role = 1;
                        break;
                    case "esriGraphNamedObjectDocument":
                    case 2:
                        message.role = 2;
                        break;
                    }
                    if (object.properties) {
                        if (!Array.isArray(object.properties))
                            throw TypeError(".esriPBuffer.graph.NamedObjectType.properties: array expected");
                        message.properties = [];
                        for (var i = 0; i < object.properties.length; ++i) {
                            if (typeof object.properties[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.NamedObjectType.properties: object expected");
                            message.properties[i] = $root.esriPBuffer.graph.GraphProperty.fromObject(object.properties[i]);
                        }
                    }
                    if (object.fieldIndexes) {
                        if (!Array.isArray(object.fieldIndexes))
                            throw TypeError(".esriPBuffer.graph.NamedObjectType.fieldIndexes: array expected");
                        message.fieldIndexes = [];
                        for (var i = 0; i < object.fieldIndexes.length; ++i) {
                            if (typeof object.fieldIndexes[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.NamedObjectType.fieldIndexes: object expected");
                            message.fieldIndexes[i] = $root.esriPBuffer.EsriTypes.FieldIndex.fromObject(object.fieldIndexes[i]);
                        }
                    }
                    if (object.strict != null)
                        message.strict = Boolean(object.strict);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NamedObjectType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @static
                 * @param {esriPBuffer.graph.NamedObjectType} message NamedObjectType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedObjectType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.properties = [];
                        object.fieldIndexes = [];
                    }
                    if (options.defaults) {
                        object.name = "";
                        object.alias = "";
                        object.role = options.enums === String ? "esriGraphNamedObjectRegular" : 0;
                        object.strict = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.alias != null && message.hasOwnProperty("alias"))
                        object.alias = message.alias;
                    if (message.role != null && message.hasOwnProperty("role"))
                        object.role = options.enums === String ? $root.esriPBuffer.graph.esriGraphNamedObjectRole[message.role] : message.role;
                    if (message.properties && message.properties.length) {
                        object.properties = [];
                        for (var j = 0; j < message.properties.length; ++j)
                            object.properties[j] = $root.esriPBuffer.graph.GraphProperty.toObject(message.properties[j], options);
                    }
                    if (message.fieldIndexes && message.fieldIndexes.length) {
                        object.fieldIndexes = [];
                        for (var j = 0; j < message.fieldIndexes.length; ++j)
                            object.fieldIndexes[j] = $root.esriPBuffer.EsriTypes.FieldIndex.toObject(message.fieldIndexes[j], options);
                    }
                    if (message.strict != null && message.hasOwnProperty("strict"))
                        object.strict = message.strict;
                    return object;
                };
    
                /**
                 * Converts this NamedObjectType to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NamedObjectType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedObjectType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NamedObjectType;
            })();
    
            graph.EntityType = (function() {
    
                /**
                 * Properties of an EntityType.
                 * @memberof esriPBuffer.graph
                 * @interface IEntityType
                 * @property {esriPBuffer.graph.INamedObjectType|null} [entity] EntityType entity
                 */
    
                /**
                 * Constructs a new EntityType.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an EntityType.
                 * @implements IEntityType
                 * @constructor
                 * @param {esriPBuffer.graph.IEntityType=} [properties] Properties to set
                 */
                function EntityType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EntityType entity.
                 * @member {esriPBuffer.graph.INamedObjectType|null|undefined} entity
                 * @memberof esriPBuffer.graph.EntityType
                 * @instance
                 */
                EntityType.prototype.entity = null;
    
                /**
                 * Creates a new EntityType instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {esriPBuffer.graph.IEntityType=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.EntityType} EntityType instance
                 */
                EntityType.create = function create(properties) {
                    return new EntityType(properties);
                };
    
                /**
                 * Encodes the specified EntityType message. Does not implicitly {@link esriPBuffer.graph.EntityType.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {esriPBuffer.graph.IEntityType} message EntityType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EntityType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entity != null && Object.hasOwnProperty.call(message, "entity"))
                        $root.esriPBuffer.graph.NamedObjectType.encode(message.entity, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EntityType message, length delimited. Does not implicitly {@link esriPBuffer.graph.EntityType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {esriPBuffer.graph.IEntityType} message EntityType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EntityType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EntityType message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.EntityType} EntityType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EntityType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.EntityType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.entity = $root.esriPBuffer.graph.NamedObjectType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EntityType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.EntityType} EntityType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EntityType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EntityType message.
                 * @function verify
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EntityType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entity != null && message.hasOwnProperty("entity")) {
                        var error = $root.esriPBuffer.graph.NamedObjectType.verify(message.entity);
                        if (error)
                            return "entity." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EntityType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.EntityType} EntityType
                 */
                EntityType.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.EntityType)
                        return object;
                    var message = new $root.esriPBuffer.graph.EntityType();
                    if (object.entity != null) {
                        if (typeof object.entity !== "object")
                            throw TypeError(".esriPBuffer.graph.EntityType.entity: object expected");
                        message.entity = $root.esriPBuffer.graph.NamedObjectType.fromObject(object.entity);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EntityType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.EntityType
                 * @static
                 * @param {esriPBuffer.graph.EntityType} message EntityType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EntityType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.entity = null;
                    if (message.entity != null && message.hasOwnProperty("entity"))
                        object.entity = $root.esriPBuffer.graph.NamedObjectType.toObject(message.entity, options);
                    return object;
                };
    
                /**
                 * Converts this EntityType to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.EntityType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EntityType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EntityType;
            })();
    
            graph.RelationshipType = (function() {
    
                /**
                 * Properties of a RelationshipType.
                 * @memberof esriPBuffer.graph
                 * @interface IRelationshipType
                 * @property {Array.<string>|null} [originEntityTypes] RelationshipType originEntityTypes
                 * @property {Array.<string>|null} [destEntityTypes] RelationshipType destEntityTypes
                 * @property {esriPBuffer.graph.INamedObjectType|null} [relationship] RelationshipType relationship
                 * @property {boolean|null} [strictOrigin] RelationshipType strictOrigin
                 * @property {boolean|null} [strictDest] RelationshipType strictDest
                 */
    
                /**
                 * Constructs a new RelationshipType.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a RelationshipType.
                 * @implements IRelationshipType
                 * @constructor
                 * @param {esriPBuffer.graph.IRelationshipType=} [properties] Properties to set
                 */
                function RelationshipType(properties) {
                    this.originEntityTypes = [];
                    this.destEntityTypes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RelationshipType originEntityTypes.
                 * @member {Array.<string>} originEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @instance
                 */
                RelationshipType.prototype.originEntityTypes = $util.emptyArray;
    
                /**
                 * RelationshipType destEntityTypes.
                 * @member {Array.<string>} destEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @instance
                 */
                RelationshipType.prototype.destEntityTypes = $util.emptyArray;
    
                /**
                 * RelationshipType relationship.
                 * @member {esriPBuffer.graph.INamedObjectType|null|undefined} relationship
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @instance
                 */
                RelationshipType.prototype.relationship = null;
    
                /**
                 * RelationshipType strictOrigin.
                 * @member {boolean} strictOrigin
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @instance
                 */
                RelationshipType.prototype.strictOrigin = false;
    
                /**
                 * RelationshipType strictDest.
                 * @member {boolean} strictDest
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @instance
                 */
                RelationshipType.prototype.strictDest = false;
    
                /**
                 * Creates a new RelationshipType instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipType=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.RelationshipType} RelationshipType instance
                 */
                RelationshipType.create = function create(properties) {
                    return new RelationshipType(properties);
                };
    
                /**
                 * Encodes the specified RelationshipType message. Does not implicitly {@link esriPBuffer.graph.RelationshipType.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipType} message RelationshipType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.originEntityTypes != null && message.originEntityTypes.length)
                        for (var i = 0; i < message.originEntityTypes.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.originEntityTypes[i]);
                    if (message.destEntityTypes != null && message.destEntityTypes.length)
                        for (var i = 0; i < message.destEntityTypes.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.destEntityTypes[i]);
                    if (message.relationship != null && Object.hasOwnProperty.call(message, "relationship"))
                        $root.esriPBuffer.graph.NamedObjectType.encode(message.relationship, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.strictOrigin != null && Object.hasOwnProperty.call(message, "strictOrigin"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.strictOrigin);
                    if (message.strictDest != null && Object.hasOwnProperty.call(message, "strictDest"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.strictDest);
                    return writer;
                };
    
                /**
                 * Encodes the specified RelationshipType message, length delimited. Does not implicitly {@link esriPBuffer.graph.RelationshipType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipType} message RelationshipType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RelationshipType message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.RelationshipType} RelationshipType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.RelationshipType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.originEntityTypes && message.originEntityTypes.length))
                                message.originEntityTypes = [];
                            message.originEntityTypes.push(reader.string());
                            break;
                        case 2:
                            if (!(message.destEntityTypes && message.destEntityTypes.length))
                                message.destEntityTypes = [];
                            message.destEntityTypes.push(reader.string());
                            break;
                        case 3:
                            message.relationship = $root.esriPBuffer.graph.NamedObjectType.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.strictOrigin = reader.bool();
                            break;
                        case 5:
                            message.strictDest = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RelationshipType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.RelationshipType} RelationshipType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RelationshipType message.
                 * @function verify
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RelationshipType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originEntityTypes != null && message.hasOwnProperty("originEntityTypes")) {
                        if (!Array.isArray(message.originEntityTypes))
                            return "originEntityTypes: array expected";
                        for (var i = 0; i < message.originEntityTypes.length; ++i)
                            if (!$util.isString(message.originEntityTypes[i]))
                                return "originEntityTypes: string[] expected";
                    }
                    if (message.destEntityTypes != null && message.hasOwnProperty("destEntityTypes")) {
                        if (!Array.isArray(message.destEntityTypes))
                            return "destEntityTypes: array expected";
                        for (var i = 0; i < message.destEntityTypes.length; ++i)
                            if (!$util.isString(message.destEntityTypes[i]))
                                return "destEntityTypes: string[] expected";
                    }
                    if (message.relationship != null && message.hasOwnProperty("relationship")) {
                        var error = $root.esriPBuffer.graph.NamedObjectType.verify(message.relationship);
                        if (error)
                            return "relationship." + error;
                    }
                    if (message.strictOrigin != null && message.hasOwnProperty("strictOrigin"))
                        if (typeof message.strictOrigin !== "boolean")
                            return "strictOrigin: boolean expected";
                    if (message.strictDest != null && message.hasOwnProperty("strictDest"))
                        if (typeof message.strictDest !== "boolean")
                            return "strictDest: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a RelationshipType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.RelationshipType} RelationshipType
                 */
                RelationshipType.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.RelationshipType)
                        return object;
                    var message = new $root.esriPBuffer.graph.RelationshipType();
                    if (object.originEntityTypes) {
                        if (!Array.isArray(object.originEntityTypes))
                            throw TypeError(".esriPBuffer.graph.RelationshipType.originEntityTypes: array expected");
                        message.originEntityTypes = [];
                        for (var i = 0; i < object.originEntityTypes.length; ++i)
                            message.originEntityTypes[i] = String(object.originEntityTypes[i]);
                    }
                    if (object.destEntityTypes) {
                        if (!Array.isArray(object.destEntityTypes))
                            throw TypeError(".esriPBuffer.graph.RelationshipType.destEntityTypes: array expected");
                        message.destEntityTypes = [];
                        for (var i = 0; i < object.destEntityTypes.length; ++i)
                            message.destEntityTypes[i] = String(object.destEntityTypes[i]);
                    }
                    if (object.relationship != null) {
                        if (typeof object.relationship !== "object")
                            throw TypeError(".esriPBuffer.graph.RelationshipType.relationship: object expected");
                        message.relationship = $root.esriPBuffer.graph.NamedObjectType.fromObject(object.relationship);
                    }
                    if (object.strictOrigin != null)
                        message.strictOrigin = Boolean(object.strictOrigin);
                    if (object.strictDest != null)
                        message.strictDest = Boolean(object.strictDest);
                    return message;
                };
    
                /**
                 * Creates a plain object from a RelationshipType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @static
                 * @param {esriPBuffer.graph.RelationshipType} message RelationshipType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RelationshipType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.originEntityTypes = [];
                        object.destEntityTypes = [];
                    }
                    if (options.defaults) {
                        object.relationship = null;
                        object.strictOrigin = false;
                        object.strictDest = false;
                    }
                    if (message.originEntityTypes && message.originEntityTypes.length) {
                        object.originEntityTypes = [];
                        for (var j = 0; j < message.originEntityTypes.length; ++j)
                            object.originEntityTypes[j] = message.originEntityTypes[j];
                    }
                    if (message.destEntityTypes && message.destEntityTypes.length) {
                        object.destEntityTypes = [];
                        for (var j = 0; j < message.destEntityTypes.length; ++j)
                            object.destEntityTypes[j] = message.destEntityTypes[j];
                    }
                    if (message.relationship != null && message.hasOwnProperty("relationship"))
                        object.relationship = $root.esriPBuffer.graph.NamedObjectType.toObject(message.relationship, options);
                    if (message.strictOrigin != null && message.hasOwnProperty("strictOrigin"))
                        object.strictOrigin = message.strictOrigin;
                    if (message.strictDest != null && message.hasOwnProperty("strictDest"))
                        object.strictDest = message.strictDest;
                    return object;
                };
    
                /**
                 * Converts this RelationshipType to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.RelationshipType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RelationshipType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RelationshipType;
            })();
    
            graph.GraphProperty = (function() {
    
                /**
                 * Properties of a GraphProperty.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphProperty
                 * @property {string|null} [name] GraphProperty name
                 * @property {string|null} [alias] GraphProperty alias
                 * @property {esriPBuffer.EsriExtendedTypes.FieldType|null} [fieldType] GraphProperty fieldType
                 * @property {esriPBuffer.EsriTypes.GeometryType|null} [geometryType] GraphProperty geometryType
                 * @property {Array.<esriPBuffer.graph.IPrimitiveValue>|null} [defaultValue] GraphProperty defaultValue
                 * @property {boolean|null} [notNullable] GraphProperty notNullable
                 * @property {boolean|null} [notEditable] GraphProperty notEditable
                 * @property {boolean|null} [notVisible] GraphProperty notVisible
                 * @property {boolean|null} [required] GraphProperty required
                 * @property {boolean|null} [isSystemMaintained] GraphProperty isSystemMaintained
                 * @property {string|null} [domain] GraphProperty domain
                 * @property {boolean|null} [hasZ] GraphProperty hasZ
                 * @property {boolean|null} [hasM] GraphProperty hasM
                 * @property {boolean|null} [searchable] GraphProperty searchable
                 */
    
                /**
                 * Constructs a new GraphProperty.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphProperty.
                 * @implements IGraphProperty
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphProperty=} [properties] Properties to set
                 */
                function GraphProperty(properties) {
                    this.defaultValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphProperty name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.name = "";
    
                /**
                 * GraphProperty alias.
                 * @member {string} alias
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.alias = "";
    
                /**
                 * GraphProperty fieldType.
                 * @member {esriPBuffer.EsriExtendedTypes.FieldType} fieldType
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.fieldType = 0;
    
                /**
                 * GraphProperty geometryType.
                 * @member {esriPBuffer.EsriTypes.GeometryType} geometryType
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.geometryType = 0;
    
                /**
                 * GraphProperty defaultValue.
                 * @member {Array.<esriPBuffer.graph.IPrimitiveValue>} defaultValue
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.defaultValue = $util.emptyArray;
    
                /**
                 * GraphProperty notNullable.
                 * @member {boolean} notNullable
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.notNullable = false;
    
                /**
                 * GraphProperty notEditable.
                 * @member {boolean} notEditable
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.notEditable = false;
    
                /**
                 * GraphProperty notVisible.
                 * @member {boolean} notVisible
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.notVisible = false;
    
                /**
                 * GraphProperty required.
                 * @member {boolean} required
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.required = false;
    
                /**
                 * GraphProperty isSystemMaintained.
                 * @member {boolean} isSystemMaintained
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.isSystemMaintained = false;
    
                /**
                 * GraphProperty domain.
                 * @member {string} domain
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.domain = "";
    
                /**
                 * GraphProperty hasZ.
                 * @member {boolean} hasZ
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.hasZ = false;
    
                /**
                 * GraphProperty hasM.
                 * @member {boolean} hasM
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.hasM = false;
    
                /**
                 * GraphProperty searchable.
                 * @member {boolean} searchable
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 */
                GraphProperty.prototype.searchable = false;
    
                /**
                 * Creates a new GraphProperty instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {esriPBuffer.graph.IGraphProperty=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphProperty} GraphProperty instance
                 */
                GraphProperty.create = function create(properties) {
                    return new GraphProperty(properties);
                };
    
                /**
                 * Encodes the specified GraphProperty message. Does not implicitly {@link esriPBuffer.graph.GraphProperty.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {esriPBuffer.graph.IGraphProperty} message GraphProperty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphProperty.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.alias != null && Object.hasOwnProperty.call(message, "alias"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
                    if (message.fieldType != null && Object.hasOwnProperty.call(message, "fieldType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.fieldType);
                    if (message.geometryType != null && Object.hasOwnProperty.call(message, "geometryType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.geometryType);
                    if (message.defaultValue != null && message.defaultValue.length)
                        for (var i = 0; i < message.defaultValue.length; ++i)
                            $root.esriPBuffer.graph.PrimitiveValue.encode(message.defaultValue[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.notNullable != null && Object.hasOwnProperty.call(message, "notNullable"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.notNullable);
                    if (message.notEditable != null && Object.hasOwnProperty.call(message, "notEditable"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.notEditable);
                    if (message.notVisible != null && Object.hasOwnProperty.call(message, "notVisible"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.notVisible);
                    if (message.required != null && Object.hasOwnProperty.call(message, "required"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.required);
                    if (message.isSystemMaintained != null && Object.hasOwnProperty.call(message, "isSystemMaintained"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.isSystemMaintained);
                    if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.domain);
                    if (message.hasZ != null && Object.hasOwnProperty.call(message, "hasZ"))
                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.hasZ);
                    if (message.hasM != null && Object.hasOwnProperty.call(message, "hasM"))
                        writer.uint32(/* id 14, wireType 0 =*/112).bool(message.hasM);
                    if (message.searchable != null && Object.hasOwnProperty.call(message, "searchable"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.searchable);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphProperty message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphProperty.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {esriPBuffer.graph.IGraphProperty} message GraphProperty message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphProperty.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphProperty message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphProperty} GraphProperty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphProperty.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphProperty();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.alias = reader.string();
                            break;
                        case 3:
                            message.fieldType = reader.int32();
                            break;
                        case 4:
                            message.geometryType = reader.int32();
                            break;
                        case 5:
                            if (!(message.defaultValue && message.defaultValue.length))
                                message.defaultValue = [];
                            message.defaultValue.push($root.esriPBuffer.graph.PrimitiveValue.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.notNullable = reader.bool();
                            break;
                        case 7:
                            message.notEditable = reader.bool();
                            break;
                        case 8:
                            message.notVisible = reader.bool();
                            break;
                        case 9:
                            message.required = reader.bool();
                            break;
                        case 10:
                            message.isSystemMaintained = reader.bool();
                            break;
                        case 11:
                            message.domain = reader.string();
                            break;
                        case 13:
                            message.hasZ = reader.bool();
                            break;
                        case 14:
                            message.hasM = reader.bool();
                            break;
                        case 15:
                            message.searchable = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphProperty message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphProperty} GraphProperty
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphProperty.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphProperty message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphProperty.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.alias != null && message.hasOwnProperty("alias"))
                        if (!$util.isString(message.alias))
                            return "alias: string expected";
                    if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                        switch (message.fieldType) {
                        default:
                            return "fieldType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                        case 10:
                        case 11:
                        case 12:
                        case 13:
                            break;
                        }
                    if (message.geometryType != null && message.hasOwnProperty("geometryType"))
                        switch (message.geometryType) {
                        default:
                            return "geometryType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue")) {
                        if (!Array.isArray(message.defaultValue))
                            return "defaultValue: array expected";
                        for (var i = 0; i < message.defaultValue.length; ++i) {
                            var error = $root.esriPBuffer.graph.PrimitiveValue.verify(message.defaultValue[i]);
                            if (error)
                                return "defaultValue." + error;
                        }
                    }
                    if (message.notNullable != null && message.hasOwnProperty("notNullable"))
                        if (typeof message.notNullable !== "boolean")
                            return "notNullable: boolean expected";
                    if (message.notEditable != null && message.hasOwnProperty("notEditable"))
                        if (typeof message.notEditable !== "boolean")
                            return "notEditable: boolean expected";
                    if (message.notVisible != null && message.hasOwnProperty("notVisible"))
                        if (typeof message.notVisible !== "boolean")
                            return "notVisible: boolean expected";
                    if (message.required != null && message.hasOwnProperty("required"))
                        if (typeof message.required !== "boolean")
                            return "required: boolean expected";
                    if (message.isSystemMaintained != null && message.hasOwnProperty("isSystemMaintained"))
                        if (typeof message.isSystemMaintained !== "boolean")
                            return "isSystemMaintained: boolean expected";
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        if (!$util.isString(message.domain))
                            return "domain: string expected";
                    if (message.hasZ != null && message.hasOwnProperty("hasZ"))
                        if (typeof message.hasZ !== "boolean")
                            return "hasZ: boolean expected";
                    if (message.hasM != null && message.hasOwnProperty("hasM"))
                        if (typeof message.hasM !== "boolean")
                            return "hasM: boolean expected";
                    if (message.searchable != null && message.hasOwnProperty("searchable"))
                        if (typeof message.searchable !== "boolean")
                            return "searchable: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a GraphProperty message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphProperty} GraphProperty
                 */
                GraphProperty.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphProperty)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphProperty();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.alias != null)
                        message.alias = String(object.alias);
                    switch (object.fieldType) {
                    case "esriFieldType_UNSPECIFIED":
                    case 0:
                        message.fieldType = 0;
                        break;
                    case "esriFieldTypeSmallInteger":
                    case 1:
                        message.fieldType = 1;
                        break;
                    case "esriFieldTypeInteger":
                    case 2:
                        message.fieldType = 2;
                        break;
                    case "esriFieldTypeSingle":
                    case 3:
                        message.fieldType = 3;
                        break;
                    case "esriFieldTypeDouble":
                    case 4:
                        message.fieldType = 4;
                        break;
                    case "esriFieldTypeString":
                    case 5:
                        message.fieldType = 5;
                        break;
                    case "esriFieldTypeDate":
                    case 6:
                        message.fieldType = 6;
                        break;
                    case "esriFieldTypeOID":
                    case 7:
                        message.fieldType = 7;
                        break;
                    case "esriFieldTypeGeometry":
                    case 8:
                        message.fieldType = 8;
                        break;
                    case "esriFieldTypeBlob":
                    case 9:
                        message.fieldType = 9;
                        break;
                    case "esriFieldTypeRaster":
                    case 10:
                        message.fieldType = 10;
                        break;
                    case "esriFieldTypeGUID":
                    case 11:
                        message.fieldType = 11;
                        break;
                    case "esriFieldTypeGlobalID":
                    case 12:
                        message.fieldType = 12;
                        break;
                    case "esriFieldTypeXML":
                    case 13:
                        message.fieldType = 13;
                        break;
                    }
                    switch (object.geometryType) {
                    case "esriGeometryTypePoint":
                    case 0:
                        message.geometryType = 0;
                        break;
                    case "esriGeometryTypeMultipoint":
                    case 1:
                        message.geometryType = 1;
                        break;
                    case "esriGeometryTypePolyline":
                    case 2:
                        message.geometryType = 2;
                        break;
                    case "esriGeometryTypePolygon":
                    case 3:
                        message.geometryType = 3;
                        break;
                    case "esriGeometryTypeMultipatch":
                    case 4:
                        message.geometryType = 4;
                        break;
                    case "esriGeometryTypeEnvelope":
                    case 5:
                        message.geometryType = 5;
                        break;
                    }
                    if (object.defaultValue) {
                        if (!Array.isArray(object.defaultValue))
                            throw TypeError(".esriPBuffer.graph.GraphProperty.defaultValue: array expected");
                        message.defaultValue = [];
                        for (var i = 0; i < object.defaultValue.length; ++i) {
                            if (typeof object.defaultValue[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphProperty.defaultValue: object expected");
                            message.defaultValue[i] = $root.esriPBuffer.graph.PrimitiveValue.fromObject(object.defaultValue[i]);
                        }
                    }
                    if (object.notNullable != null)
                        message.notNullable = Boolean(object.notNullable);
                    if (object.notEditable != null)
                        message.notEditable = Boolean(object.notEditable);
                    if (object.notVisible != null)
                        message.notVisible = Boolean(object.notVisible);
                    if (object.required != null)
                        message.required = Boolean(object.required);
                    if (object.isSystemMaintained != null)
                        message.isSystemMaintained = Boolean(object.isSystemMaintained);
                    if (object.domain != null)
                        message.domain = String(object.domain);
                    if (object.hasZ != null)
                        message.hasZ = Boolean(object.hasZ);
                    if (object.hasM != null)
                        message.hasM = Boolean(object.hasM);
                    if (object.searchable != null)
                        message.searchable = Boolean(object.searchable);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphProperty message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @static
                 * @param {esriPBuffer.graph.GraphProperty} message GraphProperty
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphProperty.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.defaultValue = [];
                    if (options.defaults) {
                        object.name = "";
                        object.alias = "";
                        object.fieldType = options.enums === String ? "esriFieldType_UNSPECIFIED" : 0;
                        object.geometryType = options.enums === String ? "esriGeometryTypePoint" : 0;
                        object.notNullable = false;
                        object.notEditable = false;
                        object.notVisible = false;
                        object.required = false;
                        object.isSystemMaintained = false;
                        object.domain = "";
                        object.hasZ = false;
                        object.hasM = false;
                        object.searchable = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.alias != null && message.hasOwnProperty("alias"))
                        object.alias = message.alias;
                    if (message.fieldType != null && message.hasOwnProperty("fieldType"))
                        object.fieldType = options.enums === String ? $root.esriPBuffer.EsriExtendedTypes.FieldType[message.fieldType] : message.fieldType;
                    if (message.geometryType != null && message.hasOwnProperty("geometryType"))
                        object.geometryType = options.enums === String ? $root.esriPBuffer.EsriTypes.GeometryType[message.geometryType] : message.geometryType;
                    if (message.defaultValue && message.defaultValue.length) {
                        object.defaultValue = [];
                        for (var j = 0; j < message.defaultValue.length; ++j)
                            object.defaultValue[j] = $root.esriPBuffer.graph.PrimitiveValue.toObject(message.defaultValue[j], options);
                    }
                    if (message.notNullable != null && message.hasOwnProperty("notNullable"))
                        object.notNullable = message.notNullable;
                    if (message.notEditable != null && message.hasOwnProperty("notEditable"))
                        object.notEditable = message.notEditable;
                    if (message.notVisible != null && message.hasOwnProperty("notVisible"))
                        object.notVisible = message.notVisible;
                    if (message.required != null && message.hasOwnProperty("required"))
                        object.required = message.required;
                    if (message.isSystemMaintained != null && message.hasOwnProperty("isSystemMaintained"))
                        object.isSystemMaintained = message.isSystemMaintained;
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        object.domain = message.domain;
                    if (message.hasZ != null && message.hasOwnProperty("hasZ"))
                        object.hasZ = message.hasZ;
                    if (message.hasM != null && message.hasOwnProperty("hasM"))
                        object.hasM = message.hasM;
                    if (message.searchable != null && message.hasOwnProperty("searchable"))
                        object.searchable = message.searchable;
                    return object;
                };
    
                /**
                 * Converts this GraphProperty to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphProperty
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphProperty.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphProperty;
            })();
    
            graph.GraphDocumentEntityTypeInfo = (function() {
    
                /**
                 * Properties of a GraphDocumentEntityTypeInfo.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphDocumentEntityTypeInfo
                 * @property {string|null} [nameProperty] GraphDocumentEntityTypeInfo nameProperty
                 * @property {string|null} [titleProperty] GraphDocumentEntityTypeInfo titleProperty
                 * @property {string|null} [urlProperty] GraphDocumentEntityTypeInfo urlProperty
                 * @property {string|null} [textProperty] GraphDocumentEntityTypeInfo textProperty
                 * @property {string|null} [keywordsProperty] GraphDocumentEntityTypeInfo keywordsProperty
                 * @property {string|null} [contentTypeProperty] GraphDocumentEntityTypeInfo contentTypeProperty
                 * @property {string|null} [metadataProperty] GraphDocumentEntityTypeInfo metadataProperty
                 * @property {string|null} [fileExtensionProperty] GraphDocumentEntityTypeInfo fileExtensionProperty
                 */
    
                /**
                 * Constructs a new GraphDocumentEntityTypeInfo.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphDocumentEntityTypeInfo.
                 * @implements IGraphDocumentEntityTypeInfo
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphDocumentEntityTypeInfo=} [properties] Properties to set
                 */
                function GraphDocumentEntityTypeInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphDocumentEntityTypeInfo nameProperty.
                 * @member {string} nameProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.nameProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo titleProperty.
                 * @member {string} titleProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.titleProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo urlProperty.
                 * @member {string} urlProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.urlProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo textProperty.
                 * @member {string} textProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.textProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo keywordsProperty.
                 * @member {string} keywordsProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.keywordsProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo contentTypeProperty.
                 * @member {string} contentTypeProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.contentTypeProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo metadataProperty.
                 * @member {string} metadataProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.metadataProperty = "";
    
                /**
                 * GraphDocumentEntityTypeInfo fileExtensionProperty.
                 * @member {string} fileExtensionProperty
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 */
                GraphDocumentEntityTypeInfo.prototype.fileExtensionProperty = "";
    
                /**
                 * Creates a new GraphDocumentEntityTypeInfo instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {esriPBuffer.graph.IGraphDocumentEntityTypeInfo=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphDocumentEntityTypeInfo} GraphDocumentEntityTypeInfo instance
                 */
                GraphDocumentEntityTypeInfo.create = function create(properties) {
                    return new GraphDocumentEntityTypeInfo(properties);
                };
    
                /**
                 * Encodes the specified GraphDocumentEntityTypeInfo message. Does not implicitly {@link esriPBuffer.graph.GraphDocumentEntityTypeInfo.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {esriPBuffer.graph.IGraphDocumentEntityTypeInfo} message GraphDocumentEntityTypeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDocumentEntityTypeInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nameProperty != null && Object.hasOwnProperty.call(message, "nameProperty"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.nameProperty);
                    if (message.titleProperty != null && Object.hasOwnProperty.call(message, "titleProperty"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.titleProperty);
                    if (message.urlProperty != null && Object.hasOwnProperty.call(message, "urlProperty"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.urlProperty);
                    if (message.textProperty != null && Object.hasOwnProperty.call(message, "textProperty"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.textProperty);
                    if (message.keywordsProperty != null && Object.hasOwnProperty.call(message, "keywordsProperty"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.keywordsProperty);
                    if (message.contentTypeProperty != null && Object.hasOwnProperty.call(message, "contentTypeProperty"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.contentTypeProperty);
                    if (message.metadataProperty != null && Object.hasOwnProperty.call(message, "metadataProperty"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.metadataProperty);
                    if (message.fileExtensionProperty != null && Object.hasOwnProperty.call(message, "fileExtensionProperty"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.fileExtensionProperty);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphDocumentEntityTypeInfo message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphDocumentEntityTypeInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {esriPBuffer.graph.IGraphDocumentEntityTypeInfo} message GraphDocumentEntityTypeInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDocumentEntityTypeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphDocumentEntityTypeInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphDocumentEntityTypeInfo} GraphDocumentEntityTypeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDocumentEntityTypeInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nameProperty = reader.string();
                            break;
                        case 2:
                            message.titleProperty = reader.string();
                            break;
                        case 3:
                            message.urlProperty = reader.string();
                            break;
                        case 4:
                            message.textProperty = reader.string();
                            break;
                        case 5:
                            message.keywordsProperty = reader.string();
                            break;
                        case 6:
                            message.contentTypeProperty = reader.string();
                            break;
                        case 7:
                            message.metadataProperty = reader.string();
                            break;
                        case 8:
                            message.fileExtensionProperty = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphDocumentEntityTypeInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphDocumentEntityTypeInfo} GraphDocumentEntityTypeInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDocumentEntityTypeInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphDocumentEntityTypeInfo message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphDocumentEntityTypeInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nameProperty != null && message.hasOwnProperty("nameProperty"))
                        if (!$util.isString(message.nameProperty))
                            return "nameProperty: string expected";
                    if (message.titleProperty != null && message.hasOwnProperty("titleProperty"))
                        if (!$util.isString(message.titleProperty))
                            return "titleProperty: string expected";
                    if (message.urlProperty != null && message.hasOwnProperty("urlProperty"))
                        if (!$util.isString(message.urlProperty))
                            return "urlProperty: string expected";
                    if (message.textProperty != null && message.hasOwnProperty("textProperty"))
                        if (!$util.isString(message.textProperty))
                            return "textProperty: string expected";
                    if (message.keywordsProperty != null && message.hasOwnProperty("keywordsProperty"))
                        if (!$util.isString(message.keywordsProperty))
                            return "keywordsProperty: string expected";
                    if (message.contentTypeProperty != null && message.hasOwnProperty("contentTypeProperty"))
                        if (!$util.isString(message.contentTypeProperty))
                            return "contentTypeProperty: string expected";
                    if (message.metadataProperty != null && message.hasOwnProperty("metadataProperty"))
                        if (!$util.isString(message.metadataProperty))
                            return "metadataProperty: string expected";
                    if (message.fileExtensionProperty != null && message.hasOwnProperty("fileExtensionProperty"))
                        if (!$util.isString(message.fileExtensionProperty))
                            return "fileExtensionProperty: string expected";
                    return null;
                };
    
                /**
                 * Creates a GraphDocumentEntityTypeInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphDocumentEntityTypeInfo} GraphDocumentEntityTypeInfo
                 */
                GraphDocumentEntityTypeInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo();
                    if (object.nameProperty != null)
                        message.nameProperty = String(object.nameProperty);
                    if (object.titleProperty != null)
                        message.titleProperty = String(object.titleProperty);
                    if (object.urlProperty != null)
                        message.urlProperty = String(object.urlProperty);
                    if (object.textProperty != null)
                        message.textProperty = String(object.textProperty);
                    if (object.keywordsProperty != null)
                        message.keywordsProperty = String(object.keywordsProperty);
                    if (object.contentTypeProperty != null)
                        message.contentTypeProperty = String(object.contentTypeProperty);
                    if (object.metadataProperty != null)
                        message.metadataProperty = String(object.metadataProperty);
                    if (object.fileExtensionProperty != null)
                        message.fileExtensionProperty = String(object.fileExtensionProperty);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphDocumentEntityTypeInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @static
                 * @param {esriPBuffer.graph.GraphDocumentEntityTypeInfo} message GraphDocumentEntityTypeInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphDocumentEntityTypeInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.nameProperty = "";
                        object.titleProperty = "";
                        object.urlProperty = "";
                        object.textProperty = "";
                        object.keywordsProperty = "";
                        object.contentTypeProperty = "";
                        object.metadataProperty = "";
                        object.fileExtensionProperty = "";
                    }
                    if (message.nameProperty != null && message.hasOwnProperty("nameProperty"))
                        object.nameProperty = message.nameProperty;
                    if (message.titleProperty != null && message.hasOwnProperty("titleProperty"))
                        object.titleProperty = message.titleProperty;
                    if (message.urlProperty != null && message.hasOwnProperty("urlProperty"))
                        object.urlProperty = message.urlProperty;
                    if (message.textProperty != null && message.hasOwnProperty("textProperty"))
                        object.textProperty = message.textProperty;
                    if (message.keywordsProperty != null && message.hasOwnProperty("keywordsProperty"))
                        object.keywordsProperty = message.keywordsProperty;
                    if (message.contentTypeProperty != null && message.hasOwnProperty("contentTypeProperty"))
                        object.contentTypeProperty = message.contentTypeProperty;
                    if (message.metadataProperty != null && message.hasOwnProperty("metadataProperty"))
                        object.metadataProperty = message.metadataProperty;
                    if (message.fileExtensionProperty != null && message.hasOwnProperty("fileExtensionProperty"))
                        object.fileExtensionProperty = message.fileExtensionProperty;
                    return object;
                };
    
                /**
                 * Converts this GraphDocumentEntityTypeInfo to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphDocumentEntityTypeInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphDocumentEntityTypeInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphDocumentEntityTypeInfo;
            })();
    
            graph.GraphPropertyAddResult = (function() {
    
                /**
                 * Properties of a GraphPropertyAddResult.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyAddResult
                 * @property {string|null} [name] GraphPropertyAddResult name
                 * @property {esriPBuffer.graph.IError|null} [error] GraphPropertyAddResult error
                 */
    
                /**
                 * Constructs a new GraphPropertyAddResult.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyAddResult.
                 * @implements IGraphPropertyAddResult
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyAddResult=} [properties] Properties to set
                 */
                function GraphPropertyAddResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyAddResult name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @instance
                 */
                GraphPropertyAddResult.prototype.name = "";
    
                /**
                 * GraphPropertyAddResult error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @instance
                 */
                GraphPropertyAddResult.prototype.error = null;
    
                /**
                 * Creates a new GraphPropertyAddResult instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddResult=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyAddResult} GraphPropertyAddResult instance
                 */
                GraphPropertyAddResult.create = function create(properties) {
                    return new GraphPropertyAddResult(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyAddResult message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyAddResult.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddResult} message GraphPropertyAddResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyAddResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyAddResult message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyAddResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddResult} message GraphPropertyAddResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyAddResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyAddResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyAddResult} GraphPropertyAddResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyAddResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyAddResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyAddResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyAddResult} GraphPropertyAddResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyAddResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyAddResult message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyAddResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyAddResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyAddResult} GraphPropertyAddResult
                 */
                GraphPropertyAddResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyAddResult)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyAddResult();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyAddResult.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyAddResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyAddResult} message GraphPropertyAddResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyAddResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.error = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyAddResult to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyAddResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyAddResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyAddResult;
            })();
    
            graph.GraphPropertyAddsResponse = (function() {
    
                /**
                 * Properties of a GraphPropertyAddsResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyAddsResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphPropertyAddsResponse error
                 * @property {Array.<esriPBuffer.graph.IGraphPropertyAddResult>|null} [propertyAddResults] GraphPropertyAddsResponse propertyAddResults
                 */
    
                /**
                 * Constructs a new GraphPropertyAddsResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyAddsResponse.
                 * @implements IGraphPropertyAddsResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyAddsResponse=} [properties] Properties to set
                 */
                function GraphPropertyAddsResponse(properties) {
                    this.propertyAddResults = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyAddsResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @instance
                 */
                GraphPropertyAddsResponse.prototype.error = null;
    
                /**
                 * GraphPropertyAddsResponse propertyAddResults.
                 * @member {Array.<esriPBuffer.graph.IGraphPropertyAddResult>} propertyAddResults
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @instance
                 */
                GraphPropertyAddsResponse.prototype.propertyAddResults = $util.emptyArray;
    
                /**
                 * Creates a new GraphPropertyAddsResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddsResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyAddsResponse} GraphPropertyAddsResponse instance
                 */
                GraphPropertyAddsResponse.create = function create(properties) {
                    return new GraphPropertyAddsResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyAddsResponse message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyAddsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddsResponse} message GraphPropertyAddsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyAddsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.propertyAddResults != null && message.propertyAddResults.length)
                        for (var i = 0; i < message.propertyAddResults.length; ++i)
                            $root.esriPBuffer.graph.GraphPropertyAddResult.encode(message.propertyAddResults[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyAddsResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyAddsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyAddsResponse} message GraphPropertyAddsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyAddsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyAddsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyAddsResponse} GraphPropertyAddsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyAddsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyAddsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.propertyAddResults && message.propertyAddResults.length))
                                message.propertyAddResults = [];
                            message.propertyAddResults.push($root.esriPBuffer.graph.GraphPropertyAddResult.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyAddsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyAddsResponse} GraphPropertyAddsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyAddsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyAddsResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyAddsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.propertyAddResults != null && message.hasOwnProperty("propertyAddResults")) {
                        if (!Array.isArray(message.propertyAddResults))
                            return "propertyAddResults: array expected";
                        for (var i = 0; i < message.propertyAddResults.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphPropertyAddResult.verify(message.propertyAddResults[i]);
                            if (error)
                                return "propertyAddResults." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyAddsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyAddsResponse} GraphPropertyAddsResponse
                 */
                GraphPropertyAddsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyAddsResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyAddsResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyAddsResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.propertyAddResults) {
                        if (!Array.isArray(object.propertyAddResults))
                            throw TypeError(".esriPBuffer.graph.GraphPropertyAddsResponse.propertyAddResults: array expected");
                        message.propertyAddResults = [];
                        for (var i = 0; i < object.propertyAddResults.length; ++i) {
                            if (typeof object.propertyAddResults[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphPropertyAddsResponse.propertyAddResults: object expected");
                            message.propertyAddResults[i] = $root.esriPBuffer.graph.GraphPropertyAddResult.fromObject(object.propertyAddResults[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyAddsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyAddsResponse} message GraphPropertyAddsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyAddsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.propertyAddResults = [];
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    if (message.propertyAddResults && message.propertyAddResults.length) {
                        object.propertyAddResults = [];
                        for (var j = 0; j < message.propertyAddResults.length; ++j)
                            object.propertyAddResults[j] = $root.esriPBuffer.graph.GraphPropertyAddResult.toObject(message.propertyAddResults[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyAddsResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyAddsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyAddsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyAddsResponse;
            })();
    
            graph.GraphPropertyIndexAddsRequest = (function() {
    
                /**
                 * Properties of a GraphPropertyIndexAddsRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyIndexAddsRequest
                 * @property {Array.<esriPBuffer.EsriTypes.IFieldIndex>|null} [fieldIndexes] GraphPropertyIndexAddsRequest fieldIndexes
                 */
    
                /**
                 * Constructs a new GraphPropertyIndexAddsRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyIndexAddsRequest.
                 * @implements IGraphPropertyIndexAddsRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsRequest=} [properties] Properties to set
                 */
                function GraphPropertyIndexAddsRequest(properties) {
                    this.fieldIndexes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyIndexAddsRequest fieldIndexes.
                 * @member {Array.<esriPBuffer.EsriTypes.IFieldIndex>} fieldIndexes
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @instance
                 */
                GraphPropertyIndexAddsRequest.prototype.fieldIndexes = $util.emptyArray;
    
                /**
                 * Creates a new GraphPropertyIndexAddsRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsRequest} GraphPropertyIndexAddsRequest instance
                 */
                GraphPropertyIndexAddsRequest.create = function create(properties) {
                    return new GraphPropertyIndexAddsRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexAddsRequest message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexAddsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsRequest} message GraphPropertyIndexAddsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexAddsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fieldIndexes != null && message.fieldIndexes.length)
                        for (var i = 0; i < message.fieldIndexes.length; ++i)
                            $root.esriPBuffer.EsriTypes.FieldIndex.encode(message.fieldIndexes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexAddsRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexAddsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsRequest} message GraphPropertyIndexAddsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexAddsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyIndexAddsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsRequest} GraphPropertyIndexAddsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexAddsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyIndexAddsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.fieldIndexes && message.fieldIndexes.length))
                                message.fieldIndexes = [];
                            message.fieldIndexes.push($root.esriPBuffer.EsriTypes.FieldIndex.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyIndexAddsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsRequest} GraphPropertyIndexAddsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexAddsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyIndexAddsRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyIndexAddsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fieldIndexes != null && message.hasOwnProperty("fieldIndexes")) {
                        if (!Array.isArray(message.fieldIndexes))
                            return "fieldIndexes: array expected";
                        for (var i = 0; i < message.fieldIndexes.length; ++i) {
                            var error = $root.esriPBuffer.EsriTypes.FieldIndex.verify(message.fieldIndexes[i]);
                            if (error)
                                return "fieldIndexes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyIndexAddsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsRequest} GraphPropertyIndexAddsRequest
                 */
                GraphPropertyIndexAddsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyIndexAddsRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyIndexAddsRequest();
                    if (object.fieldIndexes) {
                        if (!Array.isArray(object.fieldIndexes))
                            throw TypeError(".esriPBuffer.graph.GraphPropertyIndexAddsRequest.fieldIndexes: array expected");
                        message.fieldIndexes = [];
                        for (var i = 0; i < object.fieldIndexes.length; ++i) {
                            if (typeof object.fieldIndexes[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphPropertyIndexAddsRequest.fieldIndexes: object expected");
                            message.fieldIndexes[i] = $root.esriPBuffer.EsriTypes.FieldIndex.fromObject(object.fieldIndexes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyIndexAddsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyIndexAddsRequest} message GraphPropertyIndexAddsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyIndexAddsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.fieldIndexes = [];
                    if (message.fieldIndexes && message.fieldIndexes.length) {
                        object.fieldIndexes = [];
                        for (var j = 0; j < message.fieldIndexes.length; ++j)
                            object.fieldIndexes[j] = $root.esriPBuffer.EsriTypes.FieldIndex.toObject(message.fieldIndexes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyIndexAddsRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyIndexAddsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyIndexAddsRequest;
            })();
    
            graph.GraphPropertyIndexAddResult = (function() {
    
                /**
                 * Properties of a GraphPropertyIndexAddResult.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyIndexAddResult
                 * @property {string|null} [name] GraphPropertyIndexAddResult name
                 * @property {esriPBuffer.graph.IError|null} [error] GraphPropertyIndexAddResult error
                 */
    
                /**
                 * Constructs a new GraphPropertyIndexAddResult.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyIndexAddResult.
                 * @implements IGraphPropertyIndexAddResult
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddResult=} [properties] Properties to set
                 */
                function GraphPropertyIndexAddResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyIndexAddResult name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @instance
                 */
                GraphPropertyIndexAddResult.prototype.name = "";
    
                /**
                 * GraphPropertyIndexAddResult error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @instance
                 */
                GraphPropertyIndexAddResult.prototype.error = null;
    
                /**
                 * Creates a new GraphPropertyIndexAddResult instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddResult=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddResult} GraphPropertyIndexAddResult instance
                 */
                GraphPropertyIndexAddResult.create = function create(properties) {
                    return new GraphPropertyIndexAddResult(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexAddResult message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexAddResult.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddResult} message GraphPropertyIndexAddResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexAddResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexAddResult message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexAddResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddResult} message GraphPropertyIndexAddResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexAddResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyIndexAddResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddResult} GraphPropertyIndexAddResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexAddResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyIndexAddResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyIndexAddResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddResult} GraphPropertyIndexAddResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexAddResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyIndexAddResult message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyIndexAddResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyIndexAddResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddResult} GraphPropertyIndexAddResult
                 */
                GraphPropertyIndexAddResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyIndexAddResult)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyIndexAddResult();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyIndexAddResult.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyIndexAddResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyIndexAddResult} message GraphPropertyIndexAddResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyIndexAddResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.error = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyIndexAddResult to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyIndexAddResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyIndexAddResult;
            })();
    
            graph.GraphPropertyIndexAddsResponse = (function() {
    
                /**
                 * Properties of a GraphPropertyIndexAddsResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyIndexAddsResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphPropertyIndexAddsResponse error
                 * @property {Array.<esriPBuffer.graph.IGraphPropertyIndexAddResult>|null} [indexAddResults] GraphPropertyIndexAddsResponse indexAddResults
                 */
    
                /**
                 * Constructs a new GraphPropertyIndexAddsResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyIndexAddsResponse.
                 * @implements IGraphPropertyIndexAddsResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsResponse=} [properties] Properties to set
                 */
                function GraphPropertyIndexAddsResponse(properties) {
                    this.indexAddResults = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyIndexAddsResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @instance
                 */
                GraphPropertyIndexAddsResponse.prototype.error = null;
    
                /**
                 * GraphPropertyIndexAddsResponse indexAddResults.
                 * @member {Array.<esriPBuffer.graph.IGraphPropertyIndexAddResult>} indexAddResults
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @instance
                 */
                GraphPropertyIndexAddsResponse.prototype.indexAddResults = $util.emptyArray;
    
                /**
                 * Creates a new GraphPropertyIndexAddsResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsResponse} GraphPropertyIndexAddsResponse instance
                 */
                GraphPropertyIndexAddsResponse.create = function create(properties) {
                    return new GraphPropertyIndexAddsResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexAddsResponse message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexAddsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsResponse} message GraphPropertyIndexAddsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexAddsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.indexAddResults != null && message.indexAddResults.length)
                        for (var i = 0; i < message.indexAddResults.length; ++i)
                            $root.esriPBuffer.graph.GraphPropertyIndexAddResult.encode(message.indexAddResults[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexAddsResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexAddsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexAddsResponse} message GraphPropertyIndexAddsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexAddsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyIndexAddsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsResponse} GraphPropertyIndexAddsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexAddsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyIndexAddsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.indexAddResults && message.indexAddResults.length))
                                message.indexAddResults = [];
                            message.indexAddResults.push($root.esriPBuffer.graph.GraphPropertyIndexAddResult.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyIndexAddsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsResponse} GraphPropertyIndexAddsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexAddsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyIndexAddsResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyIndexAddsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.indexAddResults != null && message.hasOwnProperty("indexAddResults")) {
                        if (!Array.isArray(message.indexAddResults))
                            return "indexAddResults: array expected";
                        for (var i = 0; i < message.indexAddResults.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphPropertyIndexAddResult.verify(message.indexAddResults[i]);
                            if (error)
                                return "indexAddResults." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyIndexAddsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyIndexAddsResponse} GraphPropertyIndexAddsResponse
                 */
                GraphPropertyIndexAddsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyIndexAddsResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyIndexAddsResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyIndexAddsResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.indexAddResults) {
                        if (!Array.isArray(object.indexAddResults))
                            throw TypeError(".esriPBuffer.graph.GraphPropertyIndexAddsResponse.indexAddResults: array expected");
                        message.indexAddResults = [];
                        for (var i = 0; i < object.indexAddResults.length; ++i) {
                            if (typeof object.indexAddResults[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphPropertyIndexAddsResponse.indexAddResults: object expected");
                            message.indexAddResults[i] = $root.esriPBuffer.graph.GraphPropertyIndexAddResult.fromObject(object.indexAddResults[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyIndexAddsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyIndexAddsResponse} message GraphPropertyIndexAddsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyIndexAddsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.indexAddResults = [];
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    if (message.indexAddResults && message.indexAddResults.length) {
                        object.indexAddResults = [];
                        for (var j = 0; j < message.indexAddResults.length; ++j)
                            object.indexAddResults[j] = $root.esriPBuffer.graph.GraphPropertyIndexAddResult.toObject(message.indexAddResults[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyIndexAddsResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyIndexAddsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyIndexAddsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyIndexAddsResponse;
            })();
    
            graph.GraphNamedObjectTypeAddsRequest = (function() {
    
                /**
                 * Properties of a GraphNamedObjectTypeAddsRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphNamedObjectTypeAddsRequest
                 * @property {Array.<esriPBuffer.graph.IEntityType>|null} [entityTypes] GraphNamedObjectTypeAddsRequest entityTypes
                 * @property {Array.<esriPBuffer.graph.IRelationshipType>|null} [relationshipTypes] GraphNamedObjectTypeAddsRequest relationshipTypes
                 */
    
                /**
                 * Constructs a new GraphNamedObjectTypeAddsRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphNamedObjectTypeAddsRequest.
                 * @implements IGraphNamedObjectTypeAddsRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsRequest=} [properties] Properties to set
                 */
                function GraphNamedObjectTypeAddsRequest(properties) {
                    this.entityTypes = [];
                    this.relationshipTypes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphNamedObjectTypeAddsRequest entityTypes.
                 * @member {Array.<esriPBuffer.graph.IEntityType>} entityTypes
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @instance
                 */
                GraphNamedObjectTypeAddsRequest.prototype.entityTypes = $util.emptyArray;
    
                /**
                 * GraphNamedObjectTypeAddsRequest relationshipTypes.
                 * @member {Array.<esriPBuffer.graph.IRelationshipType>} relationshipTypes
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @instance
                 */
                GraphNamedObjectTypeAddsRequest.prototype.relationshipTypes = $util.emptyArray;
    
                /**
                 * Creates a new GraphNamedObjectTypeAddsRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsRequest} GraphNamedObjectTypeAddsRequest instance
                 */
                GraphNamedObjectTypeAddsRequest.create = function create(properties) {
                    return new GraphNamedObjectTypeAddsRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeAddsRequest message. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeAddsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsRequest} message GraphNamedObjectTypeAddsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeAddsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entityTypes != null && message.entityTypes.length)
                        for (var i = 0; i < message.entityTypes.length; ++i)
                            $root.esriPBuffer.graph.EntityType.encode(message.entityTypes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.relationshipTypes != null && message.relationshipTypes.length)
                        for (var i = 0; i < message.relationshipTypes.length; ++i)
                            $root.esriPBuffer.graph.RelationshipType.encode(message.relationshipTypes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeAddsRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeAddsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsRequest} message GraphNamedObjectTypeAddsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeAddsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeAddsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsRequest} GraphNamedObjectTypeAddsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeAddsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphNamedObjectTypeAddsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.entityTypes && message.entityTypes.length))
                                message.entityTypes = [];
                            message.entityTypes.push($root.esriPBuffer.graph.EntityType.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.relationshipTypes && message.relationshipTypes.length))
                                message.relationshipTypes = [];
                            message.relationshipTypes.push($root.esriPBuffer.graph.RelationshipType.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeAddsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsRequest} GraphNamedObjectTypeAddsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeAddsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphNamedObjectTypeAddsRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphNamedObjectTypeAddsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entityTypes != null && message.hasOwnProperty("entityTypes")) {
                        if (!Array.isArray(message.entityTypes))
                            return "entityTypes: array expected";
                        for (var i = 0; i < message.entityTypes.length; ++i) {
                            var error = $root.esriPBuffer.graph.EntityType.verify(message.entityTypes[i]);
                            if (error)
                                return "entityTypes." + error;
                        }
                    }
                    if (message.relationshipTypes != null && message.hasOwnProperty("relationshipTypes")) {
                        if (!Array.isArray(message.relationshipTypes))
                            return "relationshipTypes: array expected";
                        for (var i = 0; i < message.relationshipTypes.length; ++i) {
                            var error = $root.esriPBuffer.graph.RelationshipType.verify(message.relationshipTypes[i]);
                            if (error)
                                return "relationshipTypes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphNamedObjectTypeAddsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsRequest} GraphNamedObjectTypeAddsRequest
                 */
                GraphNamedObjectTypeAddsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphNamedObjectTypeAddsRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphNamedObjectTypeAddsRequest();
                    if (object.entityTypes) {
                        if (!Array.isArray(object.entityTypes))
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsRequest.entityTypes: array expected");
                        message.entityTypes = [];
                        for (var i = 0; i < object.entityTypes.length; ++i) {
                            if (typeof object.entityTypes[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsRequest.entityTypes: object expected");
                            message.entityTypes[i] = $root.esriPBuffer.graph.EntityType.fromObject(object.entityTypes[i]);
                        }
                    }
                    if (object.relationshipTypes) {
                        if (!Array.isArray(object.relationshipTypes))
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsRequest.relationshipTypes: array expected");
                        message.relationshipTypes = [];
                        for (var i = 0; i < object.relationshipTypes.length; ++i) {
                            if (typeof object.relationshipTypes[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsRequest.relationshipTypes: object expected");
                            message.relationshipTypes[i] = $root.esriPBuffer.graph.RelationshipType.fromObject(object.relationshipTypes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphNamedObjectTypeAddsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphNamedObjectTypeAddsRequest} message GraphNamedObjectTypeAddsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphNamedObjectTypeAddsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.entityTypes = [];
                        object.relationshipTypes = [];
                    }
                    if (message.entityTypes && message.entityTypes.length) {
                        object.entityTypes = [];
                        for (var j = 0; j < message.entityTypes.length; ++j)
                            object.entityTypes[j] = $root.esriPBuffer.graph.EntityType.toObject(message.entityTypes[j], options);
                    }
                    if (message.relationshipTypes && message.relationshipTypes.length) {
                        object.relationshipTypes = [];
                        for (var j = 0; j < message.relationshipTypes.length; ++j)
                            object.relationshipTypes[j] = $root.esriPBuffer.graph.RelationshipType.toObject(message.relationshipTypes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphNamedObjectTypeAddsRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphNamedObjectTypeAddsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphNamedObjectTypeAddsRequest;
            })();
    
            graph.GraphNamedObjectTypeAddResult = (function() {
    
                /**
                 * Properties of a GraphNamedObjectTypeAddResult.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphNamedObjectTypeAddResult
                 * @property {string|null} [name] GraphNamedObjectTypeAddResult name
                 * @property {esriPBuffer.graph.IError|null} [error] GraphNamedObjectTypeAddResult error
                 */
    
                /**
                 * Constructs a new GraphNamedObjectTypeAddResult.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphNamedObjectTypeAddResult.
                 * @implements IGraphNamedObjectTypeAddResult
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddResult=} [properties] Properties to set
                 */
                function GraphNamedObjectTypeAddResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphNamedObjectTypeAddResult name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @instance
                 */
                GraphNamedObjectTypeAddResult.prototype.name = "";
    
                /**
                 * GraphNamedObjectTypeAddResult error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @instance
                 */
                GraphNamedObjectTypeAddResult.prototype.error = null;
    
                /**
                 * Creates a new GraphNamedObjectTypeAddResult instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddResult=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddResult} GraphNamedObjectTypeAddResult instance
                 */
                GraphNamedObjectTypeAddResult.create = function create(properties) {
                    return new GraphNamedObjectTypeAddResult(properties);
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeAddResult message. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeAddResult.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddResult} message GraphNamedObjectTypeAddResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeAddResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeAddResult message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeAddResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddResult} message GraphNamedObjectTypeAddResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeAddResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeAddResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddResult} GraphNamedObjectTypeAddResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeAddResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeAddResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddResult} GraphNamedObjectTypeAddResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeAddResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphNamedObjectTypeAddResult message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphNamedObjectTypeAddResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphNamedObjectTypeAddResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddResult} GraphNamedObjectTypeAddResult
                 */
                GraphNamedObjectTypeAddResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddResult.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphNamedObjectTypeAddResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @static
                 * @param {esriPBuffer.graph.GraphNamedObjectTypeAddResult} message GraphNamedObjectTypeAddResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphNamedObjectTypeAddResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.error = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphNamedObjectTypeAddResult to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphNamedObjectTypeAddResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphNamedObjectTypeAddResult;
            })();
    
            graph.GraphNamedObjectTypeAddsResponse = (function() {
    
                /**
                 * Properties of a GraphNamedObjectTypeAddsResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphNamedObjectTypeAddsResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphNamedObjectTypeAddsResponse error
                 * @property {Array.<esriPBuffer.graph.IGraphNamedObjectTypeAddResult>|null} [entityAddResults] GraphNamedObjectTypeAddsResponse entityAddResults
                 * @property {Array.<esriPBuffer.graph.IGraphNamedObjectTypeAddResult>|null} [relationshipAddResults] GraphNamedObjectTypeAddsResponse relationshipAddResults
                 */
    
                /**
                 * Constructs a new GraphNamedObjectTypeAddsResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphNamedObjectTypeAddsResponse.
                 * @implements IGraphNamedObjectTypeAddsResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsResponse=} [properties] Properties to set
                 */
                function GraphNamedObjectTypeAddsResponse(properties) {
                    this.entityAddResults = [];
                    this.relationshipAddResults = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphNamedObjectTypeAddsResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @instance
                 */
                GraphNamedObjectTypeAddsResponse.prototype.error = null;
    
                /**
                 * GraphNamedObjectTypeAddsResponse entityAddResults.
                 * @member {Array.<esriPBuffer.graph.IGraphNamedObjectTypeAddResult>} entityAddResults
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @instance
                 */
                GraphNamedObjectTypeAddsResponse.prototype.entityAddResults = $util.emptyArray;
    
                /**
                 * GraphNamedObjectTypeAddsResponse relationshipAddResults.
                 * @member {Array.<esriPBuffer.graph.IGraphNamedObjectTypeAddResult>} relationshipAddResults
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @instance
                 */
                GraphNamedObjectTypeAddsResponse.prototype.relationshipAddResults = $util.emptyArray;
    
                /**
                 * Creates a new GraphNamedObjectTypeAddsResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsResponse} GraphNamedObjectTypeAddsResponse instance
                 */
                GraphNamedObjectTypeAddsResponse.create = function create(properties) {
                    return new GraphNamedObjectTypeAddsResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeAddsResponse message. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsResponse} message GraphNamedObjectTypeAddsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeAddsResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.entityAddResults != null && message.entityAddResults.length)
                        for (var i = 0; i < message.entityAddResults.length; ++i)
                            $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.encode(message.entityAddResults[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.relationshipAddResults != null && message.relationshipAddResults.length)
                        for (var i = 0; i < message.relationshipAddResults.length; ++i)
                            $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.encode(message.relationshipAddResults[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeAddsResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeAddsResponse} message GraphNamedObjectTypeAddsResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeAddsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeAddsResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsResponse} GraphNamedObjectTypeAddsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeAddsResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphNamedObjectTypeAddsResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.entityAddResults && message.entityAddResults.length))
                                message.entityAddResults = [];
                            message.entityAddResults.push($root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.relationshipAddResults && message.relationshipAddResults.length))
                                message.relationshipAddResults = [];
                            message.relationshipAddResults.push($root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeAddsResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsResponse} GraphNamedObjectTypeAddsResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeAddsResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphNamedObjectTypeAddsResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphNamedObjectTypeAddsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.entityAddResults != null && message.hasOwnProperty("entityAddResults")) {
                        if (!Array.isArray(message.entityAddResults))
                            return "entityAddResults: array expected";
                        for (var i = 0; i < message.entityAddResults.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.verify(message.entityAddResults[i]);
                            if (error)
                                return "entityAddResults." + error;
                        }
                    }
                    if (message.relationshipAddResults != null && message.hasOwnProperty("relationshipAddResults")) {
                        if (!Array.isArray(message.relationshipAddResults))
                            return "relationshipAddResults: array expected";
                        for (var i = 0; i < message.relationshipAddResults.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.verify(message.relationshipAddResults[i]);
                            if (error)
                                return "relationshipAddResults." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphNamedObjectTypeAddsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeAddsResponse} GraphNamedObjectTypeAddsResponse
                 */
                GraphNamedObjectTypeAddsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphNamedObjectTypeAddsResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphNamedObjectTypeAddsResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.entityAddResults) {
                        if (!Array.isArray(object.entityAddResults))
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.entityAddResults: array expected");
                        message.entityAddResults = [];
                        for (var i = 0; i < object.entityAddResults.length; ++i) {
                            if (typeof object.entityAddResults[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.entityAddResults: object expected");
                            message.entityAddResults[i] = $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.fromObject(object.entityAddResults[i]);
                        }
                    }
                    if (object.relationshipAddResults) {
                        if (!Array.isArray(object.relationshipAddResults))
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.relationshipAddResults: array expected");
                        message.relationshipAddResults = [];
                        for (var i = 0; i < object.relationshipAddResults.length; ++i) {
                            if (typeof object.relationshipAddResults[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeAddsResponse.relationshipAddResults: object expected");
                            message.relationshipAddResults[i] = $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.fromObject(object.relationshipAddResults[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphNamedObjectTypeAddsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphNamedObjectTypeAddsResponse} message GraphNamedObjectTypeAddsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphNamedObjectTypeAddsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.entityAddResults = [];
                        object.relationshipAddResults = [];
                    }
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    if (message.entityAddResults && message.entityAddResults.length) {
                        object.entityAddResults = [];
                        for (var j = 0; j < message.entityAddResults.length; ++j)
                            object.entityAddResults[j] = $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.toObject(message.entityAddResults[j], options);
                    }
                    if (message.relationshipAddResults && message.relationshipAddResults.length) {
                        object.relationshipAddResults = [];
                        for (var j = 0; j < message.relationshipAddResults.length; ++j)
                            object.relationshipAddResults[j] = $root.esriPBuffer.graph.GraphNamedObjectTypeAddResult.toObject(message.relationshipAddResults[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphNamedObjectTypeAddsResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeAddsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphNamedObjectTypeAddsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphNamedObjectTypeAddsResponse;
            })();
    
            graph.NamedObjectAdd = (function() {
    
                /**
                 * Properties of a NamedObjectAdd.
                 * @memberof esriPBuffer.graph
                 * @interface INamedObjectAdd
                 * @property {Object.<string,esriPBuffer.graph.IAnyValue>|null} [properties] NamedObjectAdd properties
                 */
    
                /**
                 * Constructs a new NamedObjectAdd.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NamedObjectAdd.
                 * @implements INamedObjectAdd
                 * @constructor
                 * @param {esriPBuffer.graph.INamedObjectAdd=} [properties] Properties to set
                 */
                function NamedObjectAdd(properties) {
                    this.properties = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedObjectAdd properties.
                 * @member {Object.<string,esriPBuffer.graph.IAnyValue>} properties
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @instance
                 */
                NamedObjectAdd.prototype.properties = $util.emptyObject;
    
                /**
                 * Creates a new NamedObjectAdd instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectAdd=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NamedObjectAdd} NamedObjectAdd instance
                 */
                NamedObjectAdd.create = function create(properties) {
                    return new NamedObjectAdd(properties);
                };
    
                /**
                 * Encodes the specified NamedObjectAdd message. Does not implicitly {@link esriPBuffer.graph.NamedObjectAdd.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectAdd} message NamedObjectAdd message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectAdd.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.AnyValue.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified NamedObjectAdd message, length delimited. Does not implicitly {@link esriPBuffer.graph.NamedObjectAdd.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectAdd} message NamedObjectAdd message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectAdd.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NamedObjectAdd message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NamedObjectAdd} NamedObjectAdd
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectAdd.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NamedObjectAdd(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.properties === $util.emptyObject)
                                message.properties = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.properties[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NamedObjectAdd message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NamedObjectAdd} NamedObjectAdd
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectAdd.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NamedObjectAdd message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedObjectAdd.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!$util.isObject(message.properties))
                            return "properties: object expected";
                        var key = Object.keys(message.properties);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.properties[key[i]]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NamedObjectAdd message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NamedObjectAdd} NamedObjectAdd
                 */
                NamedObjectAdd.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NamedObjectAdd)
                        return object;
                    var message = new $root.esriPBuffer.graph.NamedObjectAdd();
                    if (object.properties) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".esriPBuffer.graph.NamedObjectAdd.properties: object expected");
                        message.properties = {};
                        for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                            if (typeof object.properties[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.NamedObjectAdd.properties: object expected");
                            message.properties[keys[i]] = $root.esriPBuffer.graph.AnyValue.fromObject(object.properties[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NamedObjectAdd message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @static
                 * @param {esriPBuffer.graph.NamedObjectAdd} message NamedObjectAdd
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedObjectAdd.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.properties = {};
                    var keys2;
                    if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                        object.properties = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.properties[keys2[j]] = $root.esriPBuffer.graph.AnyValue.toObject(message.properties[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NamedObjectAdd to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NamedObjectAdd
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedObjectAdd.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NamedObjectAdd;
            })();
    
            graph.NamedObjectAdds = (function() {
    
                /**
                 * Properties of a NamedObjectAdds.
                 * @memberof esriPBuffer.graph
                 * @interface INamedObjectAdds
                 * @property {Array.<esriPBuffer.graph.INamedObjectAdd>|null} [namedObjectAdds] NamedObjectAdds namedObjectAdds
                 */
    
                /**
                 * Constructs a new NamedObjectAdds.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NamedObjectAdds.
                 * @implements INamedObjectAdds
                 * @constructor
                 * @param {esriPBuffer.graph.INamedObjectAdds=} [properties] Properties to set
                 */
                function NamedObjectAdds(properties) {
                    this.namedObjectAdds = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedObjectAdds namedObjectAdds.
                 * @member {Array.<esriPBuffer.graph.INamedObjectAdd>} namedObjectAdds
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @instance
                 */
                NamedObjectAdds.prototype.namedObjectAdds = $util.emptyArray;
    
                /**
                 * Creates a new NamedObjectAdds instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectAdds=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NamedObjectAdds} NamedObjectAdds instance
                 */
                NamedObjectAdds.create = function create(properties) {
                    return new NamedObjectAdds(properties);
                };
    
                /**
                 * Encodes the specified NamedObjectAdds message. Does not implicitly {@link esriPBuffer.graph.NamedObjectAdds.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectAdds} message NamedObjectAdds message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectAdds.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.namedObjectAdds != null && message.namedObjectAdds.length)
                        for (var i = 0; i < message.namedObjectAdds.length; ++i)
                            $root.esriPBuffer.graph.NamedObjectAdd.encode(message.namedObjectAdds[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NamedObjectAdds message, length delimited. Does not implicitly {@link esriPBuffer.graph.NamedObjectAdds.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectAdds} message NamedObjectAdds message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectAdds.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NamedObjectAdds message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NamedObjectAdds} NamedObjectAdds
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectAdds.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NamedObjectAdds();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.namedObjectAdds && message.namedObjectAdds.length))
                                message.namedObjectAdds = [];
                            message.namedObjectAdds.push($root.esriPBuffer.graph.NamedObjectAdd.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NamedObjectAdds message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NamedObjectAdds} NamedObjectAdds
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectAdds.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NamedObjectAdds message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedObjectAdds.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.namedObjectAdds != null && message.hasOwnProperty("namedObjectAdds")) {
                        if (!Array.isArray(message.namedObjectAdds))
                            return "namedObjectAdds: array expected";
                        for (var i = 0; i < message.namedObjectAdds.length; ++i) {
                            var error = $root.esriPBuffer.graph.NamedObjectAdd.verify(message.namedObjectAdds[i]);
                            if (error)
                                return "namedObjectAdds." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NamedObjectAdds message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NamedObjectAdds} NamedObjectAdds
                 */
                NamedObjectAdds.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NamedObjectAdds)
                        return object;
                    var message = new $root.esriPBuffer.graph.NamedObjectAdds();
                    if (object.namedObjectAdds) {
                        if (!Array.isArray(object.namedObjectAdds))
                            throw TypeError(".esriPBuffer.graph.NamedObjectAdds.namedObjectAdds: array expected");
                        message.namedObjectAdds = [];
                        for (var i = 0; i < object.namedObjectAdds.length; ++i) {
                            if (typeof object.namedObjectAdds[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.NamedObjectAdds.namedObjectAdds: object expected");
                            message.namedObjectAdds[i] = $root.esriPBuffer.graph.NamedObjectAdd.fromObject(object.namedObjectAdds[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NamedObjectAdds message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @static
                 * @param {esriPBuffer.graph.NamedObjectAdds} message NamedObjectAdds
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedObjectAdds.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.namedObjectAdds = [];
                    if (message.namedObjectAdds && message.namedObjectAdds.length) {
                        object.namedObjectAdds = [];
                        for (var j = 0; j < message.namedObjectAdds.length; ++j)
                            object.namedObjectAdds[j] = $root.esriPBuffer.graph.NamedObjectAdd.toObject(message.namedObjectAdds[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NamedObjectAdds to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NamedObjectAdds
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedObjectAdds.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NamedObjectAdds;
            })();
    
            graph.Adds = (function() {
    
                /**
                 * Properties of an Adds.
                 * @memberof esriPBuffer.graph
                 * @interface IAdds
                 * @property {Object.<string,esriPBuffer.graph.INamedObjectAdds>|null} [entities] Adds entities
                 * @property {Object.<string,esriPBuffer.graph.INamedObjectAdds>|null} [relationships] Adds relationships
                 */
    
                /**
                 * Constructs a new Adds.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an Adds.
                 * @implements IAdds
                 * @constructor
                 * @param {esriPBuffer.graph.IAdds=} [properties] Properties to set
                 */
                function Adds(properties) {
                    this.entities = {};
                    this.relationships = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Adds entities.
                 * @member {Object.<string,esriPBuffer.graph.INamedObjectAdds>} entities
                 * @memberof esriPBuffer.graph.Adds
                 * @instance
                 */
                Adds.prototype.entities = $util.emptyObject;
    
                /**
                 * Adds relationships.
                 * @member {Object.<string,esriPBuffer.graph.INamedObjectAdds>} relationships
                 * @memberof esriPBuffer.graph.Adds
                 * @instance
                 */
                Adds.prototype.relationships = $util.emptyObject;
    
                /**
                 * Creates a new Adds instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {esriPBuffer.graph.IAdds=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Adds} Adds instance
                 */
                Adds.create = function create(properties) {
                    return new Adds(properties);
                };
    
                /**
                 * Encodes the specified Adds message. Does not implicitly {@link esriPBuffer.graph.Adds.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {esriPBuffer.graph.IAdds} message Adds message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Adds.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entities != null && Object.hasOwnProperty.call(message, "entities"))
                        for (var keys = Object.keys(message.entities), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.NamedObjectAdds.encode(message.entities[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.relationships != null && Object.hasOwnProperty.call(message, "relationships"))
                        for (var keys = Object.keys(message.relationships), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.NamedObjectAdds.encode(message.relationships[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified Adds message, length delimited. Does not implicitly {@link esriPBuffer.graph.Adds.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {esriPBuffer.graph.IAdds} message Adds message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Adds.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Adds message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Adds} Adds
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Adds.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Adds(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.entities === $util.emptyObject)
                                message.entities = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.NamedObjectAdds.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.entities[key] = value;
                            break;
                        case 2:
                            if (message.relationships === $util.emptyObject)
                                message.relationships = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.NamedObjectAdds.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.relationships[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Adds message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Adds} Adds
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Adds.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Adds message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Adds.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entities != null && message.hasOwnProperty("entities")) {
                        if (!$util.isObject(message.entities))
                            return "entities: object expected";
                        var key = Object.keys(message.entities);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.NamedObjectAdds.verify(message.entities[key[i]]);
                            if (error)
                                return "entities." + error;
                        }
                    }
                    if (message.relationships != null && message.hasOwnProperty("relationships")) {
                        if (!$util.isObject(message.relationships))
                            return "relationships: object expected";
                        var key = Object.keys(message.relationships);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.NamedObjectAdds.verify(message.relationships[key[i]]);
                            if (error)
                                return "relationships." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Adds message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Adds} Adds
                 */
                Adds.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Adds)
                        return object;
                    var message = new $root.esriPBuffer.graph.Adds();
                    if (object.entities) {
                        if (typeof object.entities !== "object")
                            throw TypeError(".esriPBuffer.graph.Adds.entities: object expected");
                        message.entities = {};
                        for (var keys = Object.keys(object.entities), i = 0; i < keys.length; ++i) {
                            if (typeof object.entities[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.Adds.entities: object expected");
                            message.entities[keys[i]] = $root.esriPBuffer.graph.NamedObjectAdds.fromObject(object.entities[keys[i]]);
                        }
                    }
                    if (object.relationships) {
                        if (typeof object.relationships !== "object")
                            throw TypeError(".esriPBuffer.graph.Adds.relationships: object expected");
                        message.relationships = {};
                        for (var keys = Object.keys(object.relationships), i = 0; i < keys.length; ++i) {
                            if (typeof object.relationships[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.Adds.relationships: object expected");
                            message.relationships[keys[i]] = $root.esriPBuffer.graph.NamedObjectAdds.fromObject(object.relationships[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Adds message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Adds
                 * @static
                 * @param {esriPBuffer.graph.Adds} message Adds
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Adds.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults) {
                        object.entities = {};
                        object.relationships = {};
                    }
                    var keys2;
                    if (message.entities && (keys2 = Object.keys(message.entities)).length) {
                        object.entities = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.entities[keys2[j]] = $root.esriPBuffer.graph.NamedObjectAdds.toObject(message.entities[keys2[j]], options);
                    }
                    if (message.relationships && (keys2 = Object.keys(message.relationships)).length) {
                        object.relationships = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.relationships[keys2[j]] = $root.esriPBuffer.graph.NamedObjectAdds.toObject(message.relationships[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Adds to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Adds
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Adds.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Adds;
            })();
    
            graph.NamedObjectUpdate = (function() {
    
                /**
                 * Properties of a NamedObjectUpdate.
                 * @memberof esriPBuffer.graph
                 * @interface INamedObjectUpdate
                 * @property {number|Long|null} [oid] NamedObjectUpdate oid
                 * @property {Uint8Array|null} [globalid] NamedObjectUpdate globalid
                 * @property {Object.<string,esriPBuffer.graph.IAnyValue>|null} [properties] NamedObjectUpdate properties
                 */
    
                /**
                 * Constructs a new NamedObjectUpdate.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NamedObjectUpdate.
                 * @implements INamedObjectUpdate
                 * @constructor
                 * @param {esriPBuffer.graph.INamedObjectUpdate=} [properties] Properties to set
                 */
                function NamedObjectUpdate(properties) {
                    this.properties = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedObjectUpdate oid.
                 * @member {number|Long|null|undefined} oid
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @instance
                 */
                NamedObjectUpdate.prototype.oid = null;
    
                /**
                 * NamedObjectUpdate globalid.
                 * @member {Uint8Array|null|undefined} globalid
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @instance
                 */
                NamedObjectUpdate.prototype.globalid = null;
    
                /**
                 * NamedObjectUpdate properties.
                 * @member {Object.<string,esriPBuffer.graph.IAnyValue>} properties
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @instance
                 */
                NamedObjectUpdate.prototype.properties = $util.emptyObject;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * NamedObjectUpdate id.
                 * @member {"oid"|"globalid"|undefined} id
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @instance
                 */
                Object.defineProperty(NamedObjectUpdate.prototype, "id", {
                    get: $util.oneOfGetter($oneOfFields = ["oid", "globalid"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NamedObjectUpdate instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectUpdate=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NamedObjectUpdate} NamedObjectUpdate instance
                 */
                NamedObjectUpdate.create = function create(properties) {
                    return new NamedObjectUpdate(properties);
                };
    
                /**
                 * Encodes the specified NamedObjectUpdate message. Does not implicitly {@link esriPBuffer.graph.NamedObjectUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectUpdate} message NamedObjectUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectUpdate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.oid != null && Object.hasOwnProperty.call(message, "oid"))
                        writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.oid);
                    if (message.globalid != null && Object.hasOwnProperty.call(message, "globalid"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.globalid);
                    if (message.properties != null && Object.hasOwnProperty.call(message, "properties"))
                        for (var keys = Object.keys(message.properties), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.AnyValue.encode(message.properties[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified NamedObjectUpdate message, length delimited. Does not implicitly {@link esriPBuffer.graph.NamedObjectUpdate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectUpdate} message NamedObjectUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NamedObjectUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NamedObjectUpdate} NamedObjectUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectUpdate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NamedObjectUpdate(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.oid = reader.sint64();
                            break;
                        case 2:
                            message.globalid = reader.bytes();
                            break;
                        case 3:
                            if (message.properties === $util.emptyObject)
                                message.properties = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.properties[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NamedObjectUpdate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NamedObjectUpdate} NamedObjectUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectUpdate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NamedObjectUpdate message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedObjectUpdate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.oid != null && message.hasOwnProperty("oid")) {
                        properties.id = 1;
                        if (!$util.isInteger(message.oid) && !(message.oid && $util.isInteger(message.oid.low) && $util.isInteger(message.oid.high)))
                            return "oid: integer|Long expected";
                    }
                    if (message.globalid != null && message.hasOwnProperty("globalid")) {
                        if (properties.id === 1)
                            return "id: multiple values";
                        properties.id = 1;
                        if (!(message.globalid && typeof message.globalid.length === "number" || $util.isString(message.globalid)))
                            return "globalid: buffer expected";
                    }
                    if (message.properties != null && message.hasOwnProperty("properties")) {
                        if (!$util.isObject(message.properties))
                            return "properties: object expected";
                        var key = Object.keys(message.properties);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.properties[key[i]]);
                            if (error)
                                return "properties." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NamedObjectUpdate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NamedObjectUpdate} NamedObjectUpdate
                 */
                NamedObjectUpdate.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NamedObjectUpdate)
                        return object;
                    var message = new $root.esriPBuffer.graph.NamedObjectUpdate();
                    if (object.oid != null)
                        if ($util.Long)
                            (message.oid = $util.Long.fromValue(object.oid)).unsigned = false;
                        else if (typeof object.oid === "string")
                            message.oid = parseInt(object.oid, 10);
                        else if (typeof object.oid === "number")
                            message.oid = object.oid;
                        else if (typeof object.oid === "object")
                            message.oid = new $util.LongBits(object.oid.low >>> 0, object.oid.high >>> 0).toNumber();
                    if (object.globalid != null)
                        if (typeof object.globalid === "string")
                            $util.base64.decode(object.globalid, message.globalid = $util.newBuffer($util.base64.length(object.globalid)), 0);
                        else if (object.globalid.length)
                            message.globalid = object.globalid;
                    if (object.properties) {
                        if (typeof object.properties !== "object")
                            throw TypeError(".esriPBuffer.graph.NamedObjectUpdate.properties: object expected");
                        message.properties = {};
                        for (var keys = Object.keys(object.properties), i = 0; i < keys.length; ++i) {
                            if (typeof object.properties[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.NamedObjectUpdate.properties: object expected");
                            message.properties[keys[i]] = $root.esriPBuffer.graph.AnyValue.fromObject(object.properties[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NamedObjectUpdate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @static
                 * @param {esriPBuffer.graph.NamedObjectUpdate} message NamedObjectUpdate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedObjectUpdate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.properties = {};
                    if (message.oid != null && message.hasOwnProperty("oid")) {
                        if (typeof message.oid === "number")
                            object.oid = options.longs === String ? String(message.oid) : message.oid;
                        else
                            object.oid = options.longs === String ? $util.Long.prototype.toString.call(message.oid) : options.longs === Number ? new $util.LongBits(message.oid.low >>> 0, message.oid.high >>> 0).toNumber() : message.oid;
                        if (options.oneofs)
                            object.id = "oid";
                    }
                    if (message.globalid != null && message.hasOwnProperty("globalid")) {
                        object.globalid = options.bytes === String ? $util.base64.encode(message.globalid, 0, message.globalid.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalid) : message.globalid;
                        if (options.oneofs)
                            object.id = "globalid";
                    }
                    var keys2;
                    if (message.properties && (keys2 = Object.keys(message.properties)).length) {
                        object.properties = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.properties[keys2[j]] = $root.esriPBuffer.graph.AnyValue.toObject(message.properties[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NamedObjectUpdate to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NamedObjectUpdate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedObjectUpdate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NamedObjectUpdate;
            })();
    
            graph.NamedObjectUpdates = (function() {
    
                /**
                 * Properties of a NamedObjectUpdates.
                 * @memberof esriPBuffer.graph
                 * @interface INamedObjectUpdates
                 * @property {Array.<esriPBuffer.graph.INamedObjectUpdate>|null} [namedObjectUpdates] NamedObjectUpdates namedObjectUpdates
                 */
    
                /**
                 * Constructs a new NamedObjectUpdates.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NamedObjectUpdates.
                 * @implements INamedObjectUpdates
                 * @constructor
                 * @param {esriPBuffer.graph.INamedObjectUpdates=} [properties] Properties to set
                 */
                function NamedObjectUpdates(properties) {
                    this.namedObjectUpdates = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedObjectUpdates namedObjectUpdates.
                 * @member {Array.<esriPBuffer.graph.INamedObjectUpdate>} namedObjectUpdates
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @instance
                 */
                NamedObjectUpdates.prototype.namedObjectUpdates = $util.emptyArray;
    
                /**
                 * Creates a new NamedObjectUpdates instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectUpdates=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NamedObjectUpdates} NamedObjectUpdates instance
                 */
                NamedObjectUpdates.create = function create(properties) {
                    return new NamedObjectUpdates(properties);
                };
    
                /**
                 * Encodes the specified NamedObjectUpdates message. Does not implicitly {@link esriPBuffer.graph.NamedObjectUpdates.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectUpdates} message NamedObjectUpdates message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectUpdates.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.namedObjectUpdates != null && message.namedObjectUpdates.length)
                        for (var i = 0; i < message.namedObjectUpdates.length; ++i)
                            $root.esriPBuffer.graph.NamedObjectUpdate.encode(message.namedObjectUpdates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NamedObjectUpdates message, length delimited. Does not implicitly {@link esriPBuffer.graph.NamedObjectUpdates.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectUpdates} message NamedObjectUpdates message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectUpdates.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NamedObjectUpdates message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NamedObjectUpdates} NamedObjectUpdates
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectUpdates.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NamedObjectUpdates();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.namedObjectUpdates && message.namedObjectUpdates.length))
                                message.namedObjectUpdates = [];
                            message.namedObjectUpdates.push($root.esriPBuffer.graph.NamedObjectUpdate.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NamedObjectUpdates message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NamedObjectUpdates} NamedObjectUpdates
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectUpdates.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NamedObjectUpdates message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedObjectUpdates.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.namedObjectUpdates != null && message.hasOwnProperty("namedObjectUpdates")) {
                        if (!Array.isArray(message.namedObjectUpdates))
                            return "namedObjectUpdates: array expected";
                        for (var i = 0; i < message.namedObjectUpdates.length; ++i) {
                            var error = $root.esriPBuffer.graph.NamedObjectUpdate.verify(message.namedObjectUpdates[i]);
                            if (error)
                                return "namedObjectUpdates." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NamedObjectUpdates message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NamedObjectUpdates} NamedObjectUpdates
                 */
                NamedObjectUpdates.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NamedObjectUpdates)
                        return object;
                    var message = new $root.esriPBuffer.graph.NamedObjectUpdates();
                    if (object.namedObjectUpdates) {
                        if (!Array.isArray(object.namedObjectUpdates))
                            throw TypeError(".esriPBuffer.graph.NamedObjectUpdates.namedObjectUpdates: array expected");
                        message.namedObjectUpdates = [];
                        for (var i = 0; i < object.namedObjectUpdates.length; ++i) {
                            if (typeof object.namedObjectUpdates[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.NamedObjectUpdates.namedObjectUpdates: object expected");
                            message.namedObjectUpdates[i] = $root.esriPBuffer.graph.NamedObjectUpdate.fromObject(object.namedObjectUpdates[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NamedObjectUpdates message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @static
                 * @param {esriPBuffer.graph.NamedObjectUpdates} message NamedObjectUpdates
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedObjectUpdates.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.namedObjectUpdates = [];
                    if (message.namedObjectUpdates && message.namedObjectUpdates.length) {
                        object.namedObjectUpdates = [];
                        for (var j = 0; j < message.namedObjectUpdates.length; ++j)
                            object.namedObjectUpdates[j] = $root.esriPBuffer.graph.NamedObjectUpdate.toObject(message.namedObjectUpdates[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NamedObjectUpdates to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NamedObjectUpdates
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedObjectUpdates.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NamedObjectUpdates;
            })();
    
            graph.Updates = (function() {
    
                /**
                 * Properties of an Updates.
                 * @memberof esriPBuffer.graph
                 * @interface IUpdates
                 * @property {Object.<string,esriPBuffer.graph.INamedObjectUpdates>|null} [entities] Updates entities
                 * @property {Object.<string,esriPBuffer.graph.INamedObjectUpdates>|null} [relationships] Updates relationships
                 */
    
                /**
                 * Constructs a new Updates.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an Updates.
                 * @implements IUpdates
                 * @constructor
                 * @param {esriPBuffer.graph.IUpdates=} [properties] Properties to set
                 */
                function Updates(properties) {
                    this.entities = {};
                    this.relationships = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Updates entities.
                 * @member {Object.<string,esriPBuffer.graph.INamedObjectUpdates>} entities
                 * @memberof esriPBuffer.graph.Updates
                 * @instance
                 */
                Updates.prototype.entities = $util.emptyObject;
    
                /**
                 * Updates relationships.
                 * @member {Object.<string,esriPBuffer.graph.INamedObjectUpdates>} relationships
                 * @memberof esriPBuffer.graph.Updates
                 * @instance
                 */
                Updates.prototype.relationships = $util.emptyObject;
    
                /**
                 * Creates a new Updates instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {esriPBuffer.graph.IUpdates=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Updates} Updates instance
                 */
                Updates.create = function create(properties) {
                    return new Updates(properties);
                };
    
                /**
                 * Encodes the specified Updates message. Does not implicitly {@link esriPBuffer.graph.Updates.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {esriPBuffer.graph.IUpdates} message Updates message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Updates.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entities != null && Object.hasOwnProperty.call(message, "entities"))
                        for (var keys = Object.keys(message.entities), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.NamedObjectUpdates.encode(message.entities[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.relationships != null && Object.hasOwnProperty.call(message, "relationships"))
                        for (var keys = Object.keys(message.relationships), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.NamedObjectUpdates.encode(message.relationships[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified Updates message, length delimited. Does not implicitly {@link esriPBuffer.graph.Updates.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {esriPBuffer.graph.IUpdates} message Updates message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Updates.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Updates message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Updates} Updates
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Updates.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Updates(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.entities === $util.emptyObject)
                                message.entities = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.NamedObjectUpdates.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.entities[key] = value;
                            break;
                        case 2:
                            if (message.relationships === $util.emptyObject)
                                message.relationships = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.NamedObjectUpdates.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.relationships[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Updates message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Updates} Updates
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Updates.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Updates message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Updates.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entities != null && message.hasOwnProperty("entities")) {
                        if (!$util.isObject(message.entities))
                            return "entities: object expected";
                        var key = Object.keys(message.entities);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.NamedObjectUpdates.verify(message.entities[key[i]]);
                            if (error)
                                return "entities." + error;
                        }
                    }
                    if (message.relationships != null && message.hasOwnProperty("relationships")) {
                        if (!$util.isObject(message.relationships))
                            return "relationships: object expected";
                        var key = Object.keys(message.relationships);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.NamedObjectUpdates.verify(message.relationships[key[i]]);
                            if (error)
                                return "relationships." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Updates message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Updates} Updates
                 */
                Updates.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Updates)
                        return object;
                    var message = new $root.esriPBuffer.graph.Updates();
                    if (object.entities) {
                        if (typeof object.entities !== "object")
                            throw TypeError(".esriPBuffer.graph.Updates.entities: object expected");
                        message.entities = {};
                        for (var keys = Object.keys(object.entities), i = 0; i < keys.length; ++i) {
                            if (typeof object.entities[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.Updates.entities: object expected");
                            message.entities[keys[i]] = $root.esriPBuffer.graph.NamedObjectUpdates.fromObject(object.entities[keys[i]]);
                        }
                    }
                    if (object.relationships) {
                        if (typeof object.relationships !== "object")
                            throw TypeError(".esriPBuffer.graph.Updates.relationships: object expected");
                        message.relationships = {};
                        for (var keys = Object.keys(object.relationships), i = 0; i < keys.length; ++i) {
                            if (typeof object.relationships[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.Updates.relationships: object expected");
                            message.relationships[keys[i]] = $root.esriPBuffer.graph.NamedObjectUpdates.fromObject(object.relationships[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Updates message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Updates
                 * @static
                 * @param {esriPBuffer.graph.Updates} message Updates
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Updates.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults) {
                        object.entities = {};
                        object.relationships = {};
                    }
                    var keys2;
                    if (message.entities && (keys2 = Object.keys(message.entities)).length) {
                        object.entities = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.entities[keys2[j]] = $root.esriPBuffer.graph.NamedObjectUpdates.toObject(message.entities[keys2[j]], options);
                    }
                    if (message.relationships && (keys2 = Object.keys(message.relationships)).length) {
                        object.relationships = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.relationships[keys2[j]] = $root.esriPBuffer.graph.NamedObjectUpdates.toObject(message.relationships[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Updates to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Updates
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Updates.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Updates;
            })();
    
            graph.Deletes = (function() {
    
                /**
                 * Properties of a Deletes.
                 * @memberof esriPBuffer.graph
                 * @interface IDeletes
                 * @property {Object.<string,esriPBuffer.IObjectIdentifierSet>|null} [deletedEntityIds] Deletes deletedEntityIds
                 * @property {Object.<string,esriPBuffer.IObjectIdentifierSet>|null} [deletedRelationshipIds] Deletes deletedRelationshipIds
                 */
    
                /**
                 * Constructs a new Deletes.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a Deletes.
                 * @implements IDeletes
                 * @constructor
                 * @param {esriPBuffer.graph.IDeletes=} [properties] Properties to set
                 */
                function Deletes(properties) {
                    this.deletedEntityIds = {};
                    this.deletedRelationshipIds = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Deletes deletedEntityIds.
                 * @member {Object.<string,esriPBuffer.IObjectIdentifierSet>} deletedEntityIds
                 * @memberof esriPBuffer.graph.Deletes
                 * @instance
                 */
                Deletes.prototype.deletedEntityIds = $util.emptyObject;
    
                /**
                 * Deletes deletedRelationshipIds.
                 * @member {Object.<string,esriPBuffer.IObjectIdentifierSet>} deletedRelationshipIds
                 * @memberof esriPBuffer.graph.Deletes
                 * @instance
                 */
                Deletes.prototype.deletedRelationshipIds = $util.emptyObject;
    
                /**
                 * Creates a new Deletes instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {esriPBuffer.graph.IDeletes=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.Deletes} Deletes instance
                 */
                Deletes.create = function create(properties) {
                    return new Deletes(properties);
                };
    
                /**
                 * Encodes the specified Deletes message. Does not implicitly {@link esriPBuffer.graph.Deletes.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {esriPBuffer.graph.IDeletes} message Deletes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Deletes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.deletedEntityIds != null && Object.hasOwnProperty.call(message, "deletedEntityIds"))
                        for (var keys = Object.keys(message.deletedEntityIds), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.ObjectIdentifierSet.encode(message.deletedEntityIds[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.deletedRelationshipIds != null && Object.hasOwnProperty.call(message, "deletedRelationshipIds"))
                        for (var keys = Object.keys(message.deletedRelationshipIds), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.ObjectIdentifierSet.encode(message.deletedRelationshipIds[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified Deletes message, length delimited. Does not implicitly {@link esriPBuffer.graph.Deletes.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {esriPBuffer.graph.IDeletes} message Deletes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Deletes.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Deletes message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.Deletes} Deletes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Deletes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.Deletes(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (message.deletedEntityIds === $util.emptyObject)
                                message.deletedEntityIds = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.ObjectIdentifierSet.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.deletedEntityIds[key] = value;
                            break;
                        case 2:
                            if (message.deletedRelationshipIds === $util.emptyObject)
                                message.deletedRelationshipIds = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.ObjectIdentifierSet.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.deletedRelationshipIds[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Deletes message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.Deletes} Deletes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Deletes.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Deletes message.
                 * @function verify
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Deletes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deletedEntityIds != null && message.hasOwnProperty("deletedEntityIds")) {
                        if (!$util.isObject(message.deletedEntityIds))
                            return "deletedEntityIds: object expected";
                        var key = Object.keys(message.deletedEntityIds);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.ObjectIdentifierSet.verify(message.deletedEntityIds[key[i]]);
                            if (error)
                                return "deletedEntityIds." + error;
                        }
                    }
                    if (message.deletedRelationshipIds != null && message.hasOwnProperty("deletedRelationshipIds")) {
                        if (!$util.isObject(message.deletedRelationshipIds))
                            return "deletedRelationshipIds: object expected";
                        var key = Object.keys(message.deletedRelationshipIds);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.ObjectIdentifierSet.verify(message.deletedRelationshipIds[key[i]]);
                            if (error)
                                return "deletedRelationshipIds." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Deletes message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.Deletes} Deletes
                 */
                Deletes.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.Deletes)
                        return object;
                    var message = new $root.esriPBuffer.graph.Deletes();
                    if (object.deletedEntityIds) {
                        if (typeof object.deletedEntityIds !== "object")
                            throw TypeError(".esriPBuffer.graph.Deletes.deletedEntityIds: object expected");
                        message.deletedEntityIds = {};
                        for (var keys = Object.keys(object.deletedEntityIds), i = 0; i < keys.length; ++i) {
                            if (typeof object.deletedEntityIds[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.Deletes.deletedEntityIds: object expected");
                            message.deletedEntityIds[keys[i]] = $root.esriPBuffer.ObjectIdentifierSet.fromObject(object.deletedEntityIds[keys[i]]);
                        }
                    }
                    if (object.deletedRelationshipIds) {
                        if (typeof object.deletedRelationshipIds !== "object")
                            throw TypeError(".esriPBuffer.graph.Deletes.deletedRelationshipIds: object expected");
                        message.deletedRelationshipIds = {};
                        for (var keys = Object.keys(object.deletedRelationshipIds), i = 0; i < keys.length; ++i) {
                            if (typeof object.deletedRelationshipIds[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.Deletes.deletedRelationshipIds: object expected");
                            message.deletedRelationshipIds[keys[i]] = $root.esriPBuffer.ObjectIdentifierSet.fromObject(object.deletedRelationshipIds[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Deletes message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.Deletes
                 * @static
                 * @param {esriPBuffer.graph.Deletes} message Deletes
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Deletes.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults) {
                        object.deletedEntityIds = {};
                        object.deletedRelationshipIds = {};
                    }
                    var keys2;
                    if (message.deletedEntityIds && (keys2 = Object.keys(message.deletedEntityIds)).length) {
                        object.deletedEntityIds = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.deletedEntityIds[keys2[j]] = $root.esriPBuffer.ObjectIdentifierSet.toObject(message.deletedEntityIds[keys2[j]], options);
                    }
                    if (message.deletedRelationshipIds && (keys2 = Object.keys(message.deletedRelationshipIds)).length) {
                        object.deletedRelationshipIds = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.deletedRelationshipIds[keys2[j]] = $root.esriPBuffer.ObjectIdentifierSet.toObject(message.deletedRelationshipIds[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Deletes to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.Deletes
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Deletes.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Deletes;
            })();
    
            graph.GraphApplyEditsHeader = (function() {
    
                /**
                 * Properties of a GraphApplyEditsHeader.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphApplyEditsHeader
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [spatialReference] GraphApplyEditsHeader spatialReference
                 * @property {boolean|null} [useGlobalIDs] GraphApplyEditsHeader useGlobalIDs
                 * @property {boolean|null} [cascadeDelete] GraphApplyEditsHeader cascadeDelete
                 * @property {esriPBuffer.graph.ITransform|null} [inputTransform] GraphApplyEditsHeader inputTransform
                 */
    
                /**
                 * Constructs a new GraphApplyEditsHeader.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphApplyEditsHeader.
                 * @implements IGraphApplyEditsHeader
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphApplyEditsHeader=} [properties] Properties to set
                 */
                function GraphApplyEditsHeader(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphApplyEditsHeader spatialReference.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} spatialReference
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @instance
                 */
                GraphApplyEditsHeader.prototype.spatialReference = null;
    
                /**
                 * GraphApplyEditsHeader useGlobalIDs.
                 * @member {boolean} useGlobalIDs
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @instance
                 */
                GraphApplyEditsHeader.prototype.useGlobalIDs = false;
    
                /**
                 * GraphApplyEditsHeader cascadeDelete.
                 * @member {boolean} cascadeDelete
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @instance
                 */
                GraphApplyEditsHeader.prototype.cascadeDelete = false;
    
                /**
                 * GraphApplyEditsHeader inputTransform.
                 * @member {esriPBuffer.graph.ITransform|null|undefined} inputTransform
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @instance
                 */
                GraphApplyEditsHeader.prototype.inputTransform = null;
    
                /**
                 * Creates a new GraphApplyEditsHeader instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsHeader=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphApplyEditsHeader} GraphApplyEditsHeader instance
                 */
                GraphApplyEditsHeader.create = function create(properties) {
                    return new GraphApplyEditsHeader(properties);
                };
    
                /**
                 * Encodes the specified GraphApplyEditsHeader message. Does not implicitly {@link esriPBuffer.graph.GraphApplyEditsHeader.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsHeader} message GraphApplyEditsHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphApplyEditsHeader.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.spatialReference != null && Object.hasOwnProperty.call(message, "spatialReference"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.spatialReference, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.useGlobalIDs != null && Object.hasOwnProperty.call(message, "useGlobalIDs"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.useGlobalIDs);
                    if (message.cascadeDelete != null && Object.hasOwnProperty.call(message, "cascadeDelete"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.cascadeDelete);
                    if (message.inputTransform != null && Object.hasOwnProperty.call(message, "inputTransform"))
                        $root.esriPBuffer.graph.Transform.encode(message.inputTransform, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphApplyEditsHeader message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphApplyEditsHeader.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsHeader} message GraphApplyEditsHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphApplyEditsHeader.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphApplyEditsHeader message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphApplyEditsHeader} GraphApplyEditsHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphApplyEditsHeader.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphApplyEditsHeader();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.spatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.useGlobalIDs = reader.bool();
                            break;
                        case 3:
                            message.cascadeDelete = reader.bool();
                            break;
                        case 4:
                            message.inputTransform = $root.esriPBuffer.graph.Transform.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphApplyEditsHeader message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphApplyEditsHeader} GraphApplyEditsHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphApplyEditsHeader.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphApplyEditsHeader message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphApplyEditsHeader.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.spatialReference != null && message.hasOwnProperty("spatialReference")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.spatialReference);
                        if (error)
                            return "spatialReference." + error;
                    }
                    if (message.useGlobalIDs != null && message.hasOwnProperty("useGlobalIDs"))
                        if (typeof message.useGlobalIDs !== "boolean")
                            return "useGlobalIDs: boolean expected";
                    if (message.cascadeDelete != null && message.hasOwnProperty("cascadeDelete"))
                        if (typeof message.cascadeDelete !== "boolean")
                            return "cascadeDelete: boolean expected";
                    if (message.inputTransform != null && message.hasOwnProperty("inputTransform")) {
                        var error = $root.esriPBuffer.graph.Transform.verify(message.inputTransform);
                        if (error)
                            return "inputTransform." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphApplyEditsHeader message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphApplyEditsHeader} GraphApplyEditsHeader
                 */
                GraphApplyEditsHeader.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphApplyEditsHeader)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphApplyEditsHeader();
                    if (object.spatialReference != null) {
                        if (typeof object.spatialReference !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsHeader.spatialReference: object expected");
                        message.spatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.spatialReference);
                    }
                    if (object.useGlobalIDs != null)
                        message.useGlobalIDs = Boolean(object.useGlobalIDs);
                    if (object.cascadeDelete != null)
                        message.cascadeDelete = Boolean(object.cascadeDelete);
                    if (object.inputTransform != null) {
                        if (typeof object.inputTransform !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsHeader.inputTransform: object expected");
                        message.inputTransform = $root.esriPBuffer.graph.Transform.fromObject(object.inputTransform);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphApplyEditsHeader message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @static
                 * @param {esriPBuffer.graph.GraphApplyEditsHeader} message GraphApplyEditsHeader
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphApplyEditsHeader.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.spatialReference = null;
                        object.useGlobalIDs = false;
                        object.cascadeDelete = false;
                        object.inputTransform = null;
                    }
                    if (message.spatialReference != null && message.hasOwnProperty("spatialReference"))
                        object.spatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.spatialReference, options);
                    if (message.useGlobalIDs != null && message.hasOwnProperty("useGlobalIDs"))
                        object.useGlobalIDs = message.useGlobalIDs;
                    if (message.cascadeDelete != null && message.hasOwnProperty("cascadeDelete"))
                        object.cascadeDelete = message.cascadeDelete;
                    if (message.inputTransform != null && message.hasOwnProperty("inputTransform"))
                        object.inputTransform = $root.esriPBuffer.graph.Transform.toObject(message.inputTransform, options);
                    return object;
                };
    
                /**
                 * Converts this GraphApplyEditsHeader to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphApplyEditsHeader
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphApplyEditsHeader.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphApplyEditsHeader;
            })();
    
            graph.GraphApplyEditsFrame = (function() {
    
                /**
                 * Properties of a GraphApplyEditsFrame.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphApplyEditsFrame
                 * @property {esriPBuffer.graph.IAdds|null} [adds] GraphApplyEditsFrame adds
                 * @property {esriPBuffer.graph.IUpdates|null} [updates] GraphApplyEditsFrame updates
                 * @property {esriPBuffer.graph.IDeletes|null} [deletes] GraphApplyEditsFrame deletes
                 */
    
                /**
                 * Constructs a new GraphApplyEditsFrame.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphApplyEditsFrame.
                 * @implements IGraphApplyEditsFrame
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphApplyEditsFrame=} [properties] Properties to set
                 */
                function GraphApplyEditsFrame(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphApplyEditsFrame adds.
                 * @member {esriPBuffer.graph.IAdds|null|undefined} adds
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @instance
                 */
                GraphApplyEditsFrame.prototype.adds = null;
    
                /**
                 * GraphApplyEditsFrame updates.
                 * @member {esriPBuffer.graph.IUpdates|null|undefined} updates
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @instance
                 */
                GraphApplyEditsFrame.prototype.updates = null;
    
                /**
                 * GraphApplyEditsFrame deletes.
                 * @member {esriPBuffer.graph.IDeletes|null|undefined} deletes
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @instance
                 */
                GraphApplyEditsFrame.prototype.deletes = null;
    
                /**
                 * Creates a new GraphApplyEditsFrame instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsFrame=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphApplyEditsFrame} GraphApplyEditsFrame instance
                 */
                GraphApplyEditsFrame.create = function create(properties) {
                    return new GraphApplyEditsFrame(properties);
                };
    
                /**
                 * Encodes the specified GraphApplyEditsFrame message. Does not implicitly {@link esriPBuffer.graph.GraphApplyEditsFrame.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsFrame} message GraphApplyEditsFrame message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphApplyEditsFrame.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.adds != null && Object.hasOwnProperty.call(message, "adds"))
                        $root.esriPBuffer.graph.Adds.encode(message.adds, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.updates != null && Object.hasOwnProperty.call(message, "updates"))
                        $root.esriPBuffer.graph.Updates.encode(message.updates, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.deletes != null && Object.hasOwnProperty.call(message, "deletes"))
                        $root.esriPBuffer.graph.Deletes.encode(message.deletes, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphApplyEditsFrame message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphApplyEditsFrame.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsFrame} message GraphApplyEditsFrame message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphApplyEditsFrame.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphApplyEditsFrame message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphApplyEditsFrame} GraphApplyEditsFrame
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphApplyEditsFrame.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphApplyEditsFrame();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.adds = $root.esriPBuffer.graph.Adds.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.updates = $root.esriPBuffer.graph.Updates.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.deletes = $root.esriPBuffer.graph.Deletes.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphApplyEditsFrame message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphApplyEditsFrame} GraphApplyEditsFrame
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphApplyEditsFrame.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphApplyEditsFrame message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphApplyEditsFrame.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.adds != null && message.hasOwnProperty("adds")) {
                        var error = $root.esriPBuffer.graph.Adds.verify(message.adds);
                        if (error)
                            return "adds." + error;
                    }
                    if (message.updates != null && message.hasOwnProperty("updates")) {
                        var error = $root.esriPBuffer.graph.Updates.verify(message.updates);
                        if (error)
                            return "updates." + error;
                    }
                    if (message.deletes != null && message.hasOwnProperty("deletes")) {
                        var error = $root.esriPBuffer.graph.Deletes.verify(message.deletes);
                        if (error)
                            return "deletes." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphApplyEditsFrame message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphApplyEditsFrame} GraphApplyEditsFrame
                 */
                GraphApplyEditsFrame.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphApplyEditsFrame)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphApplyEditsFrame();
                    if (object.adds != null) {
                        if (typeof object.adds !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsFrame.adds: object expected");
                        message.adds = $root.esriPBuffer.graph.Adds.fromObject(object.adds);
                    }
                    if (object.updates != null) {
                        if (typeof object.updates !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsFrame.updates: object expected");
                        message.updates = $root.esriPBuffer.graph.Updates.fromObject(object.updates);
                    }
                    if (object.deletes != null) {
                        if (typeof object.deletes !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsFrame.deletes: object expected");
                        message.deletes = $root.esriPBuffer.graph.Deletes.fromObject(object.deletes);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphApplyEditsFrame message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @static
                 * @param {esriPBuffer.graph.GraphApplyEditsFrame} message GraphApplyEditsFrame
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphApplyEditsFrame.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.adds = null;
                        object.updates = null;
                        object.deletes = null;
                    }
                    if (message.adds != null && message.hasOwnProperty("adds"))
                        object.adds = $root.esriPBuffer.graph.Adds.toObject(message.adds, options);
                    if (message.updates != null && message.hasOwnProperty("updates"))
                        object.updates = $root.esriPBuffer.graph.Updates.toObject(message.updates, options);
                    if (message.deletes != null && message.hasOwnProperty("deletes"))
                        object.deletes = $root.esriPBuffer.graph.Deletes.toObject(message.deletes, options);
                    return object;
                };
    
                /**
                 * Converts this GraphApplyEditsFrame to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphApplyEditsFrame
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphApplyEditsFrame.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphApplyEditsFrame;
            })();
    
            graph.EditResults = (function() {
    
                /**
                 * Properties of an EditResults.
                 * @memberof esriPBuffer.graph
                 * @interface IEditResults
                 * @property {esriPBuffer.IObjectIdArray|null} [oidArray] EditResults oidArray
                 * @property {Uint8Array|null} [globalidArray] EditResults globalidArray
                 * @property {Object.<string,esriPBuffer.graph.IError>|null} [errors] EditResults errors
                 */
    
                /**
                 * Constructs a new EditResults.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents an EditResults.
                 * @implements IEditResults
                 * @constructor
                 * @param {esriPBuffer.graph.IEditResults=} [properties] Properties to set
                 */
                function EditResults(properties) {
                    this.errors = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * EditResults oidArray.
                 * @member {esriPBuffer.IObjectIdArray|null|undefined} oidArray
                 * @memberof esriPBuffer.graph.EditResults
                 * @instance
                 */
                EditResults.prototype.oidArray = null;
    
                /**
                 * EditResults globalidArray.
                 * @member {Uint8Array} globalidArray
                 * @memberof esriPBuffer.graph.EditResults
                 * @instance
                 */
                EditResults.prototype.globalidArray = $util.newBuffer([]);
    
                /**
                 * EditResults errors.
                 * @member {Object.<string,esriPBuffer.graph.IError>} errors
                 * @memberof esriPBuffer.graph.EditResults
                 * @instance
                 */
                EditResults.prototype.errors = $util.emptyObject;
    
                /**
                 * Creates a new EditResults instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {esriPBuffer.graph.IEditResults=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.EditResults} EditResults instance
                 */
                EditResults.create = function create(properties) {
                    return new EditResults(properties);
                };
    
                /**
                 * Encodes the specified EditResults message. Does not implicitly {@link esriPBuffer.graph.EditResults.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {esriPBuffer.graph.IEditResults} message EditResults message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EditResults.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.oidArray != null && Object.hasOwnProperty.call(message, "oidArray"))
                        $root.esriPBuffer.ObjectIdArray.encode(message.oidArray, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.globalidArray != null && Object.hasOwnProperty.call(message, "globalidArray"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.globalidArray);
                    if (message.errors != null && Object.hasOwnProperty.call(message, "errors"))
                        for (var keys = Object.keys(message.errors), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]);
                            $root.esriPBuffer.graph.Error.encode(message.errors[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified EditResults message, length delimited. Does not implicitly {@link esriPBuffer.graph.EditResults.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {esriPBuffer.graph.IEditResults} message EditResults message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EditResults.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EditResults message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.EditResults} EditResults
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EditResults.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.EditResults(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.oidArray = $root.esriPBuffer.ObjectIdArray.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.globalidArray = reader.bytes();
                            break;
                        case 3:
                            if (message.errors === $util.emptyObject)
                                message.errors = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint64();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.errors[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EditResults message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.EditResults} EditResults
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EditResults.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EditResults message.
                 * @function verify
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EditResults.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.oidArray != null && message.hasOwnProperty("oidArray")) {
                        var error = $root.esriPBuffer.ObjectIdArray.verify(message.oidArray);
                        if (error)
                            return "oidArray." + error;
                    }
                    if (message.globalidArray != null && message.hasOwnProperty("globalidArray"))
                        if (!(message.globalidArray && typeof message.globalidArray.length === "number" || $util.isString(message.globalidArray)))
                            return "globalidArray: buffer expected";
                    if (message.errors != null && message.hasOwnProperty("errors")) {
                        if (!$util.isObject(message.errors))
                            return "errors: object expected";
                        var key = Object.keys(message.errors);
                        for (var i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "errors: integer|Long key{k:uint64} expected";
                            {
                                var error = $root.esriPBuffer.graph.Error.verify(message.errors[key[i]]);
                                if (error)
                                    return "errors." + error;
                            }
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an EditResults message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.EditResults} EditResults
                 */
                EditResults.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.EditResults)
                        return object;
                    var message = new $root.esriPBuffer.graph.EditResults();
                    if (object.oidArray != null) {
                        if (typeof object.oidArray !== "object")
                            throw TypeError(".esriPBuffer.graph.EditResults.oidArray: object expected");
                        message.oidArray = $root.esriPBuffer.ObjectIdArray.fromObject(object.oidArray);
                    }
                    if (object.globalidArray != null)
                        if (typeof object.globalidArray === "string")
                            $util.base64.decode(object.globalidArray, message.globalidArray = $util.newBuffer($util.base64.length(object.globalidArray)), 0);
                        else if (object.globalidArray.length)
                            message.globalidArray = object.globalidArray;
                    if (object.errors) {
                        if (typeof object.errors !== "object")
                            throw TypeError(".esriPBuffer.graph.EditResults.errors: object expected");
                        message.errors = {};
                        for (var keys = Object.keys(object.errors), i = 0; i < keys.length; ++i) {
                            if (typeof object.errors[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.EditResults.errors: object expected");
                            message.errors[keys[i]] = $root.esriPBuffer.graph.Error.fromObject(object.errors[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EditResults message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.EditResults
                 * @static
                 * @param {esriPBuffer.graph.EditResults} message EditResults
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EditResults.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.errors = {};
                    if (options.defaults) {
                        object.oidArray = null;
                        if (options.bytes === String)
                            object.globalidArray = "";
                        else {
                            object.globalidArray = [];
                            if (options.bytes !== Array)
                                object.globalidArray = $util.newBuffer(object.globalidArray);
                        }
                    }
                    if (message.oidArray != null && message.hasOwnProperty("oidArray"))
                        object.oidArray = $root.esriPBuffer.ObjectIdArray.toObject(message.oidArray, options);
                    if (message.globalidArray != null && message.hasOwnProperty("globalidArray"))
                        object.globalidArray = options.bytes === String ? $util.base64.encode(message.globalidArray, 0, message.globalidArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalidArray) : message.globalidArray;
                    var keys2;
                    if (message.errors && (keys2 = Object.keys(message.errors)).length) {
                        object.errors = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.errors[keys2[j]] = $root.esriPBuffer.graph.Error.toObject(message.errors[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this EditResults to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.EditResults
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EditResults.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EditResults;
            })();
    
            graph.CascadingRelationshipDeletes = (function() {
    
                /**
                 * Properties of a CascadingRelationshipDeletes.
                 * @memberof esriPBuffer.graph
                 * @interface ICascadingRelationshipDeletes
                 * @property {esriPBuffer.graph.IEditResults|null} [relationshipDeleteResults] CascadingRelationshipDeletes relationshipDeleteResults
                 * @property {Uint8Array|null} [originEntityGlobalidArray] CascadingRelationshipDeletes originEntityGlobalidArray
                 * @property {Uint8Array|null} [destEntityGlobalidArray] CascadingRelationshipDeletes destEntityGlobalidArray
                 */
    
                /**
                 * Constructs a new CascadingRelationshipDeletes.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a CascadingRelationshipDeletes.
                 * @implements ICascadingRelationshipDeletes
                 * @constructor
                 * @param {esriPBuffer.graph.ICascadingRelationshipDeletes=} [properties] Properties to set
                 */
                function CascadingRelationshipDeletes(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CascadingRelationshipDeletes relationshipDeleteResults.
                 * @member {esriPBuffer.graph.IEditResults|null|undefined} relationshipDeleteResults
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @instance
                 */
                CascadingRelationshipDeletes.prototype.relationshipDeleteResults = null;
    
                /**
                 * CascadingRelationshipDeletes originEntityGlobalidArray.
                 * @member {Uint8Array} originEntityGlobalidArray
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @instance
                 */
                CascadingRelationshipDeletes.prototype.originEntityGlobalidArray = $util.newBuffer([]);
    
                /**
                 * CascadingRelationshipDeletes destEntityGlobalidArray.
                 * @member {Uint8Array} destEntityGlobalidArray
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @instance
                 */
                CascadingRelationshipDeletes.prototype.destEntityGlobalidArray = $util.newBuffer([]);
    
                /**
                 * Creates a new CascadingRelationshipDeletes instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {esriPBuffer.graph.ICascadingRelationshipDeletes=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.CascadingRelationshipDeletes} CascadingRelationshipDeletes instance
                 */
                CascadingRelationshipDeletes.create = function create(properties) {
                    return new CascadingRelationshipDeletes(properties);
                };
    
                /**
                 * Encodes the specified CascadingRelationshipDeletes message. Does not implicitly {@link esriPBuffer.graph.CascadingRelationshipDeletes.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {esriPBuffer.graph.ICascadingRelationshipDeletes} message CascadingRelationshipDeletes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CascadingRelationshipDeletes.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.relationshipDeleteResults != null && Object.hasOwnProperty.call(message, "relationshipDeleteResults"))
                        $root.esriPBuffer.graph.EditResults.encode(message.relationshipDeleteResults, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.originEntityGlobalidArray != null && Object.hasOwnProperty.call(message, "originEntityGlobalidArray"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.originEntityGlobalidArray);
                    if (message.destEntityGlobalidArray != null && Object.hasOwnProperty.call(message, "destEntityGlobalidArray"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.destEntityGlobalidArray);
                    return writer;
                };
    
                /**
                 * Encodes the specified CascadingRelationshipDeletes message, length delimited. Does not implicitly {@link esriPBuffer.graph.CascadingRelationshipDeletes.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {esriPBuffer.graph.ICascadingRelationshipDeletes} message CascadingRelationshipDeletes message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CascadingRelationshipDeletes.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CascadingRelationshipDeletes message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.CascadingRelationshipDeletes} CascadingRelationshipDeletes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CascadingRelationshipDeletes.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.CascadingRelationshipDeletes();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.relationshipDeleteResults = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.originEntityGlobalidArray = reader.bytes();
                            break;
                        case 3:
                            message.destEntityGlobalidArray = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CascadingRelationshipDeletes message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.CascadingRelationshipDeletes} CascadingRelationshipDeletes
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CascadingRelationshipDeletes.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CascadingRelationshipDeletes message.
                 * @function verify
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CascadingRelationshipDeletes.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.relationshipDeleteResults != null && message.hasOwnProperty("relationshipDeleteResults")) {
                        var error = $root.esriPBuffer.graph.EditResults.verify(message.relationshipDeleteResults);
                        if (error)
                            return "relationshipDeleteResults." + error;
                    }
                    if (message.originEntityGlobalidArray != null && message.hasOwnProperty("originEntityGlobalidArray"))
                        if (!(message.originEntityGlobalidArray && typeof message.originEntityGlobalidArray.length === "number" || $util.isString(message.originEntityGlobalidArray)))
                            return "originEntityGlobalidArray: buffer expected";
                    if (message.destEntityGlobalidArray != null && message.hasOwnProperty("destEntityGlobalidArray"))
                        if (!(message.destEntityGlobalidArray && typeof message.destEntityGlobalidArray.length === "number" || $util.isString(message.destEntityGlobalidArray)))
                            return "destEntityGlobalidArray: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a CascadingRelationshipDeletes message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.CascadingRelationshipDeletes} CascadingRelationshipDeletes
                 */
                CascadingRelationshipDeletes.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.CascadingRelationshipDeletes)
                        return object;
                    var message = new $root.esriPBuffer.graph.CascadingRelationshipDeletes();
                    if (object.relationshipDeleteResults != null) {
                        if (typeof object.relationshipDeleteResults !== "object")
                            throw TypeError(".esriPBuffer.graph.CascadingRelationshipDeletes.relationshipDeleteResults: object expected");
                        message.relationshipDeleteResults = $root.esriPBuffer.graph.EditResults.fromObject(object.relationshipDeleteResults);
                    }
                    if (object.originEntityGlobalidArray != null)
                        if (typeof object.originEntityGlobalidArray === "string")
                            $util.base64.decode(object.originEntityGlobalidArray, message.originEntityGlobalidArray = $util.newBuffer($util.base64.length(object.originEntityGlobalidArray)), 0);
                        else if (object.originEntityGlobalidArray.length)
                            message.originEntityGlobalidArray = object.originEntityGlobalidArray;
                    if (object.destEntityGlobalidArray != null)
                        if (typeof object.destEntityGlobalidArray === "string")
                            $util.base64.decode(object.destEntityGlobalidArray, message.destEntityGlobalidArray = $util.newBuffer($util.base64.length(object.destEntityGlobalidArray)), 0);
                        else if (object.destEntityGlobalidArray.length)
                            message.destEntityGlobalidArray = object.destEntityGlobalidArray;
                    return message;
                };
    
                /**
                 * Creates a plain object from a CascadingRelationshipDeletes message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @static
                 * @param {esriPBuffer.graph.CascadingRelationshipDeletes} message CascadingRelationshipDeletes
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CascadingRelationshipDeletes.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.relationshipDeleteResults = null;
                        if (options.bytes === String)
                            object.originEntityGlobalidArray = "";
                        else {
                            object.originEntityGlobalidArray = [];
                            if (options.bytes !== Array)
                                object.originEntityGlobalidArray = $util.newBuffer(object.originEntityGlobalidArray);
                        }
                        if (options.bytes === String)
                            object.destEntityGlobalidArray = "";
                        else {
                            object.destEntityGlobalidArray = [];
                            if (options.bytes !== Array)
                                object.destEntityGlobalidArray = $util.newBuffer(object.destEntityGlobalidArray);
                        }
                    }
                    if (message.relationshipDeleteResults != null && message.hasOwnProperty("relationshipDeleteResults"))
                        object.relationshipDeleteResults = $root.esriPBuffer.graph.EditResults.toObject(message.relationshipDeleteResults, options);
                    if (message.originEntityGlobalidArray != null && message.hasOwnProperty("originEntityGlobalidArray"))
                        object.originEntityGlobalidArray = options.bytes === String ? $util.base64.encode(message.originEntityGlobalidArray, 0, message.originEntityGlobalidArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.originEntityGlobalidArray) : message.originEntityGlobalidArray;
                    if (message.destEntityGlobalidArray != null && message.hasOwnProperty("destEntityGlobalidArray"))
                        object.destEntityGlobalidArray = options.bytes === String ? $util.base64.encode(message.destEntityGlobalidArray, 0, message.destEntityGlobalidArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.destEntityGlobalidArray) : message.destEntityGlobalidArray;
                    return object;
                };
    
                /**
                 * Converts this CascadingRelationshipDeletes to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.CascadingRelationshipDeletes
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CascadingRelationshipDeletes.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CascadingRelationshipDeletes;
            })();
    
            graph.RelationshipTypeSchemaChanges = (function() {
    
                /**
                 * Properties of a RelationshipTypeSchemaChanges.
                 * @memberof esriPBuffer.graph
                 * @interface IRelationshipTypeSchemaChanges
                 * @property {Array.<string>|null} [originEntityTypes] RelationshipTypeSchemaChanges originEntityTypes
                 * @property {Array.<string>|null} [destEntityTypes] RelationshipTypeSchemaChanges destEntityTypes
                 */
    
                /**
                 * Constructs a new RelationshipTypeSchemaChanges.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a RelationshipTypeSchemaChanges.
                 * @implements IRelationshipTypeSchemaChanges
                 * @constructor
                 * @param {esriPBuffer.graph.IRelationshipTypeSchemaChanges=} [properties] Properties to set
                 */
                function RelationshipTypeSchemaChanges(properties) {
                    this.originEntityTypes = [];
                    this.destEntityTypes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RelationshipTypeSchemaChanges originEntityTypes.
                 * @member {Array.<string>} originEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @instance
                 */
                RelationshipTypeSchemaChanges.prototype.originEntityTypes = $util.emptyArray;
    
                /**
                 * RelationshipTypeSchemaChanges destEntityTypes.
                 * @member {Array.<string>} destEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @instance
                 */
                RelationshipTypeSchemaChanges.prototype.destEntityTypes = $util.emptyArray;
    
                /**
                 * Creates a new RelationshipTypeSchemaChanges instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipTypeSchemaChanges=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.RelationshipTypeSchemaChanges} RelationshipTypeSchemaChanges instance
                 */
                RelationshipTypeSchemaChanges.create = function create(properties) {
                    return new RelationshipTypeSchemaChanges(properties);
                };
    
                /**
                 * Encodes the specified RelationshipTypeSchemaChanges message. Does not implicitly {@link esriPBuffer.graph.RelationshipTypeSchemaChanges.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipTypeSchemaChanges} message RelationshipTypeSchemaChanges message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipTypeSchemaChanges.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.originEntityTypes != null && message.originEntityTypes.length)
                        for (var i = 0; i < message.originEntityTypes.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.originEntityTypes[i]);
                    if (message.destEntityTypes != null && message.destEntityTypes.length)
                        for (var i = 0; i < message.destEntityTypes.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.destEntityTypes[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified RelationshipTypeSchemaChanges message, length delimited. Does not implicitly {@link esriPBuffer.graph.RelationshipTypeSchemaChanges.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipTypeSchemaChanges} message RelationshipTypeSchemaChanges message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipTypeSchemaChanges.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RelationshipTypeSchemaChanges message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.RelationshipTypeSchemaChanges} RelationshipTypeSchemaChanges
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipTypeSchemaChanges.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.RelationshipTypeSchemaChanges();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.originEntityTypes && message.originEntityTypes.length))
                                message.originEntityTypes = [];
                            message.originEntityTypes.push(reader.string());
                            break;
                        case 2:
                            if (!(message.destEntityTypes && message.destEntityTypes.length))
                                message.destEntityTypes = [];
                            message.destEntityTypes.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RelationshipTypeSchemaChanges message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.RelationshipTypeSchemaChanges} RelationshipTypeSchemaChanges
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipTypeSchemaChanges.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RelationshipTypeSchemaChanges message.
                 * @function verify
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RelationshipTypeSchemaChanges.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originEntityTypes != null && message.hasOwnProperty("originEntityTypes")) {
                        if (!Array.isArray(message.originEntityTypes))
                            return "originEntityTypes: array expected";
                        for (var i = 0; i < message.originEntityTypes.length; ++i)
                            if (!$util.isString(message.originEntityTypes[i]))
                                return "originEntityTypes: string[] expected";
                    }
                    if (message.destEntityTypes != null && message.hasOwnProperty("destEntityTypes")) {
                        if (!Array.isArray(message.destEntityTypes))
                            return "destEntityTypes: array expected";
                        for (var i = 0; i < message.destEntityTypes.length; ++i)
                            if (!$util.isString(message.destEntityTypes[i]))
                                return "destEntityTypes: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a RelationshipTypeSchemaChanges message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.RelationshipTypeSchemaChanges} RelationshipTypeSchemaChanges
                 */
                RelationshipTypeSchemaChanges.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.RelationshipTypeSchemaChanges)
                        return object;
                    var message = new $root.esriPBuffer.graph.RelationshipTypeSchemaChanges();
                    if (object.originEntityTypes) {
                        if (!Array.isArray(object.originEntityTypes))
                            throw TypeError(".esriPBuffer.graph.RelationshipTypeSchemaChanges.originEntityTypes: array expected");
                        message.originEntityTypes = [];
                        for (var i = 0; i < object.originEntityTypes.length; ++i)
                            message.originEntityTypes[i] = String(object.originEntityTypes[i]);
                    }
                    if (object.destEntityTypes) {
                        if (!Array.isArray(object.destEntityTypes))
                            throw TypeError(".esriPBuffer.graph.RelationshipTypeSchemaChanges.destEntityTypes: array expected");
                        message.destEntityTypes = [];
                        for (var i = 0; i < object.destEntityTypes.length; ++i)
                            message.destEntityTypes[i] = String(object.destEntityTypes[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a RelationshipTypeSchemaChanges message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @static
                 * @param {esriPBuffer.graph.RelationshipTypeSchemaChanges} message RelationshipTypeSchemaChanges
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RelationshipTypeSchemaChanges.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.originEntityTypes = [];
                        object.destEntityTypes = [];
                    }
                    if (message.originEntityTypes && message.originEntityTypes.length) {
                        object.originEntityTypes = [];
                        for (var j = 0; j < message.originEntityTypes.length; ++j)
                            object.originEntityTypes[j] = message.originEntityTypes[j];
                    }
                    if (message.destEntityTypes && message.destEntityTypes.length) {
                        object.destEntityTypes = [];
                        for (var j = 0; j < message.destEntityTypes.length; ++j)
                            object.destEntityTypes[j] = message.destEntityTypes[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this RelationshipTypeSchemaChanges to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.RelationshipTypeSchemaChanges
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RelationshipTypeSchemaChanges.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RelationshipTypeSchemaChanges;
            })();
    
            graph.GraphApplyEditsResult = (function() {
    
                /**
                 * Properties of a GraphApplyEditsResult.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphApplyEditsResult
                 * @property {esriPBuffer.graph.IError|null} [error] GraphApplyEditsResult error
                 * @property {Object.<string,esriPBuffer.graph.IEditResults>|null} [entityAddResults] GraphApplyEditsResult entityAddResults
                 * @property {Object.<string,esriPBuffer.graph.IEditResults>|null} [relationshipAddResults] GraphApplyEditsResult relationshipAddResults
                 * @property {Object.<string,esriPBuffer.graph.IEditResults>|null} [entityUpdateResults] GraphApplyEditsResult entityUpdateResults
                 * @property {Object.<string,esriPBuffer.graph.IEditResults>|null} [relationshipUpdateResults] GraphApplyEditsResult relationshipUpdateResults
                 * @property {Object.<string,esriPBuffer.graph.IEditResults>|null} [entityDeleteResults] GraphApplyEditsResult entityDeleteResults
                 * @property {Object.<string,esriPBuffer.graph.IEditResults>|null} [relationshipDeleteResults] GraphApplyEditsResult relationshipDeleteResults
                 * @property {Object.<string,esriPBuffer.graph.ICascadingRelationshipDeletes>|null} [cascadingRelationshipDeleteResults] GraphApplyEditsResult cascadingRelationshipDeleteResults
                 * @property {Object.<string,esriPBuffer.graph.IRelationshipTypeSchemaChanges>|null} [relTypeSchemaChanges] GraphApplyEditsResult relTypeSchemaChanges
                 */
    
                /**
                 * Constructs a new GraphApplyEditsResult.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphApplyEditsResult.
                 * @implements IGraphApplyEditsResult
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphApplyEditsResult=} [properties] Properties to set
                 */
                function GraphApplyEditsResult(properties) {
                    this.entityAddResults = {};
                    this.relationshipAddResults = {};
                    this.entityUpdateResults = {};
                    this.relationshipUpdateResults = {};
                    this.entityDeleteResults = {};
                    this.relationshipDeleteResults = {};
                    this.cascadingRelationshipDeleteResults = {};
                    this.relTypeSchemaChanges = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphApplyEditsResult error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.error = null;
    
                /**
                 * GraphApplyEditsResult entityAddResults.
                 * @member {Object.<string,esriPBuffer.graph.IEditResults>} entityAddResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.entityAddResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult relationshipAddResults.
                 * @member {Object.<string,esriPBuffer.graph.IEditResults>} relationshipAddResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.relationshipAddResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult entityUpdateResults.
                 * @member {Object.<string,esriPBuffer.graph.IEditResults>} entityUpdateResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.entityUpdateResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult relationshipUpdateResults.
                 * @member {Object.<string,esriPBuffer.graph.IEditResults>} relationshipUpdateResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.relationshipUpdateResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult entityDeleteResults.
                 * @member {Object.<string,esriPBuffer.graph.IEditResults>} entityDeleteResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.entityDeleteResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult relationshipDeleteResults.
                 * @member {Object.<string,esriPBuffer.graph.IEditResults>} relationshipDeleteResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.relationshipDeleteResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult cascadingRelationshipDeleteResults.
                 * @member {Object.<string,esriPBuffer.graph.ICascadingRelationshipDeletes>} cascadingRelationshipDeleteResults
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.cascadingRelationshipDeleteResults = $util.emptyObject;
    
                /**
                 * GraphApplyEditsResult relTypeSchemaChanges.
                 * @member {Object.<string,esriPBuffer.graph.IRelationshipTypeSchemaChanges>} relTypeSchemaChanges
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 */
                GraphApplyEditsResult.prototype.relTypeSchemaChanges = $util.emptyObject;
    
                /**
                 * Creates a new GraphApplyEditsResult instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsResult=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphApplyEditsResult} GraphApplyEditsResult instance
                 */
                GraphApplyEditsResult.create = function create(properties) {
                    return new GraphApplyEditsResult(properties);
                };
    
                /**
                 * Encodes the specified GraphApplyEditsResult message. Does not implicitly {@link esriPBuffer.graph.GraphApplyEditsResult.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsResult} message GraphApplyEditsResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphApplyEditsResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.entityAddResults != null && Object.hasOwnProperty.call(message, "entityAddResults"))
                        for (var keys = Object.keys(message.entityAddResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.EditResults.encode(message.entityAddResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.relationshipAddResults != null && Object.hasOwnProperty.call(message, "relationshipAddResults"))
                        for (var keys = Object.keys(message.relationshipAddResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.EditResults.encode(message.relationshipAddResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.entityUpdateResults != null && Object.hasOwnProperty.call(message, "entityUpdateResults"))
                        for (var keys = Object.keys(message.entityUpdateResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.EditResults.encode(message.entityUpdateResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.relationshipUpdateResults != null && Object.hasOwnProperty.call(message, "relationshipUpdateResults"))
                        for (var keys = Object.keys(message.relationshipUpdateResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 5, wireType 2 =*/42).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.EditResults.encode(message.relationshipUpdateResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.entityDeleteResults != null && Object.hasOwnProperty.call(message, "entityDeleteResults"))
                        for (var keys = Object.keys(message.entityDeleteResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 6, wireType 2 =*/50).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.EditResults.encode(message.entityDeleteResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.relationshipDeleteResults != null && Object.hasOwnProperty.call(message, "relationshipDeleteResults"))
                        for (var keys = Object.keys(message.relationshipDeleteResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 7, wireType 2 =*/58).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.EditResults.encode(message.relationshipDeleteResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.cascadingRelationshipDeleteResults != null && Object.hasOwnProperty.call(message, "cascadingRelationshipDeleteResults"))
                        for (var keys = Object.keys(message.cascadingRelationshipDeleteResults), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 8, wireType 2 =*/66).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.CascadingRelationshipDeletes.encode(message.cascadingRelationshipDeleteResults[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.relTypeSchemaChanges != null && Object.hasOwnProperty.call(message, "relTypeSchemaChanges"))
                        for (var keys = Object.keys(message.relTypeSchemaChanges), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 9, wireType 2 =*/74).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.RelationshipTypeSchemaChanges.encode(message.relTypeSchemaChanges[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphApplyEditsResult message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphApplyEditsResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphApplyEditsResult} message GraphApplyEditsResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphApplyEditsResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphApplyEditsResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphApplyEditsResult} GraphApplyEditsResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphApplyEditsResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphApplyEditsResult(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (message.entityAddResults === $util.emptyObject)
                                message.entityAddResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.entityAddResults[key] = value;
                            break;
                        case 3:
                            if (message.relationshipAddResults === $util.emptyObject)
                                message.relationshipAddResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.relationshipAddResults[key] = value;
                            break;
                        case 4:
                            if (message.entityUpdateResults === $util.emptyObject)
                                message.entityUpdateResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.entityUpdateResults[key] = value;
                            break;
                        case 5:
                            if (message.relationshipUpdateResults === $util.emptyObject)
                                message.relationshipUpdateResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.relationshipUpdateResults[key] = value;
                            break;
                        case 6:
                            if (message.entityDeleteResults === $util.emptyObject)
                                message.entityDeleteResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.entityDeleteResults[key] = value;
                            break;
                        case 7:
                            if (message.relationshipDeleteResults === $util.emptyObject)
                                message.relationshipDeleteResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.EditResults.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.relationshipDeleteResults[key] = value;
                            break;
                        case 8:
                            if (message.cascadingRelationshipDeleteResults === $util.emptyObject)
                                message.cascadingRelationshipDeleteResults = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.CascadingRelationshipDeletes.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.cascadingRelationshipDeleteResults[key] = value;
                            break;
                        case 9:
                            if (message.relTypeSchemaChanges === $util.emptyObject)
                                message.relTypeSchemaChanges = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.RelationshipTypeSchemaChanges.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.relTypeSchemaChanges[key] = value;
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphApplyEditsResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphApplyEditsResult} GraphApplyEditsResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphApplyEditsResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphApplyEditsResult message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphApplyEditsResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.entityAddResults != null && message.hasOwnProperty("entityAddResults")) {
                        if (!$util.isObject(message.entityAddResults))
                            return "entityAddResults: object expected";
                        var key = Object.keys(message.entityAddResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.EditResults.verify(message.entityAddResults[key[i]]);
                            if (error)
                                return "entityAddResults." + error;
                        }
                    }
                    if (message.relationshipAddResults != null && message.hasOwnProperty("relationshipAddResults")) {
                        if (!$util.isObject(message.relationshipAddResults))
                            return "relationshipAddResults: object expected";
                        var key = Object.keys(message.relationshipAddResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.EditResults.verify(message.relationshipAddResults[key[i]]);
                            if (error)
                                return "relationshipAddResults." + error;
                        }
                    }
                    if (message.entityUpdateResults != null && message.hasOwnProperty("entityUpdateResults")) {
                        if (!$util.isObject(message.entityUpdateResults))
                            return "entityUpdateResults: object expected";
                        var key = Object.keys(message.entityUpdateResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.EditResults.verify(message.entityUpdateResults[key[i]]);
                            if (error)
                                return "entityUpdateResults." + error;
                        }
                    }
                    if (message.relationshipUpdateResults != null && message.hasOwnProperty("relationshipUpdateResults")) {
                        if (!$util.isObject(message.relationshipUpdateResults))
                            return "relationshipUpdateResults: object expected";
                        var key = Object.keys(message.relationshipUpdateResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.EditResults.verify(message.relationshipUpdateResults[key[i]]);
                            if (error)
                                return "relationshipUpdateResults." + error;
                        }
                    }
                    if (message.entityDeleteResults != null && message.hasOwnProperty("entityDeleteResults")) {
                        if (!$util.isObject(message.entityDeleteResults))
                            return "entityDeleteResults: object expected";
                        var key = Object.keys(message.entityDeleteResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.EditResults.verify(message.entityDeleteResults[key[i]]);
                            if (error)
                                return "entityDeleteResults." + error;
                        }
                    }
                    if (message.relationshipDeleteResults != null && message.hasOwnProperty("relationshipDeleteResults")) {
                        if (!$util.isObject(message.relationshipDeleteResults))
                            return "relationshipDeleteResults: object expected";
                        var key = Object.keys(message.relationshipDeleteResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.EditResults.verify(message.relationshipDeleteResults[key[i]]);
                            if (error)
                                return "relationshipDeleteResults." + error;
                        }
                    }
                    if (message.cascadingRelationshipDeleteResults != null && message.hasOwnProperty("cascadingRelationshipDeleteResults")) {
                        if (!$util.isObject(message.cascadingRelationshipDeleteResults))
                            return "cascadingRelationshipDeleteResults: object expected";
                        var key = Object.keys(message.cascadingRelationshipDeleteResults);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.CascadingRelationshipDeletes.verify(message.cascadingRelationshipDeleteResults[key[i]]);
                            if (error)
                                return "cascadingRelationshipDeleteResults." + error;
                        }
                    }
                    if (message.relTypeSchemaChanges != null && message.hasOwnProperty("relTypeSchemaChanges")) {
                        if (!$util.isObject(message.relTypeSchemaChanges))
                            return "relTypeSchemaChanges: object expected";
                        var key = Object.keys(message.relTypeSchemaChanges);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.RelationshipTypeSchemaChanges.verify(message.relTypeSchemaChanges[key[i]]);
                            if (error)
                                return "relTypeSchemaChanges." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphApplyEditsResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphApplyEditsResult} GraphApplyEditsResult
                 */
                GraphApplyEditsResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphApplyEditsResult)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphApplyEditsResult();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.entityAddResults) {
                        if (typeof object.entityAddResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.entityAddResults: object expected");
                        message.entityAddResults = {};
                        for (var keys = Object.keys(object.entityAddResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.entityAddResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.entityAddResults: object expected");
                            message.entityAddResults[keys[i]] = $root.esriPBuffer.graph.EditResults.fromObject(object.entityAddResults[keys[i]]);
                        }
                    }
                    if (object.relationshipAddResults) {
                        if (typeof object.relationshipAddResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relationshipAddResults: object expected");
                        message.relationshipAddResults = {};
                        for (var keys = Object.keys(object.relationshipAddResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.relationshipAddResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relationshipAddResults: object expected");
                            message.relationshipAddResults[keys[i]] = $root.esriPBuffer.graph.EditResults.fromObject(object.relationshipAddResults[keys[i]]);
                        }
                    }
                    if (object.entityUpdateResults) {
                        if (typeof object.entityUpdateResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.entityUpdateResults: object expected");
                        message.entityUpdateResults = {};
                        for (var keys = Object.keys(object.entityUpdateResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.entityUpdateResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.entityUpdateResults: object expected");
                            message.entityUpdateResults[keys[i]] = $root.esriPBuffer.graph.EditResults.fromObject(object.entityUpdateResults[keys[i]]);
                        }
                    }
                    if (object.relationshipUpdateResults) {
                        if (typeof object.relationshipUpdateResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relationshipUpdateResults: object expected");
                        message.relationshipUpdateResults = {};
                        for (var keys = Object.keys(object.relationshipUpdateResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.relationshipUpdateResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relationshipUpdateResults: object expected");
                            message.relationshipUpdateResults[keys[i]] = $root.esriPBuffer.graph.EditResults.fromObject(object.relationshipUpdateResults[keys[i]]);
                        }
                    }
                    if (object.entityDeleteResults) {
                        if (typeof object.entityDeleteResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.entityDeleteResults: object expected");
                        message.entityDeleteResults = {};
                        for (var keys = Object.keys(object.entityDeleteResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.entityDeleteResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.entityDeleteResults: object expected");
                            message.entityDeleteResults[keys[i]] = $root.esriPBuffer.graph.EditResults.fromObject(object.entityDeleteResults[keys[i]]);
                        }
                    }
                    if (object.relationshipDeleteResults) {
                        if (typeof object.relationshipDeleteResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relationshipDeleteResults: object expected");
                        message.relationshipDeleteResults = {};
                        for (var keys = Object.keys(object.relationshipDeleteResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.relationshipDeleteResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relationshipDeleteResults: object expected");
                            message.relationshipDeleteResults[keys[i]] = $root.esriPBuffer.graph.EditResults.fromObject(object.relationshipDeleteResults[keys[i]]);
                        }
                    }
                    if (object.cascadingRelationshipDeleteResults) {
                        if (typeof object.cascadingRelationshipDeleteResults !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.cascadingRelationshipDeleteResults: object expected");
                        message.cascadingRelationshipDeleteResults = {};
                        for (var keys = Object.keys(object.cascadingRelationshipDeleteResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.cascadingRelationshipDeleteResults[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.cascadingRelationshipDeleteResults: object expected");
                            message.cascadingRelationshipDeleteResults[keys[i]] = $root.esriPBuffer.graph.CascadingRelationshipDeletes.fromObject(object.cascadingRelationshipDeleteResults[keys[i]]);
                        }
                    }
                    if (object.relTypeSchemaChanges) {
                        if (typeof object.relTypeSchemaChanges !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relTypeSchemaChanges: object expected");
                        message.relTypeSchemaChanges = {};
                        for (var keys = Object.keys(object.relTypeSchemaChanges), i = 0; i < keys.length; ++i) {
                            if (typeof object.relTypeSchemaChanges[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphApplyEditsResult.relTypeSchemaChanges: object expected");
                            message.relTypeSchemaChanges[keys[i]] = $root.esriPBuffer.graph.RelationshipTypeSchemaChanges.fromObject(object.relTypeSchemaChanges[keys[i]]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphApplyEditsResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @static
                 * @param {esriPBuffer.graph.GraphApplyEditsResult} message GraphApplyEditsResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphApplyEditsResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults) {
                        object.entityAddResults = {};
                        object.relationshipAddResults = {};
                        object.entityUpdateResults = {};
                        object.relationshipUpdateResults = {};
                        object.entityDeleteResults = {};
                        object.relationshipDeleteResults = {};
                        object.cascadingRelationshipDeleteResults = {};
                        object.relTypeSchemaChanges = {};
                    }
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    var keys2;
                    if (message.entityAddResults && (keys2 = Object.keys(message.entityAddResults)).length) {
                        object.entityAddResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.entityAddResults[keys2[j]] = $root.esriPBuffer.graph.EditResults.toObject(message.entityAddResults[keys2[j]], options);
                    }
                    if (message.relationshipAddResults && (keys2 = Object.keys(message.relationshipAddResults)).length) {
                        object.relationshipAddResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.relationshipAddResults[keys2[j]] = $root.esriPBuffer.graph.EditResults.toObject(message.relationshipAddResults[keys2[j]], options);
                    }
                    if (message.entityUpdateResults && (keys2 = Object.keys(message.entityUpdateResults)).length) {
                        object.entityUpdateResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.entityUpdateResults[keys2[j]] = $root.esriPBuffer.graph.EditResults.toObject(message.entityUpdateResults[keys2[j]], options);
                    }
                    if (message.relationshipUpdateResults && (keys2 = Object.keys(message.relationshipUpdateResults)).length) {
                        object.relationshipUpdateResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.relationshipUpdateResults[keys2[j]] = $root.esriPBuffer.graph.EditResults.toObject(message.relationshipUpdateResults[keys2[j]], options);
                    }
                    if (message.entityDeleteResults && (keys2 = Object.keys(message.entityDeleteResults)).length) {
                        object.entityDeleteResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.entityDeleteResults[keys2[j]] = $root.esriPBuffer.graph.EditResults.toObject(message.entityDeleteResults[keys2[j]], options);
                    }
                    if (message.relationshipDeleteResults && (keys2 = Object.keys(message.relationshipDeleteResults)).length) {
                        object.relationshipDeleteResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.relationshipDeleteResults[keys2[j]] = $root.esriPBuffer.graph.EditResults.toObject(message.relationshipDeleteResults[keys2[j]], options);
                    }
                    if (message.cascadingRelationshipDeleteResults && (keys2 = Object.keys(message.cascadingRelationshipDeleteResults)).length) {
                        object.cascadingRelationshipDeleteResults = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.cascadingRelationshipDeleteResults[keys2[j]] = $root.esriPBuffer.graph.CascadingRelationshipDeletes.toObject(message.cascadingRelationshipDeleteResults[keys2[j]], options);
                    }
                    if (message.relTypeSchemaChanges && (keys2 = Object.keys(message.relTypeSchemaChanges)).length) {
                        object.relTypeSchemaChanges = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.relTypeSchemaChanges[keys2[j]] = $root.esriPBuffer.graph.RelationshipTypeSchemaChanges.toObject(message.relTypeSchemaChanges[keys2[j]], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphApplyEditsResult to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphApplyEditsResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphApplyEditsResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphApplyEditsResult;
            })();
    
            graph.GraphDomainDeleteResponse = (function() {
    
                /**
                 * Properties of a GraphDomainDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphDomainDeleteResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphDomainDeleteResponse error
                 */
    
                /**
                 * Constructs a new GraphDomainDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphDomainDeleteResponse.
                 * @implements IGraphDomainDeleteResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphDomainDeleteResponse=} [properties] Properties to set
                 */
                function GraphDomainDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphDomainDeleteResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @instance
                 */
                GraphDomainDeleteResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphDomainDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainDeleteResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphDomainDeleteResponse} GraphDomainDeleteResponse instance
                 */
                GraphDomainDeleteResponse.create = function create(properties) {
                    return new GraphDomainDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphDomainDeleteResponse message. Does not implicitly {@link esriPBuffer.graph.GraphDomainDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainDeleteResponse} message GraphDomainDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphDomainDeleteResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphDomainDeleteResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainDeleteResponse} message GraphDomainDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainDeleteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphDomainDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphDomainDeleteResponse} GraphDomainDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphDomainDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphDomainDeleteResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphDomainDeleteResponse} GraphDomainDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainDeleteResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphDomainDeleteResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphDomainDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphDomainDeleteResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphDomainDeleteResponse} GraphDomainDeleteResponse
                 */
                GraphDomainDeleteResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphDomainDeleteResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphDomainDeleteResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphDomainDeleteResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphDomainDeleteResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphDomainDeleteResponse} message GraphDomainDeleteResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphDomainDeleteResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphDomainDeleteResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphDomainDeleteResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphDomainDeleteResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphDomainDeleteResponse;
            })();
    
            graph.GraphPropertyDeleteRequest = (function() {
    
                /**
                 * Properties of a GraphPropertyDeleteRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyDeleteRequest
                 * @property {string|null} [name] GraphPropertyDeleteRequest name
                 */
    
                /**
                 * Constructs a new GraphPropertyDeleteRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyDeleteRequest.
                 * @implements IGraphPropertyDeleteRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteRequest=} [properties] Properties to set
                 */
                function GraphPropertyDeleteRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyDeleteRequest name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @instance
                 */
                GraphPropertyDeleteRequest.prototype.name = "";
    
                /**
                 * Creates a new GraphPropertyDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteRequest} GraphPropertyDeleteRequest instance
                 */
                GraphPropertyDeleteRequest.create = function create(properties) {
                    return new GraphPropertyDeleteRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyDeleteRequest message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteRequest} message GraphPropertyDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyDeleteRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyDeleteRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteRequest} message GraphPropertyDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyDeleteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteRequest} GraphPropertyDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyDeleteRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyDeleteRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteRequest} GraphPropertyDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyDeleteRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyDeleteRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyDeleteRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteRequest} GraphPropertyDeleteRequest
                 */
                GraphPropertyDeleteRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyDeleteRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyDeleteRequest();
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyDeleteRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyDeleteRequest} message GraphPropertyDeleteRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyDeleteRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyDeleteRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyDeleteRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyDeleteRequest;
            })();
    
            graph.GraphPropertyDeleteResponse = (function() {
    
                /**
                 * Properties of a GraphPropertyDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyDeleteResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphPropertyDeleteResponse error
                 */
    
                /**
                 * Constructs a new GraphPropertyDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyDeleteResponse.
                 * @implements IGraphPropertyDeleteResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteResponse=} [properties] Properties to set
                 */
                function GraphPropertyDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyDeleteResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @instance
                 */
                GraphPropertyDeleteResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphPropertyDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteResponse} GraphPropertyDeleteResponse instance
                 */
                GraphPropertyDeleteResponse.create = function create(properties) {
                    return new GraphPropertyDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyDeleteResponse message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteResponse} message GraphPropertyDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyDeleteResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyDeleteResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyDeleteResponse} message GraphPropertyDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyDeleteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteResponse} GraphPropertyDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyDeleteResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteResponse} GraphPropertyDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyDeleteResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyDeleteResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyDeleteResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyDeleteResponse} GraphPropertyDeleteResponse
                 */
                GraphPropertyDeleteResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyDeleteResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyDeleteResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyDeleteResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyDeleteResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyDeleteResponse} message GraphPropertyDeleteResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyDeleteResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyDeleteResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyDeleteResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyDeleteResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyDeleteResponse;
            })();
    
            graph.GraphPropertyIndexDeleteRequest = (function() {
    
                /**
                 * Properties of a GraphPropertyIndexDeleteRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyIndexDeleteRequest
                 * @property {Array.<string>|null} [name] GraphPropertyIndexDeleteRequest name
                 */
    
                /**
                 * Constructs a new GraphPropertyIndexDeleteRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyIndexDeleteRequest.
                 * @implements IGraphPropertyIndexDeleteRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyIndexDeleteRequest=} [properties] Properties to set
                 */
                function GraphPropertyIndexDeleteRequest(properties) {
                    this.name = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyIndexDeleteRequest name.
                 * @member {Array.<string>} name
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @instance
                 */
                GraphPropertyIndexDeleteRequest.prototype.name = $util.emptyArray;
    
                /**
                 * Creates a new GraphPropertyIndexDeleteRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexDeleteRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyIndexDeleteRequest} GraphPropertyIndexDeleteRequest instance
                 */
                GraphPropertyIndexDeleteRequest.create = function create(properties) {
                    return new GraphPropertyIndexDeleteRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexDeleteRequest message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexDeleteRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexDeleteRequest} message GraphPropertyIndexDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexDeleteRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.name.length)
                        for (var i = 0; i < message.name.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyIndexDeleteRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyIndexDeleteRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyIndexDeleteRequest} message GraphPropertyIndexDeleteRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyIndexDeleteRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyIndexDeleteRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyIndexDeleteRequest} GraphPropertyIndexDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexDeleteRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyIndexDeleteRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyIndexDeleteRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyIndexDeleteRequest} GraphPropertyIndexDeleteRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyIndexDeleteRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyIndexDeleteRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyIndexDeleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name")) {
                        if (!Array.isArray(message.name))
                            return "name: array expected";
                        for (var i = 0; i < message.name.length; ++i)
                            if (!$util.isString(message.name[i]))
                                return "name: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyIndexDeleteRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyIndexDeleteRequest} GraphPropertyIndexDeleteRequest
                 */
                GraphPropertyIndexDeleteRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyIndexDeleteRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyIndexDeleteRequest();
                    if (object.name) {
                        if (!Array.isArray(object.name))
                            throw TypeError(".esriPBuffer.graph.GraphPropertyIndexDeleteRequest.name: array expected");
                        message.name = [];
                        for (var i = 0; i < object.name.length; ++i)
                            message.name[i] = String(object.name[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyIndexDeleteRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyIndexDeleteRequest} message GraphPropertyIndexDeleteRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyIndexDeleteRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.name = [];
                    if (message.name && message.name.length) {
                        object.name = [];
                        for (var j = 0; j < message.name.length; ++j)
                            object.name[j] = message.name[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyIndexDeleteRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyIndexDeleteRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyIndexDeleteRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyIndexDeleteRequest;
            })();
    
            graph.GraphIndexDeleteResult = (function() {
    
                /**
                 * Properties of a GraphIndexDeleteResult.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphIndexDeleteResult
                 * @property {string|null} [name] GraphIndexDeleteResult name
                 * @property {esriPBuffer.graph.IError|null} [error] GraphIndexDeleteResult error
                 */
    
                /**
                 * Constructs a new GraphIndexDeleteResult.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphIndexDeleteResult.
                 * @implements IGraphIndexDeleteResult
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResult=} [properties] Properties to set
                 */
                function GraphIndexDeleteResult(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphIndexDeleteResult name.
                 * @member {string} name
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @instance
                 */
                GraphIndexDeleteResult.prototype.name = "";
    
                /**
                 * GraphIndexDeleteResult error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @instance
                 */
                GraphIndexDeleteResult.prototype.error = null;
    
                /**
                 * Creates a new GraphIndexDeleteResult instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResult=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResult} GraphIndexDeleteResult instance
                 */
                GraphIndexDeleteResult.create = function create(properties) {
                    return new GraphIndexDeleteResult(properties);
                };
    
                /**
                 * Encodes the specified GraphIndexDeleteResult message. Does not implicitly {@link esriPBuffer.graph.GraphIndexDeleteResult.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResult} message GraphIndexDeleteResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphIndexDeleteResult.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphIndexDeleteResult message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphIndexDeleteResult.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResult} message GraphIndexDeleteResult message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphIndexDeleteResult.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphIndexDeleteResult message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResult} GraphIndexDeleteResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphIndexDeleteResult.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphIndexDeleteResult();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphIndexDeleteResult message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResult} GraphIndexDeleteResult
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphIndexDeleteResult.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphIndexDeleteResult message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphIndexDeleteResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphIndexDeleteResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResult} GraphIndexDeleteResult
                 */
                GraphIndexDeleteResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphIndexDeleteResult)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphIndexDeleteResult();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphIndexDeleteResult.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphIndexDeleteResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @static
                 * @param {esriPBuffer.graph.GraphIndexDeleteResult} message GraphIndexDeleteResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphIndexDeleteResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.error = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphIndexDeleteResult to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphIndexDeleteResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphIndexDeleteResult;
            })();
    
            graph.GraphIndexDeleteResponse = (function() {
    
                /**
                 * Properties of a GraphIndexDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphIndexDeleteResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphIndexDeleteResponse error
                 * @property {Array.<esriPBuffer.graph.IGraphIndexDeleteResult>|null} [indexDeleteResults] GraphIndexDeleteResponse indexDeleteResults
                 */
    
                /**
                 * Constructs a new GraphIndexDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphIndexDeleteResponse.
                 * @implements IGraphIndexDeleteResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResponse=} [properties] Properties to set
                 */
                function GraphIndexDeleteResponse(properties) {
                    this.indexDeleteResults = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphIndexDeleteResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @instance
                 */
                GraphIndexDeleteResponse.prototype.error = null;
    
                /**
                 * GraphIndexDeleteResponse indexDeleteResults.
                 * @member {Array.<esriPBuffer.graph.IGraphIndexDeleteResult>} indexDeleteResults
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @instance
                 */
                GraphIndexDeleteResponse.prototype.indexDeleteResults = $util.emptyArray;
    
                /**
                 * Creates a new GraphIndexDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResponse} GraphIndexDeleteResponse instance
                 */
                GraphIndexDeleteResponse.create = function create(properties) {
                    return new GraphIndexDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphIndexDeleteResponse message. Does not implicitly {@link esriPBuffer.graph.GraphIndexDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResponse} message GraphIndexDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphIndexDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.indexDeleteResults != null && message.indexDeleteResults.length)
                        for (var i = 0; i < message.indexDeleteResults.length; ++i)
                            $root.esriPBuffer.graph.GraphIndexDeleteResult.encode(message.indexDeleteResults[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphIndexDeleteResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphIndexDeleteResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphIndexDeleteResponse} message GraphIndexDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphIndexDeleteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphIndexDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResponse} GraphIndexDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphIndexDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphIndexDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.indexDeleteResults && message.indexDeleteResults.length))
                                message.indexDeleteResults = [];
                            message.indexDeleteResults.push($root.esriPBuffer.graph.GraphIndexDeleteResult.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphIndexDeleteResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResponse} GraphIndexDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphIndexDeleteResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphIndexDeleteResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphIndexDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.indexDeleteResults != null && message.hasOwnProperty("indexDeleteResults")) {
                        if (!Array.isArray(message.indexDeleteResults))
                            return "indexDeleteResults: array expected";
                        for (var i = 0; i < message.indexDeleteResults.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphIndexDeleteResult.verify(message.indexDeleteResults[i]);
                            if (error)
                                return "indexDeleteResults." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphIndexDeleteResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphIndexDeleteResponse} GraphIndexDeleteResponse
                 */
                GraphIndexDeleteResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphIndexDeleteResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphIndexDeleteResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphIndexDeleteResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.indexDeleteResults) {
                        if (!Array.isArray(object.indexDeleteResults))
                            throw TypeError(".esriPBuffer.graph.GraphIndexDeleteResponse.indexDeleteResults: array expected");
                        message.indexDeleteResults = [];
                        for (var i = 0; i < object.indexDeleteResults.length; ++i) {
                            if (typeof object.indexDeleteResults[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphIndexDeleteResponse.indexDeleteResults: object expected");
                            message.indexDeleteResults[i] = $root.esriPBuffer.graph.GraphIndexDeleteResult.fromObject(object.indexDeleteResults[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphIndexDeleteResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphIndexDeleteResponse} message GraphIndexDeleteResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphIndexDeleteResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.indexDeleteResults = [];
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    if (message.indexDeleteResults && message.indexDeleteResults.length) {
                        object.indexDeleteResults = [];
                        for (var j = 0; j < message.indexDeleteResults.length; ++j)
                            object.indexDeleteResults[j] = $root.esriPBuffer.graph.GraphIndexDeleteResult.toObject(message.indexDeleteResults[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphIndexDeleteResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphIndexDeleteResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphIndexDeleteResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphIndexDeleteResponse;
            })();
    
            graph.GraphNamedObjectTypeDeleteResponse = (function() {
    
                /**
                 * Properties of a GraphNamedObjectTypeDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphNamedObjectTypeDeleteResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphNamedObjectTypeDeleteResponse error
                 */
    
                /**
                 * Constructs a new GraphNamedObjectTypeDeleteResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphNamedObjectTypeDeleteResponse.
                 * @implements IGraphNamedObjectTypeDeleteResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeDeleteResponse=} [properties] Properties to set
                 */
                function GraphNamedObjectTypeDeleteResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphNamedObjectTypeDeleteResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @instance
                 */
                GraphNamedObjectTypeDeleteResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphNamedObjectTypeDeleteResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeDeleteResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse} GraphNamedObjectTypeDeleteResponse instance
                 */
                GraphNamedObjectTypeDeleteResponse.create = function create(properties) {
                    return new GraphNamedObjectTypeDeleteResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeDeleteResponse message. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeDeleteResponse} message GraphNamedObjectTypeDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeDeleteResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeDeleteResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeDeleteResponse} message GraphNamedObjectTypeDeleteResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeDeleteResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeDeleteResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse} GraphNamedObjectTypeDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeDeleteResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeDeleteResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse} GraphNamedObjectTypeDeleteResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeDeleteResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphNamedObjectTypeDeleteResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphNamedObjectTypeDeleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphNamedObjectTypeDeleteResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse} GraphNamedObjectTypeDeleteResponse
                 */
                GraphNamedObjectTypeDeleteResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphNamedObjectTypeDeleteResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse} message GraphNamedObjectTypeDeleteResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphNamedObjectTypeDeleteResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphNamedObjectTypeDeleteResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeDeleteResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphNamedObjectTypeDeleteResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphNamedObjectTypeDeleteResponse;
            })();
    
            graph.GraphDataModel = (function() {
    
                /**
                 * Properties of a GraphDataModel.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphDataModel
                 * @property {number|Long|null} [dataModelTimestamp] GraphDataModel dataModelTimestamp
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [spatialReference] GraphDataModel spatialReference
                 * @property {Array.<esriPBuffer.EsriTypes.IDomain>|null} [domains] GraphDataModel domains
                 * @property {Array.<esriPBuffer.graph.IEntityType>|null} [entityTypes] GraphDataModel entityTypes
                 * @property {Array.<esriPBuffer.graph.IRelationshipType>|null} [relationshipTypes] GraphDataModel relationshipTypes
                 * @property {boolean|null} [strict] GraphDataModel strict
                 * @property {string|null} [objectidProperty] GraphDataModel objectidProperty
                 * @property {string|null} [globalidProperty] GraphDataModel globalidProperty
                 * @property {string|null} [originEntityGlobalidProperty] GraphDataModel originEntityGlobalidProperty
                 * @property {string|null} [destEntityGlobalidProperty] GraphDataModel destEntityGlobalidProperty
                 * @property {esriPBuffer.graph.IGraphDocumentEntityTypeInfo|null} [docEntityTypeInfo] GraphDataModel docEntityTypeInfo
                 */
    
                /**
                 * Constructs a new GraphDataModel.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphDataModel.
                 * @implements IGraphDataModel
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphDataModel=} [properties] Properties to set
                 */
                function GraphDataModel(properties) {
                    this.domains = [];
                    this.entityTypes = [];
                    this.relationshipTypes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphDataModel dataModelTimestamp.
                 * @member {number|Long} dataModelTimestamp
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.dataModelTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * GraphDataModel spatialReference.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} spatialReference
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.spatialReference = null;
    
                /**
                 * GraphDataModel domains.
                 * @member {Array.<esriPBuffer.EsriTypes.IDomain>} domains
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.domains = $util.emptyArray;
    
                /**
                 * GraphDataModel entityTypes.
                 * @member {Array.<esriPBuffer.graph.IEntityType>} entityTypes
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.entityTypes = $util.emptyArray;
    
                /**
                 * GraphDataModel relationshipTypes.
                 * @member {Array.<esriPBuffer.graph.IRelationshipType>} relationshipTypes
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.relationshipTypes = $util.emptyArray;
    
                /**
                 * GraphDataModel strict.
                 * @member {boolean} strict
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.strict = false;
    
                /**
                 * GraphDataModel objectidProperty.
                 * @member {string} objectidProperty
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.objectidProperty = "";
    
                /**
                 * GraphDataModel globalidProperty.
                 * @member {string} globalidProperty
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.globalidProperty = "";
    
                /**
                 * GraphDataModel originEntityGlobalidProperty.
                 * @member {string} originEntityGlobalidProperty
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.originEntityGlobalidProperty = "";
    
                /**
                 * GraphDataModel destEntityGlobalidProperty.
                 * @member {string} destEntityGlobalidProperty
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.destEntityGlobalidProperty = "";
    
                /**
                 * GraphDataModel docEntityTypeInfo.
                 * @member {esriPBuffer.graph.IGraphDocumentEntityTypeInfo|null|undefined} docEntityTypeInfo
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 */
                GraphDataModel.prototype.docEntityTypeInfo = null;
    
                /**
                 * Creates a new GraphDataModel instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {esriPBuffer.graph.IGraphDataModel=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphDataModel} GraphDataModel instance
                 */
                GraphDataModel.create = function create(properties) {
                    return new GraphDataModel(properties);
                };
    
                /**
                 * Encodes the specified GraphDataModel message. Does not implicitly {@link esriPBuffer.graph.GraphDataModel.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {esriPBuffer.graph.IGraphDataModel} message GraphDataModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDataModel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.dataModelTimestamp != null && Object.hasOwnProperty.call(message, "dataModelTimestamp"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.dataModelTimestamp);
                    if (message.spatialReference != null && Object.hasOwnProperty.call(message, "spatialReference"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.spatialReference, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.domains != null && message.domains.length)
                        for (var i = 0; i < message.domains.length; ++i)
                            $root.esriPBuffer.EsriTypes.Domain.encode(message.domains[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.entityTypes != null && message.entityTypes.length)
                        for (var i = 0; i < message.entityTypes.length; ++i)
                            $root.esriPBuffer.graph.EntityType.encode(message.entityTypes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.relationshipTypes != null && message.relationshipTypes.length)
                        for (var i = 0; i < message.relationshipTypes.length; ++i)
                            $root.esriPBuffer.graph.RelationshipType.encode(message.relationshipTypes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.strict != null && Object.hasOwnProperty.call(message, "strict"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.strict);
                    if (message.objectidProperty != null && Object.hasOwnProperty.call(message, "objectidProperty"))
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.objectidProperty);
                    if (message.globalidProperty != null && Object.hasOwnProperty.call(message, "globalidProperty"))
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.globalidProperty);
                    if (message.originEntityGlobalidProperty != null && Object.hasOwnProperty.call(message, "originEntityGlobalidProperty"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.originEntityGlobalidProperty);
                    if (message.destEntityGlobalidProperty != null && Object.hasOwnProperty.call(message, "destEntityGlobalidProperty"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.destEntityGlobalidProperty);
                    if (message.docEntityTypeInfo != null && Object.hasOwnProperty.call(message, "docEntityTypeInfo"))
                        $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo.encode(message.docEntityTypeInfo, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphDataModel message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphDataModel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {esriPBuffer.graph.IGraphDataModel} message GraphDataModel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDataModel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphDataModel message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphDataModel} GraphDataModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDataModel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphDataModel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.dataModelTimestamp = reader.uint64();
                            break;
                        case 2:
                            message.spatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.domains && message.domains.length))
                                message.domains = [];
                            message.domains.push($root.esriPBuffer.EsriTypes.Domain.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.entityTypes && message.entityTypes.length))
                                message.entityTypes = [];
                            message.entityTypes.push($root.esriPBuffer.graph.EntityType.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.relationshipTypes && message.relationshipTypes.length))
                                message.relationshipTypes = [];
                            message.relationshipTypes.push($root.esriPBuffer.graph.RelationshipType.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            message.strict = reader.bool();
                            break;
                        case 7:
                            message.objectidProperty = reader.string();
                            break;
                        case 8:
                            message.globalidProperty = reader.string();
                            break;
                        case 9:
                            message.originEntityGlobalidProperty = reader.string();
                            break;
                        case 10:
                            message.destEntityGlobalidProperty = reader.string();
                            break;
                        case 11:
                            message.docEntityTypeInfo = $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphDataModel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphDataModel} GraphDataModel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDataModel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphDataModel message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphDataModel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.dataModelTimestamp != null && message.hasOwnProperty("dataModelTimestamp"))
                        if (!$util.isInteger(message.dataModelTimestamp) && !(message.dataModelTimestamp && $util.isInteger(message.dataModelTimestamp.low) && $util.isInteger(message.dataModelTimestamp.high)))
                            return "dataModelTimestamp: integer|Long expected";
                    if (message.spatialReference != null && message.hasOwnProperty("spatialReference")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.spatialReference);
                        if (error)
                            return "spatialReference." + error;
                    }
                    if (message.domains != null && message.hasOwnProperty("domains")) {
                        if (!Array.isArray(message.domains))
                            return "domains: array expected";
                        for (var i = 0; i < message.domains.length; ++i) {
                            var error = $root.esriPBuffer.EsriTypes.Domain.verify(message.domains[i]);
                            if (error)
                                return "domains." + error;
                        }
                    }
                    if (message.entityTypes != null && message.hasOwnProperty("entityTypes")) {
                        if (!Array.isArray(message.entityTypes))
                            return "entityTypes: array expected";
                        for (var i = 0; i < message.entityTypes.length; ++i) {
                            var error = $root.esriPBuffer.graph.EntityType.verify(message.entityTypes[i]);
                            if (error)
                                return "entityTypes." + error;
                        }
                    }
                    if (message.relationshipTypes != null && message.hasOwnProperty("relationshipTypes")) {
                        if (!Array.isArray(message.relationshipTypes))
                            return "relationshipTypes: array expected";
                        for (var i = 0; i < message.relationshipTypes.length; ++i) {
                            var error = $root.esriPBuffer.graph.RelationshipType.verify(message.relationshipTypes[i]);
                            if (error)
                                return "relationshipTypes." + error;
                        }
                    }
                    if (message.strict != null && message.hasOwnProperty("strict"))
                        if (typeof message.strict !== "boolean")
                            return "strict: boolean expected";
                    if (message.objectidProperty != null && message.hasOwnProperty("objectidProperty"))
                        if (!$util.isString(message.objectidProperty))
                            return "objectidProperty: string expected";
                    if (message.globalidProperty != null && message.hasOwnProperty("globalidProperty"))
                        if (!$util.isString(message.globalidProperty))
                            return "globalidProperty: string expected";
                    if (message.originEntityGlobalidProperty != null && message.hasOwnProperty("originEntityGlobalidProperty"))
                        if (!$util.isString(message.originEntityGlobalidProperty))
                            return "originEntityGlobalidProperty: string expected";
                    if (message.destEntityGlobalidProperty != null && message.hasOwnProperty("destEntityGlobalidProperty"))
                        if (!$util.isString(message.destEntityGlobalidProperty))
                            return "destEntityGlobalidProperty: string expected";
                    if (message.docEntityTypeInfo != null && message.hasOwnProperty("docEntityTypeInfo")) {
                        var error = $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo.verify(message.docEntityTypeInfo);
                        if (error)
                            return "docEntityTypeInfo." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphDataModel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphDataModel} GraphDataModel
                 */
                GraphDataModel.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphDataModel)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphDataModel();
                    if (object.dataModelTimestamp != null)
                        if ($util.Long)
                            (message.dataModelTimestamp = $util.Long.fromValue(object.dataModelTimestamp)).unsigned = true;
                        else if (typeof object.dataModelTimestamp === "string")
                            message.dataModelTimestamp = parseInt(object.dataModelTimestamp, 10);
                        else if (typeof object.dataModelTimestamp === "number")
                            message.dataModelTimestamp = object.dataModelTimestamp;
                        else if (typeof object.dataModelTimestamp === "object")
                            message.dataModelTimestamp = new $util.LongBits(object.dataModelTimestamp.low >>> 0, object.dataModelTimestamp.high >>> 0).toNumber(true);
                    if (object.spatialReference != null) {
                        if (typeof object.spatialReference !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphDataModel.spatialReference: object expected");
                        message.spatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.spatialReference);
                    }
                    if (object.domains) {
                        if (!Array.isArray(object.domains))
                            throw TypeError(".esriPBuffer.graph.GraphDataModel.domains: array expected");
                        message.domains = [];
                        for (var i = 0; i < object.domains.length; ++i) {
                            if (typeof object.domains[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphDataModel.domains: object expected");
                            message.domains[i] = $root.esriPBuffer.EsriTypes.Domain.fromObject(object.domains[i]);
                        }
                    }
                    if (object.entityTypes) {
                        if (!Array.isArray(object.entityTypes))
                            throw TypeError(".esriPBuffer.graph.GraphDataModel.entityTypes: array expected");
                        message.entityTypes = [];
                        for (var i = 0; i < object.entityTypes.length; ++i) {
                            if (typeof object.entityTypes[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphDataModel.entityTypes: object expected");
                            message.entityTypes[i] = $root.esriPBuffer.graph.EntityType.fromObject(object.entityTypes[i]);
                        }
                    }
                    if (object.relationshipTypes) {
                        if (!Array.isArray(object.relationshipTypes))
                            throw TypeError(".esriPBuffer.graph.GraphDataModel.relationshipTypes: array expected");
                        message.relationshipTypes = [];
                        for (var i = 0; i < object.relationshipTypes.length; ++i) {
                            if (typeof object.relationshipTypes[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphDataModel.relationshipTypes: object expected");
                            message.relationshipTypes[i] = $root.esriPBuffer.graph.RelationshipType.fromObject(object.relationshipTypes[i]);
                        }
                    }
                    if (object.strict != null)
                        message.strict = Boolean(object.strict);
                    if (object.objectidProperty != null)
                        message.objectidProperty = String(object.objectidProperty);
                    if (object.globalidProperty != null)
                        message.globalidProperty = String(object.globalidProperty);
                    if (object.originEntityGlobalidProperty != null)
                        message.originEntityGlobalidProperty = String(object.originEntityGlobalidProperty);
                    if (object.destEntityGlobalidProperty != null)
                        message.destEntityGlobalidProperty = String(object.destEntityGlobalidProperty);
                    if (object.docEntityTypeInfo != null) {
                        if (typeof object.docEntityTypeInfo !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphDataModel.docEntityTypeInfo: object expected");
                        message.docEntityTypeInfo = $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo.fromObject(object.docEntityTypeInfo);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphDataModel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @static
                 * @param {esriPBuffer.graph.GraphDataModel} message GraphDataModel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphDataModel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.domains = [];
                        object.entityTypes = [];
                        object.relationshipTypes = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.dataModelTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.dataModelTimestamp = options.longs === String ? "0" : 0;
                        object.spatialReference = null;
                        object.strict = false;
                        object.objectidProperty = "";
                        object.globalidProperty = "";
                        object.originEntityGlobalidProperty = "";
                        object.destEntityGlobalidProperty = "";
                        object.docEntityTypeInfo = null;
                    }
                    if (message.dataModelTimestamp != null && message.hasOwnProperty("dataModelTimestamp"))
                        if (typeof message.dataModelTimestamp === "number")
                            object.dataModelTimestamp = options.longs === String ? String(message.dataModelTimestamp) : message.dataModelTimestamp;
                        else
                            object.dataModelTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.dataModelTimestamp) : options.longs === Number ? new $util.LongBits(message.dataModelTimestamp.low >>> 0, message.dataModelTimestamp.high >>> 0).toNumber(true) : message.dataModelTimestamp;
                    if (message.spatialReference != null && message.hasOwnProperty("spatialReference"))
                        object.spatialReference = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.spatialReference, options);
                    if (message.domains && message.domains.length) {
                        object.domains = [];
                        for (var j = 0; j < message.domains.length; ++j)
                            object.domains[j] = $root.esriPBuffer.EsriTypes.Domain.toObject(message.domains[j], options);
                    }
                    if (message.entityTypes && message.entityTypes.length) {
                        object.entityTypes = [];
                        for (var j = 0; j < message.entityTypes.length; ++j)
                            object.entityTypes[j] = $root.esriPBuffer.graph.EntityType.toObject(message.entityTypes[j], options);
                    }
                    if (message.relationshipTypes && message.relationshipTypes.length) {
                        object.relationshipTypes = [];
                        for (var j = 0; j < message.relationshipTypes.length; ++j)
                            object.relationshipTypes[j] = $root.esriPBuffer.graph.RelationshipType.toObject(message.relationshipTypes[j], options);
                    }
                    if (message.strict != null && message.hasOwnProperty("strict"))
                        object.strict = message.strict;
                    if (message.objectidProperty != null && message.hasOwnProperty("objectidProperty"))
                        object.objectidProperty = message.objectidProperty;
                    if (message.globalidProperty != null && message.hasOwnProperty("globalidProperty"))
                        object.globalidProperty = message.globalidProperty;
                    if (message.originEntityGlobalidProperty != null && message.hasOwnProperty("originEntityGlobalidProperty"))
                        object.originEntityGlobalidProperty = message.originEntityGlobalidProperty;
                    if (message.destEntityGlobalidProperty != null && message.hasOwnProperty("destEntityGlobalidProperty"))
                        object.destEntityGlobalidProperty = message.destEntityGlobalidProperty;
                    if (message.docEntityTypeInfo != null && message.hasOwnProperty("docEntityTypeInfo"))
                        object.docEntityTypeInfo = $root.esriPBuffer.graph.GraphDocumentEntityTypeInfo.toObject(message.docEntityTypeInfo, options);
                    return object;
                };
    
                /**
                 * Converts this GraphDataModel to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphDataModel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphDataModel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphDataModel;
            })();
    
            graph.GraphQueryRequest = (function() {
    
                /**
                 * Properties of a GraphQueryRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphQueryRequest
                 * @property {string|null} [openCypherQuery] GraphQueryRequest openCypherQuery
                 * @property {Object.<string,esriPBuffer.graph.IAnyValue>|null} [parameters] GraphQueryRequest parameters
                 * @property {esriPBuffer.EsriTypes.esriFeatureEncoding|null} [featureEncoding] GraphQueryRequest featureEncoding
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [outSr] GraphQueryRequest outSr
                 * @property {esriPBuffer.EsriTypes.IDatumTransformation|null} [datumTransformation] GraphQueryRequest datumTransformation
                 * @property {esriPBuffer.graph.IQuantizationParameters|null} [quantizationParameters] GraphQueryRequest quantizationParameters
                 * @property {esriPBuffer.graph.ITransform|null} [inputTransform] GraphQueryRequest inputTransform
                 */
    
                /**
                 * Constructs a new GraphQueryRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphQueryRequest.
                 * @implements IGraphQueryRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphQueryRequest=} [properties] Properties to set
                 */
                function GraphQueryRequest(properties) {
                    this.parameters = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphQueryRequest openCypherQuery.
                 * @member {string} openCypherQuery
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.openCypherQuery = "";
    
                /**
                 * GraphQueryRequest parameters.
                 * @member {Object.<string,esriPBuffer.graph.IAnyValue>} parameters
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.parameters = $util.emptyObject;
    
                /**
                 * GraphQueryRequest featureEncoding.
                 * @member {esriPBuffer.EsriTypes.esriFeatureEncoding} featureEncoding
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.featureEncoding = 0;
    
                /**
                 * GraphQueryRequest outSr.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} outSr
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.outSr = null;
    
                /**
                 * GraphQueryRequest datumTransformation.
                 * @member {esriPBuffer.EsriTypes.IDatumTransformation|null|undefined} datumTransformation
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.datumTransformation = null;
    
                /**
                 * GraphQueryRequest quantizationParameters.
                 * @member {esriPBuffer.graph.IQuantizationParameters|null|undefined} quantizationParameters
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.quantizationParameters = null;
    
                /**
                 * GraphQueryRequest inputTransform.
                 * @member {esriPBuffer.graph.ITransform|null|undefined} inputTransform
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 */
                GraphQueryRequest.prototype.inputTransform = null;
    
                /**
                 * Creates a new GraphQueryRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphQueryRequest} GraphQueryRequest instance
                 */
                GraphQueryRequest.create = function create(properties) {
                    return new GraphQueryRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphQueryRequest message. Does not implicitly {@link esriPBuffer.graph.GraphQueryRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryRequest} message GraphQueryRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.openCypherQuery != null && Object.hasOwnProperty.call(message, "openCypherQuery"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.openCypherQuery);
                    if (message.parameters != null && Object.hasOwnProperty.call(message, "parameters"))
                        for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.esriPBuffer.graph.AnyValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.featureEncoding != null && Object.hasOwnProperty.call(message, "featureEncoding"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.featureEncoding);
                    if (message.outSr != null && Object.hasOwnProperty.call(message, "outSr"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.outSr, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.datumTransformation != null && Object.hasOwnProperty.call(message, "datumTransformation"))
                        $root.esriPBuffer.EsriTypes.DatumTransformation.encode(message.datumTransformation, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.quantizationParameters != null && Object.hasOwnProperty.call(message, "quantizationParameters"))
                        $root.esriPBuffer.graph.QuantizationParameters.encode(message.quantizationParameters, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.inputTransform != null && Object.hasOwnProperty.call(message, "inputTransform"))
                        $root.esriPBuffer.graph.Transform.encode(message.inputTransform, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphQueryRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphQueryRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryRequest} message GraphQueryRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphQueryRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphQueryRequest} GraphQueryRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphQueryRequest(), key, value;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.openCypherQuery = reader.string();
                            break;
                        case 2:
                            if (message.parameters === $util.emptyObject)
                                message.parameters = {};
                            var end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = null;
                            while (reader.pos < end2) {
                                var tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = $root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.parameters[key] = value;
                            break;
                        case 3:
                            message.featureEncoding = reader.int32();
                            break;
                        case 4:
                            message.outSr = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.datumTransformation = $root.esriPBuffer.EsriTypes.DatumTransformation.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.quantizationParameters = $root.esriPBuffer.graph.QuantizationParameters.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.inputTransform = $root.esriPBuffer.graph.Transform.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphQueryRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphQueryRequest} GraphQueryRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphQueryRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphQueryRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.openCypherQuery != null && message.hasOwnProperty("openCypherQuery"))
                        if (!$util.isString(message.openCypherQuery))
                            return "openCypherQuery: string expected";
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!$util.isObject(message.parameters))
                            return "parameters: object expected";
                        var key = Object.keys(message.parameters);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.parameters[key[i]]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    if (message.featureEncoding != null && message.hasOwnProperty("featureEncoding"))
                        switch (message.featureEncoding) {
                        default:
                            return "featureEncoding: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.outSr != null && message.hasOwnProperty("outSr")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.outSr);
                        if (error)
                            return "outSr." + error;
                    }
                    if (message.datumTransformation != null && message.hasOwnProperty("datumTransformation")) {
                        var error = $root.esriPBuffer.EsriTypes.DatumTransformation.verify(message.datumTransformation);
                        if (error)
                            return "datumTransformation." + error;
                    }
                    if (message.quantizationParameters != null && message.hasOwnProperty("quantizationParameters")) {
                        var error = $root.esriPBuffer.graph.QuantizationParameters.verify(message.quantizationParameters);
                        if (error)
                            return "quantizationParameters." + error;
                    }
                    if (message.inputTransform != null && message.hasOwnProperty("inputTransform")) {
                        var error = $root.esriPBuffer.graph.Transform.verify(message.inputTransform);
                        if (error)
                            return "inputTransform." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphQueryRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphQueryRequest} GraphQueryRequest
                 */
                GraphQueryRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphQueryRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphQueryRequest();
                    if (object.openCypherQuery != null)
                        message.openCypherQuery = String(object.openCypherQuery);
                    if (object.parameters) {
                        if (typeof object.parameters !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryRequest.parameters: object expected");
                        message.parameters = {};
                        for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                            if (typeof object.parameters[keys[i]] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphQueryRequest.parameters: object expected");
                            message.parameters[keys[i]] = $root.esriPBuffer.graph.AnyValue.fromObject(object.parameters[keys[i]]);
                        }
                    }
                    switch (object.featureEncoding) {
                    case "esriFeatureEncoding_UNSPECIFIED":
                    case 0:
                        message.featureEncoding = 0;
                        break;
                    case "esriDefault":
                    case 1:
                        message.featureEncoding = 1;
                        break;
                    case "esriCompressedShapeBuffer":
                    case 2:
                        message.featureEncoding = 2;
                        break;
                    }
                    if (object.outSr != null) {
                        if (typeof object.outSr !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryRequest.outSr: object expected");
                        message.outSr = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.outSr);
                    }
                    if (object.datumTransformation != null) {
                        if (typeof object.datumTransformation !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryRequest.datumTransformation: object expected");
                        message.datumTransformation = $root.esriPBuffer.EsriTypes.DatumTransformation.fromObject(object.datumTransformation);
                    }
                    if (object.quantizationParameters != null) {
                        if (typeof object.quantizationParameters !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryRequest.quantizationParameters: object expected");
                        message.quantizationParameters = $root.esriPBuffer.graph.QuantizationParameters.fromObject(object.quantizationParameters);
                    }
                    if (object.inputTransform != null) {
                        if (typeof object.inputTransform !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryRequest.inputTransform: object expected");
                        message.inputTransform = $root.esriPBuffer.graph.Transform.fromObject(object.inputTransform);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphQueryRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphQueryRequest} message GraphQueryRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphQueryRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.parameters = {};
                    if (options.defaults) {
                        object.openCypherQuery = "";
                        object.featureEncoding = options.enums === String ? "esriFeatureEncoding_UNSPECIFIED" : 0;
                        object.outSr = null;
                        object.datumTransformation = null;
                        object.quantizationParameters = null;
                        object.inputTransform = null;
                    }
                    if (message.openCypherQuery != null && message.hasOwnProperty("openCypherQuery"))
                        object.openCypherQuery = message.openCypherQuery;
                    var keys2;
                    if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                        object.parameters = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.parameters[keys2[j]] = $root.esriPBuffer.graph.AnyValue.toObject(message.parameters[keys2[j]], options);
                    }
                    if (message.featureEncoding != null && message.hasOwnProperty("featureEncoding"))
                        object.featureEncoding = options.enums === String ? $root.esriPBuffer.EsriTypes.esriFeatureEncoding[message.featureEncoding] : message.featureEncoding;
                    if (message.outSr != null && message.hasOwnProperty("outSr"))
                        object.outSr = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.outSr, options);
                    if (message.datumTransformation != null && message.hasOwnProperty("datumTransformation"))
                        object.datumTransformation = $root.esriPBuffer.EsriTypes.DatumTransformation.toObject(message.datumTransformation, options);
                    if (message.quantizationParameters != null && message.hasOwnProperty("quantizationParameters"))
                        object.quantizationParameters = $root.esriPBuffer.graph.QuantizationParameters.toObject(message.quantizationParameters, options);
                    if (message.inputTransform != null && message.hasOwnProperty("inputTransform"))
                        object.inputTransform = $root.esriPBuffer.graph.Transform.toObject(message.inputTransform, options);
                    return object;
                };
    
                /**
                 * Converts this GraphQueryRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphQueryRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphQueryRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphQueryRequest;
            })();
    
            graph.GraphQueryResultHeader = (function() {
    
                /**
                 * Properties of a GraphQueryResultHeader.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphQueryResultHeader
                 * @property {number|Long|null} [dataModelTimestamp] GraphQueryResultHeader dataModelTimestamp
                 * @property {esriPBuffer.graph.ITransform|null} [transform] GraphQueryResultHeader transform
                 * @property {esriPBuffer.graph.IError|null} [error] GraphQueryResultHeader error
                 * @property {Array.<string>|null} [fieldNames] GraphQueryResultHeader fieldNames
                 * @property {boolean|null} [compressedFrames] GraphQueryResultHeader compressedFrames
                 */
    
                /**
                 * Constructs a new GraphQueryResultHeader.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphQueryResultHeader.
                 * @implements IGraphQueryResultHeader
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphQueryResultHeader=} [properties] Properties to set
                 */
                function GraphQueryResultHeader(properties) {
                    this.fieldNames = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphQueryResultHeader dataModelTimestamp.
                 * @member {number|Long} dataModelTimestamp
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @instance
                 */
                GraphQueryResultHeader.prototype.dataModelTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * GraphQueryResultHeader transform.
                 * @member {esriPBuffer.graph.ITransform|null|undefined} transform
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @instance
                 */
                GraphQueryResultHeader.prototype.transform = null;
    
                /**
                 * GraphQueryResultHeader error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @instance
                 */
                GraphQueryResultHeader.prototype.error = null;
    
                /**
                 * GraphQueryResultHeader fieldNames.
                 * @member {Array.<string>} fieldNames
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @instance
                 */
                GraphQueryResultHeader.prototype.fieldNames = $util.emptyArray;
    
                /**
                 * GraphQueryResultHeader compressedFrames.
                 * @member {boolean} compressedFrames
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @instance
                 */
                GraphQueryResultHeader.prototype.compressedFrames = false;
    
                /**
                 * Creates a new GraphQueryResultHeader instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryResultHeader=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphQueryResultHeader} GraphQueryResultHeader instance
                 */
                GraphQueryResultHeader.create = function create(properties) {
                    return new GraphQueryResultHeader(properties);
                };
    
                /**
                 * Encodes the specified GraphQueryResultHeader message. Does not implicitly {@link esriPBuffer.graph.GraphQueryResultHeader.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryResultHeader} message GraphQueryResultHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryResultHeader.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.dataModelTimestamp != null && Object.hasOwnProperty.call(message, "dataModelTimestamp"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.dataModelTimestamp);
                    if (message.transform != null && Object.hasOwnProperty.call(message, "transform"))
                        $root.esriPBuffer.graph.Transform.encode(message.transform, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.fieldNames != null && message.fieldNames.length)
                        for (var i = 0; i < message.fieldNames.length; ++i)
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.fieldNames[i]);
                    if (message.compressedFrames != null && Object.hasOwnProperty.call(message, "compressedFrames"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.compressedFrames);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphQueryResultHeader message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphQueryResultHeader.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryResultHeader} message GraphQueryResultHeader message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryResultHeader.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphQueryResultHeader message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphQueryResultHeader} GraphQueryResultHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryResultHeader.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphQueryResultHeader();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.dataModelTimestamp = reader.uint64();
                            break;
                        case 2:
                            message.transform = $root.esriPBuffer.graph.Transform.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 4:
                            if (!(message.fieldNames && message.fieldNames.length))
                                message.fieldNames = [];
                            message.fieldNames.push(reader.string());
                            break;
                        case 5:
                            message.compressedFrames = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphQueryResultHeader message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphQueryResultHeader} GraphQueryResultHeader
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryResultHeader.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphQueryResultHeader message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphQueryResultHeader.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.dataModelTimestamp != null && message.hasOwnProperty("dataModelTimestamp"))
                        if (!$util.isInteger(message.dataModelTimestamp) && !(message.dataModelTimestamp && $util.isInteger(message.dataModelTimestamp.low) && $util.isInteger(message.dataModelTimestamp.high)))
                            return "dataModelTimestamp: integer|Long expected";
                    if (message.transform != null && message.hasOwnProperty("transform")) {
                        var error = $root.esriPBuffer.graph.Transform.verify(message.transform);
                        if (error)
                            return "transform." + error;
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.fieldNames != null && message.hasOwnProperty("fieldNames")) {
                        if (!Array.isArray(message.fieldNames))
                            return "fieldNames: array expected";
                        for (var i = 0; i < message.fieldNames.length; ++i)
                            if (!$util.isString(message.fieldNames[i]))
                                return "fieldNames: string[] expected";
                    }
                    if (message.compressedFrames != null && message.hasOwnProperty("compressedFrames"))
                        if (typeof message.compressedFrames !== "boolean")
                            return "compressedFrames: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a GraphQueryResultHeader message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphQueryResultHeader} GraphQueryResultHeader
                 */
                GraphQueryResultHeader.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphQueryResultHeader)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphQueryResultHeader();
                    if (object.dataModelTimestamp != null)
                        if ($util.Long)
                            (message.dataModelTimestamp = $util.Long.fromValue(object.dataModelTimestamp)).unsigned = true;
                        else if (typeof object.dataModelTimestamp === "string")
                            message.dataModelTimestamp = parseInt(object.dataModelTimestamp, 10);
                        else if (typeof object.dataModelTimestamp === "number")
                            message.dataModelTimestamp = object.dataModelTimestamp;
                        else if (typeof object.dataModelTimestamp === "object")
                            message.dataModelTimestamp = new $util.LongBits(object.dataModelTimestamp.low >>> 0, object.dataModelTimestamp.high >>> 0).toNumber(true);
                    if (object.transform != null) {
                        if (typeof object.transform !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryResultHeader.transform: object expected");
                        message.transform = $root.esriPBuffer.graph.Transform.fromObject(object.transform);
                    }
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryResultHeader.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.fieldNames) {
                        if (!Array.isArray(object.fieldNames))
                            throw TypeError(".esriPBuffer.graph.GraphQueryResultHeader.fieldNames: array expected");
                        message.fieldNames = [];
                        for (var i = 0; i < object.fieldNames.length; ++i)
                            message.fieldNames[i] = String(object.fieldNames[i]);
                    }
                    if (object.compressedFrames != null)
                        message.compressedFrames = Boolean(object.compressedFrames);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphQueryResultHeader message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @static
                 * @param {esriPBuffer.graph.GraphQueryResultHeader} message GraphQueryResultHeader
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphQueryResultHeader.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.fieldNames = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.dataModelTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.dataModelTimestamp = options.longs === String ? "0" : 0;
                        object.transform = null;
                        object.error = null;
                        object.compressedFrames = false;
                    }
                    if (message.dataModelTimestamp != null && message.hasOwnProperty("dataModelTimestamp"))
                        if (typeof message.dataModelTimestamp === "number")
                            object.dataModelTimestamp = options.longs === String ? String(message.dataModelTimestamp) : message.dataModelTimestamp;
                        else
                            object.dataModelTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.dataModelTimestamp) : options.longs === Number ? new $util.LongBits(message.dataModelTimestamp.low >>> 0, message.dataModelTimestamp.high >>> 0).toNumber(true) : message.dataModelTimestamp;
                    if (message.transform != null && message.hasOwnProperty("transform"))
                        object.transform = $root.esriPBuffer.graph.Transform.toObject(message.transform, options);
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    if (message.fieldNames && message.fieldNames.length) {
                        object.fieldNames = [];
                        for (var j = 0; j < message.fieldNames.length; ++j)
                            object.fieldNames[j] = message.fieldNames[j];
                    }
                    if (message.compressedFrames != null && message.hasOwnProperty("compressedFrames"))
                        object.compressedFrames = message.compressedFrames;
                    return object;
                };
    
                /**
                 * Converts this GraphQueryResultHeader to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphQueryResultHeader
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphQueryResultHeader.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphQueryResultHeader;
            })();
    
            graph.GraphQueryRow = (function() {
    
                /**
                 * Properties of a GraphQueryRow.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphQueryRow
                 * @property {Array.<esriPBuffer.graph.IAnyValue>|null} [values] GraphQueryRow values
                 */
    
                /**
                 * Constructs a new GraphQueryRow.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphQueryRow.
                 * @implements IGraphQueryRow
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphQueryRow=} [properties] Properties to set
                 */
                function GraphQueryRow(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphQueryRow values.
                 * @member {Array.<esriPBuffer.graph.IAnyValue>} values
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @instance
                 */
                GraphQueryRow.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new GraphQueryRow instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryRow=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphQueryRow} GraphQueryRow instance
                 */
                GraphQueryRow.create = function create(properties) {
                    return new GraphQueryRow(properties);
                };
    
                /**
                 * Encodes the specified GraphQueryRow message. Does not implicitly {@link esriPBuffer.graph.GraphQueryRow.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryRow} message GraphQueryRow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryRow.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length)
                        for (var i = 0; i < message.values.length; ++i)
                            $root.esriPBuffer.graph.AnyValue.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphQueryRow message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphQueryRow.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryRow} message GraphQueryRow message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryRow.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphQueryRow message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphQueryRow} GraphQueryRow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryRow.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphQueryRow();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            message.values.push($root.esriPBuffer.graph.AnyValue.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphQueryRow message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphQueryRow} GraphQueryRow
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryRow.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphQueryRow message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphQueryRow.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i) {
                            var error = $root.esriPBuffer.graph.AnyValue.verify(message.values[i]);
                            if (error)
                                return "values." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphQueryRow message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphQueryRow} GraphQueryRow
                 */
                GraphQueryRow.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphQueryRow)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphQueryRow();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".esriPBuffer.graph.GraphQueryRow.values: array expected");
                        message.values = [];
                        for (var i = 0; i < object.values.length; ++i) {
                            if (typeof object.values[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphQueryRow.values: object expected");
                            message.values[i] = $root.esriPBuffer.graph.AnyValue.fromObject(object.values[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphQueryRow message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @static
                 * @param {esriPBuffer.graph.GraphQueryRow} message GraphQueryRow
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphQueryRow.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (var j = 0; j < message.values.length; ++j)
                            object.values[j] = $root.esriPBuffer.graph.AnyValue.toObject(message.values[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphQueryRow to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphQueryRow
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphQueryRow.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphQueryRow;
            })();
    
            graph.GraphQueryResultFrame = (function() {
    
                /**
                 * Properties of a GraphQueryResultFrame.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphQueryResultFrame
                 * @property {esriPBuffer.graph.IError|null} [error] GraphQueryResultFrame error
                 * @property {Array.<esriPBuffer.graph.IGraphQueryRow>|null} [rows] GraphQueryResultFrame rows
                 * @property {boolean|null} [exceededTransferLimit] GraphQueryResultFrame exceededTransferLimit
                 */
    
                /**
                 * Constructs a new GraphQueryResultFrame.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphQueryResultFrame.
                 * @implements IGraphQueryResultFrame
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphQueryResultFrame=} [properties] Properties to set
                 */
                function GraphQueryResultFrame(properties) {
                    this.rows = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphQueryResultFrame error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @instance
                 */
                GraphQueryResultFrame.prototype.error = null;
    
                /**
                 * GraphQueryResultFrame rows.
                 * @member {Array.<esriPBuffer.graph.IGraphQueryRow>} rows
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @instance
                 */
                GraphQueryResultFrame.prototype.rows = $util.emptyArray;
    
                /**
                 * GraphQueryResultFrame exceededTransferLimit.
                 * @member {boolean} exceededTransferLimit
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @instance
                 */
                GraphQueryResultFrame.prototype.exceededTransferLimit = false;
    
                /**
                 * Creates a new GraphQueryResultFrame instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryResultFrame=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphQueryResultFrame} GraphQueryResultFrame instance
                 */
                GraphQueryResultFrame.create = function create(properties) {
                    return new GraphQueryResultFrame(properties);
                };
    
                /**
                 * Encodes the specified GraphQueryResultFrame message. Does not implicitly {@link esriPBuffer.graph.GraphQueryResultFrame.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryResultFrame} message GraphQueryResultFrame message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryResultFrame.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.rows != null && message.rows.length)
                        for (var i = 0; i < message.rows.length; ++i)
                            $root.esriPBuffer.graph.GraphQueryRow.encode(message.rows[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.exceededTransferLimit != null && Object.hasOwnProperty.call(message, "exceededTransferLimit"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.exceededTransferLimit);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphQueryResultFrame message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphQueryResultFrame.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {esriPBuffer.graph.IGraphQueryResultFrame} message GraphQueryResultFrame message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphQueryResultFrame.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphQueryResultFrame message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphQueryResultFrame} GraphQueryResultFrame
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryResultFrame.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphQueryResultFrame();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.esriPBuffer.graph.GraphQueryRow.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.exceededTransferLimit = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphQueryResultFrame message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphQueryResultFrame} GraphQueryResultFrame
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphQueryResultFrame.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphQueryResultFrame message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphQueryResultFrame.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.rows != null && message.hasOwnProperty("rows")) {
                        if (!Array.isArray(message.rows))
                            return "rows: array expected";
                        for (var i = 0; i < message.rows.length; ++i) {
                            var error = $root.esriPBuffer.graph.GraphQueryRow.verify(message.rows[i]);
                            if (error)
                                return "rows." + error;
                        }
                    }
                    if (message.exceededTransferLimit != null && message.hasOwnProperty("exceededTransferLimit"))
                        if (typeof message.exceededTransferLimit !== "boolean")
                            return "exceededTransferLimit: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a GraphQueryResultFrame message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphQueryResultFrame} GraphQueryResultFrame
                 */
                GraphQueryResultFrame.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphQueryResultFrame)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphQueryResultFrame();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphQueryResultFrame.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    if (object.rows) {
                        if (!Array.isArray(object.rows))
                            throw TypeError(".esriPBuffer.graph.GraphQueryResultFrame.rows: array expected");
                        message.rows = [];
                        for (var i = 0; i < object.rows.length; ++i) {
                            if (typeof object.rows[i] !== "object")
                                throw TypeError(".esriPBuffer.graph.GraphQueryResultFrame.rows: object expected");
                            message.rows[i] = $root.esriPBuffer.graph.GraphQueryRow.fromObject(object.rows[i]);
                        }
                    }
                    if (object.exceededTransferLimit != null)
                        message.exceededTransferLimit = Boolean(object.exceededTransferLimit);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphQueryResultFrame message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @static
                 * @param {esriPBuffer.graph.GraphQueryResultFrame} message GraphQueryResultFrame
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphQueryResultFrame.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.rows = [];
                    if (options.defaults) {
                        object.error = null;
                        object.exceededTransferLimit = false;
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    if (message.rows && message.rows.length) {
                        object.rows = [];
                        for (var j = 0; j < message.rows.length; ++j)
                            object.rows[j] = $root.esriPBuffer.graph.GraphQueryRow.toObject(message.rows[j], options);
                    }
                    if (message.exceededTransferLimit != null && message.hasOwnProperty("exceededTransferLimit"))
                        object.exceededTransferLimit = message.exceededTransferLimit;
                    return object;
                };
    
                /**
                 * Converts this GraphQueryResultFrame to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphQueryResultFrame
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphQueryResultFrame.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphQueryResultFrame;
            })();
    
            graph.GraphSearchRequest = (function() {
    
                /**
                 * Properties of a GraphSearchRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphSearchRequest
                 * @property {string|null} [searchQuery] GraphSearchRequest searchQuery
                 * @property {Uint8Array|null} [globalidArray] GraphSearchRequest globalidArray
                 * @property {Array.<string>|null} [namedTypeFilter] GraphSearchRequest namedTypeFilter
                 * @property {esriPBuffer.graph.GraphSearchRequest.esriNamedTypeCategory|null} [typeCategoryFilter] GraphSearchRequest typeCategoryFilter
                 * @property {esriPBuffer.graph.IGeometryValue|null} [spatialFilter] GraphSearchRequest spatialFilter
                 * @property {esriPBuffer.graph.ITransform|null} [inputTransform] GraphSearchRequest inputTransform
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [inputSpatRef] GraphSearchRequest inputSpatRef
                 * @property {esriPBuffer.EsriTypes.esriSpatialRel|null} [spatialRelation] GraphSearchRequest spatialRelation
                 * @property {boolean|null} [returnGeometry] GraphSearchRequest returnGeometry
                 * @property {esriPBuffer.EsriTypes.esriFeatureEncoding|null} [featureEncoding] GraphSearchRequest featureEncoding
                 * @property {esriPBuffer.EsriTypes.ISpatialReference|null} [outSpatRef] GraphSearchRequest outSpatRef
                 * @property {esriPBuffer.EsriTypes.IDatumTransformation|null} [datumTransform] GraphSearchRequest datumTransform
                 * @property {esriPBuffer.graph.IQuantizationParameters|null} [quantizationParams] GraphSearchRequest quantizationParams
                 * @property {number|null} [startIndex] GraphSearchRequest startIndex
                 * @property {number|null} [maxNumResults] GraphSearchRequest maxNumResults
                 * @property {boolean|null} [returnSearchContext] GraphSearchRequest returnSearchContext
                 */
    
                /**
                 * Constructs a new GraphSearchRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphSearchRequest.
                 * @implements IGraphSearchRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphSearchRequest=} [properties] Properties to set
                 */
                function GraphSearchRequest(properties) {
                    this.namedTypeFilter = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphSearchRequest searchQuery.
                 * @member {string} searchQuery
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.searchQuery = "";
    
                /**
                 * GraphSearchRequest globalidArray.
                 * @member {Uint8Array} globalidArray
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.globalidArray = $util.newBuffer([]);
    
                /**
                 * GraphSearchRequest namedTypeFilter.
                 * @member {Array.<string>} namedTypeFilter
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.namedTypeFilter = $util.emptyArray;
    
                /**
                 * GraphSearchRequest typeCategoryFilter.
                 * @member {esriPBuffer.graph.GraphSearchRequest.esriNamedTypeCategory} typeCategoryFilter
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.typeCategoryFilter = 0;
    
                /**
                 * GraphSearchRequest spatialFilter.
                 * @member {esriPBuffer.graph.IGeometryValue|null|undefined} spatialFilter
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.spatialFilter = null;
    
                /**
                 * GraphSearchRequest inputTransform.
                 * @member {esriPBuffer.graph.ITransform|null|undefined} inputTransform
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.inputTransform = null;
    
                /**
                 * GraphSearchRequest inputSpatRef.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} inputSpatRef
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.inputSpatRef = null;
    
                /**
                 * GraphSearchRequest spatialRelation.
                 * @member {esriPBuffer.EsriTypes.esriSpatialRel} spatialRelation
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.spatialRelation = 0;
    
                /**
                 * GraphSearchRequest returnGeometry.
                 * @member {boolean} returnGeometry
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.returnGeometry = false;
    
                /**
                 * GraphSearchRequest featureEncoding.
                 * @member {esriPBuffer.EsriTypes.esriFeatureEncoding} featureEncoding
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.featureEncoding = 0;
    
                /**
                 * GraphSearchRequest outSpatRef.
                 * @member {esriPBuffer.EsriTypes.ISpatialReference|null|undefined} outSpatRef
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.outSpatRef = null;
    
                /**
                 * GraphSearchRequest datumTransform.
                 * @member {esriPBuffer.EsriTypes.IDatumTransformation|null|undefined} datumTransform
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.datumTransform = null;
    
                /**
                 * GraphSearchRequest quantizationParams.
                 * @member {esriPBuffer.graph.IQuantizationParameters|null|undefined} quantizationParams
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.quantizationParams = null;
    
                /**
                 * GraphSearchRequest startIndex.
                 * @member {number} startIndex
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.startIndex = 0;
    
                /**
                 * GraphSearchRequest maxNumResults.
                 * @member {number} maxNumResults
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.maxNumResults = 0;
    
                /**
                 * GraphSearchRequest returnSearchContext.
                 * @member {boolean} returnSearchContext
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 */
                GraphSearchRequest.prototype.returnSearchContext = false;
    
                /**
                 * Creates a new GraphSearchRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphSearchRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphSearchRequest} GraphSearchRequest instance
                 */
                GraphSearchRequest.create = function create(properties) {
                    return new GraphSearchRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphSearchRequest message. Does not implicitly {@link esriPBuffer.graph.GraphSearchRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphSearchRequest} message GraphSearchRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphSearchRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.searchQuery != null && Object.hasOwnProperty.call(message, "searchQuery"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.searchQuery);
                    if (message.globalidArray != null && Object.hasOwnProperty.call(message, "globalidArray"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.globalidArray);
                    if (message.namedTypeFilter != null && message.namedTypeFilter.length)
                        for (var i = 0; i < message.namedTypeFilter.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.namedTypeFilter[i]);
                    if (message.typeCategoryFilter != null && Object.hasOwnProperty.call(message, "typeCategoryFilter"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.typeCategoryFilter);
                    if (message.spatialFilter != null && Object.hasOwnProperty.call(message, "spatialFilter"))
                        $root.esriPBuffer.graph.GeometryValue.encode(message.spatialFilter, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.inputTransform != null && Object.hasOwnProperty.call(message, "inputTransform"))
                        $root.esriPBuffer.graph.Transform.encode(message.inputTransform, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.inputSpatRef != null && Object.hasOwnProperty.call(message, "inputSpatRef"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.inputSpatRef, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.spatialRelation != null && Object.hasOwnProperty.call(message, "spatialRelation"))
                        writer.uint32(/* id 8, wireType 0 =*/64).int32(message.spatialRelation);
                    if (message.returnGeometry != null && Object.hasOwnProperty.call(message, "returnGeometry"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.returnGeometry);
                    if (message.featureEncoding != null && Object.hasOwnProperty.call(message, "featureEncoding"))
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.featureEncoding);
                    if (message.outSpatRef != null && Object.hasOwnProperty.call(message, "outSpatRef"))
                        $root.esriPBuffer.EsriTypes.SpatialReference.encode(message.outSpatRef, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.datumTransform != null && Object.hasOwnProperty.call(message, "datumTransform"))
                        $root.esriPBuffer.EsriTypes.DatumTransformation.encode(message.datumTransform, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.quantizationParams != null && Object.hasOwnProperty.call(message, "quantizationParams"))
                        $root.esriPBuffer.graph.QuantizationParameters.encode(message.quantizationParams, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                    if (message.startIndex != null && Object.hasOwnProperty.call(message, "startIndex"))
                        writer.uint32(/* id 15, wireType 0 =*/120).sint32(message.startIndex);
                    if (message.maxNumResults != null && Object.hasOwnProperty.call(message, "maxNumResults"))
                        writer.uint32(/* id 16, wireType 0 =*/128).sint32(message.maxNumResults);
                    if (message.returnSearchContext != null && Object.hasOwnProperty.call(message, "returnSearchContext"))
                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.returnSearchContext);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphSearchRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphSearchRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphSearchRequest} message GraphSearchRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphSearchRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphSearchRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphSearchRequest} GraphSearchRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphSearchRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphSearchRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.searchQuery = reader.string();
                            break;
                        case 2:
                            message.globalidArray = reader.bytes();
                            break;
                        case 3:
                            if (!(message.namedTypeFilter && message.namedTypeFilter.length))
                                message.namedTypeFilter = [];
                            message.namedTypeFilter.push(reader.string());
                            break;
                        case 4:
                            message.typeCategoryFilter = reader.int32();
                            break;
                        case 5:
                            message.spatialFilter = $root.esriPBuffer.graph.GeometryValue.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.inputTransform = $root.esriPBuffer.graph.Transform.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.inputSpatRef = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        case 8:
                            message.spatialRelation = reader.int32();
                            break;
                        case 9:
                            message.returnGeometry = reader.bool();
                            break;
                        case 10:
                            message.featureEncoding = reader.int32();
                            break;
                        case 11:
                            message.outSpatRef = $root.esriPBuffer.EsriTypes.SpatialReference.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.datumTransform = $root.esriPBuffer.EsriTypes.DatumTransformation.decode(reader, reader.uint32());
                            break;
                        case 14:
                            message.quantizationParams = $root.esriPBuffer.graph.QuantizationParameters.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.startIndex = reader.sint32();
                            break;
                        case 16:
                            message.maxNumResults = reader.sint32();
                            break;
                        case 17:
                            message.returnSearchContext = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphSearchRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphSearchRequest} GraphSearchRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphSearchRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphSearchRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphSearchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.searchQuery != null && message.hasOwnProperty("searchQuery"))
                        if (!$util.isString(message.searchQuery))
                            return "searchQuery: string expected";
                    if (message.globalidArray != null && message.hasOwnProperty("globalidArray"))
                        if (!(message.globalidArray && typeof message.globalidArray.length === "number" || $util.isString(message.globalidArray)))
                            return "globalidArray: buffer expected";
                    if (message.namedTypeFilter != null && message.hasOwnProperty("namedTypeFilter")) {
                        if (!Array.isArray(message.namedTypeFilter))
                            return "namedTypeFilter: array expected";
                        for (var i = 0; i < message.namedTypeFilter.length; ++i)
                            if (!$util.isString(message.namedTypeFilter[i]))
                                return "namedTypeFilter: string[] expected";
                    }
                    if (message.typeCategoryFilter != null && message.hasOwnProperty("typeCategoryFilter"))
                        switch (message.typeCategoryFilter) {
                        default:
                            return "typeCategoryFilter: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.spatialFilter != null && message.hasOwnProperty("spatialFilter")) {
                        var error = $root.esriPBuffer.graph.GeometryValue.verify(message.spatialFilter);
                        if (error)
                            return "spatialFilter." + error;
                    }
                    if (message.inputTransform != null && message.hasOwnProperty("inputTransform")) {
                        var error = $root.esriPBuffer.graph.Transform.verify(message.inputTransform);
                        if (error)
                            return "inputTransform." + error;
                    }
                    if (message.inputSpatRef != null && message.hasOwnProperty("inputSpatRef")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.inputSpatRef);
                        if (error)
                            return "inputSpatRef." + error;
                    }
                    if (message.spatialRelation != null && message.hasOwnProperty("spatialRelation"))
                        switch (message.spatialRelation) {
                        default:
                            return "spatialRelation: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.returnGeometry != null && message.hasOwnProperty("returnGeometry"))
                        if (typeof message.returnGeometry !== "boolean")
                            return "returnGeometry: boolean expected";
                    if (message.featureEncoding != null && message.hasOwnProperty("featureEncoding"))
                        switch (message.featureEncoding) {
                        default:
                            return "featureEncoding: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.outSpatRef != null && message.hasOwnProperty("outSpatRef")) {
                        var error = $root.esriPBuffer.EsriTypes.SpatialReference.verify(message.outSpatRef);
                        if (error)
                            return "outSpatRef." + error;
                    }
                    if (message.datumTransform != null && message.hasOwnProperty("datumTransform")) {
                        var error = $root.esriPBuffer.EsriTypes.DatumTransformation.verify(message.datumTransform);
                        if (error)
                            return "datumTransform." + error;
                    }
                    if (message.quantizationParams != null && message.hasOwnProperty("quantizationParams")) {
                        var error = $root.esriPBuffer.graph.QuantizationParameters.verify(message.quantizationParams);
                        if (error)
                            return "quantizationParams." + error;
                    }
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        if (!$util.isInteger(message.startIndex))
                            return "startIndex: integer expected";
                    if (message.maxNumResults != null && message.hasOwnProperty("maxNumResults"))
                        if (!$util.isInteger(message.maxNumResults))
                            return "maxNumResults: integer expected";
                    if (message.returnSearchContext != null && message.hasOwnProperty("returnSearchContext"))
                        if (typeof message.returnSearchContext !== "boolean")
                            return "returnSearchContext: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a GraphSearchRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphSearchRequest} GraphSearchRequest
                 */
                GraphSearchRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphSearchRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphSearchRequest();
                    if (object.searchQuery != null)
                        message.searchQuery = String(object.searchQuery);
                    if (object.globalidArray != null)
                        if (typeof object.globalidArray === "string")
                            $util.base64.decode(object.globalidArray, message.globalidArray = $util.newBuffer($util.base64.length(object.globalidArray)), 0);
                        else if (object.globalidArray.length)
                            message.globalidArray = object.globalidArray;
                    if (object.namedTypeFilter) {
                        if (!Array.isArray(object.namedTypeFilter))
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.namedTypeFilter: array expected");
                        message.namedTypeFilter = [];
                        for (var i = 0; i < object.namedTypeFilter.length; ++i)
                            message.namedTypeFilter[i] = String(object.namedTypeFilter[i]);
                    }
                    switch (object.typeCategoryFilter) {
                    case "esriType_UNSPECIFIED":
                    case 0:
                        message.typeCategoryFilter = 0;
                        break;
                    case "esriTypeEntity":
                    case 1:
                        message.typeCategoryFilter = 1;
                        break;
                    case "esriTypeRelationship":
                    case 2:
                        message.typeCategoryFilter = 2;
                        break;
                    case "esriTypeBoth":
                    case 3:
                        message.typeCategoryFilter = 3;
                        break;
                    }
                    if (object.spatialFilter != null) {
                        if (typeof object.spatialFilter !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.spatialFilter: object expected");
                        message.spatialFilter = $root.esriPBuffer.graph.GeometryValue.fromObject(object.spatialFilter);
                    }
                    if (object.inputTransform != null) {
                        if (typeof object.inputTransform !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.inputTransform: object expected");
                        message.inputTransform = $root.esriPBuffer.graph.Transform.fromObject(object.inputTransform);
                    }
                    if (object.inputSpatRef != null) {
                        if (typeof object.inputSpatRef !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.inputSpatRef: object expected");
                        message.inputSpatRef = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.inputSpatRef);
                    }
                    switch (object.spatialRelation) {
                    case "esriSpatialRelIntersects":
                    case 0:
                        message.spatialRelation = 0;
                        break;
                    case "esriSpatialRelContains":
                    case 1:
                        message.spatialRelation = 1;
                        break;
                    case "esriSpatialRelCrosses":
                    case 2:
                        message.spatialRelation = 2;
                        break;
                    case "esriSpatialRelEnvelopeIntersects":
                    case 3:
                        message.spatialRelation = 3;
                        break;
                    case "esriSpatialRelIndexIntersects":
                    case 4:
                        message.spatialRelation = 4;
                        break;
                    case "esriSpatialRelOverlaps":
                    case 5:
                        message.spatialRelation = 5;
                        break;
                    case "esriSpatialRelTouches":
                    case 6:
                        message.spatialRelation = 6;
                        break;
                    case "esriSpatialRelWithin":
                    case 7:
                        message.spatialRelation = 7;
                        break;
                    }
                    if (object.returnGeometry != null)
                        message.returnGeometry = Boolean(object.returnGeometry);
                    switch (object.featureEncoding) {
                    case "esriFeatureEncoding_UNSPECIFIED":
                    case 0:
                        message.featureEncoding = 0;
                        break;
                    case "esriDefault":
                    case 1:
                        message.featureEncoding = 1;
                        break;
                    case "esriCompressedShapeBuffer":
                    case 2:
                        message.featureEncoding = 2;
                        break;
                    }
                    if (object.outSpatRef != null) {
                        if (typeof object.outSpatRef !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.outSpatRef: object expected");
                        message.outSpatRef = $root.esriPBuffer.EsriTypes.SpatialReference.fromObject(object.outSpatRef);
                    }
                    if (object.datumTransform != null) {
                        if (typeof object.datumTransform !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.datumTransform: object expected");
                        message.datumTransform = $root.esriPBuffer.EsriTypes.DatumTransformation.fromObject(object.datumTransform);
                    }
                    if (object.quantizationParams != null) {
                        if (typeof object.quantizationParams !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphSearchRequest.quantizationParams: object expected");
                        message.quantizationParams = $root.esriPBuffer.graph.QuantizationParameters.fromObject(object.quantizationParams);
                    }
                    if (object.startIndex != null)
                        message.startIndex = object.startIndex | 0;
                    if (object.maxNumResults != null)
                        message.maxNumResults = object.maxNumResults | 0;
                    if (object.returnSearchContext != null)
                        message.returnSearchContext = Boolean(object.returnSearchContext);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphSearchRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphSearchRequest} message GraphSearchRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphSearchRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.namedTypeFilter = [];
                    if (options.defaults) {
                        object.searchQuery = "";
                        if (options.bytes === String)
                            object.globalidArray = "";
                        else {
                            object.globalidArray = [];
                            if (options.bytes !== Array)
                                object.globalidArray = $util.newBuffer(object.globalidArray);
                        }
                        object.typeCategoryFilter = options.enums === String ? "esriType_UNSPECIFIED" : 0;
                        object.spatialFilter = null;
                        object.inputTransform = null;
                        object.inputSpatRef = null;
                        object.spatialRelation = options.enums === String ? "esriSpatialRelIntersects" : 0;
                        object.returnGeometry = false;
                        object.featureEncoding = options.enums === String ? "esriFeatureEncoding_UNSPECIFIED" : 0;
                        object.outSpatRef = null;
                        object.datumTransform = null;
                        object.quantizationParams = null;
                        object.startIndex = 0;
                        object.maxNumResults = 0;
                        object.returnSearchContext = false;
                    }
                    if (message.searchQuery != null && message.hasOwnProperty("searchQuery"))
                        object.searchQuery = message.searchQuery;
                    if (message.globalidArray != null && message.hasOwnProperty("globalidArray"))
                        object.globalidArray = options.bytes === String ? $util.base64.encode(message.globalidArray, 0, message.globalidArray.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalidArray) : message.globalidArray;
                    if (message.namedTypeFilter && message.namedTypeFilter.length) {
                        object.namedTypeFilter = [];
                        for (var j = 0; j < message.namedTypeFilter.length; ++j)
                            object.namedTypeFilter[j] = message.namedTypeFilter[j];
                    }
                    if (message.typeCategoryFilter != null && message.hasOwnProperty("typeCategoryFilter"))
                        object.typeCategoryFilter = options.enums === String ? $root.esriPBuffer.graph.GraphSearchRequest.esriNamedTypeCategory[message.typeCategoryFilter] : message.typeCategoryFilter;
                    if (message.spatialFilter != null && message.hasOwnProperty("spatialFilter"))
                        object.spatialFilter = $root.esriPBuffer.graph.GeometryValue.toObject(message.spatialFilter, options);
                    if (message.inputTransform != null && message.hasOwnProperty("inputTransform"))
                        object.inputTransform = $root.esriPBuffer.graph.Transform.toObject(message.inputTransform, options);
                    if (message.inputSpatRef != null && message.hasOwnProperty("inputSpatRef"))
                        object.inputSpatRef = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.inputSpatRef, options);
                    if (message.spatialRelation != null && message.hasOwnProperty("spatialRelation"))
                        object.spatialRelation = options.enums === String ? $root.esriPBuffer.EsriTypes.esriSpatialRel[message.spatialRelation] : message.spatialRelation;
                    if (message.returnGeometry != null && message.hasOwnProperty("returnGeometry"))
                        object.returnGeometry = message.returnGeometry;
                    if (message.featureEncoding != null && message.hasOwnProperty("featureEncoding"))
                        object.featureEncoding = options.enums === String ? $root.esriPBuffer.EsriTypes.esriFeatureEncoding[message.featureEncoding] : message.featureEncoding;
                    if (message.outSpatRef != null && message.hasOwnProperty("outSpatRef"))
                        object.outSpatRef = $root.esriPBuffer.EsriTypes.SpatialReference.toObject(message.outSpatRef, options);
                    if (message.datumTransform != null && message.hasOwnProperty("datumTransform"))
                        object.datumTransform = $root.esriPBuffer.EsriTypes.DatumTransformation.toObject(message.datumTransform, options);
                    if (message.quantizationParams != null && message.hasOwnProperty("quantizationParams"))
                        object.quantizationParams = $root.esriPBuffer.graph.QuantizationParameters.toObject(message.quantizationParams, options);
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        object.startIndex = message.startIndex;
                    if (message.maxNumResults != null && message.hasOwnProperty("maxNumResults"))
                        object.maxNumResults = message.maxNumResults;
                    if (message.returnSearchContext != null && message.hasOwnProperty("returnSearchContext"))
                        object.returnSearchContext = message.returnSearchContext;
                    return object;
                };
    
                /**
                 * Converts this GraphSearchRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphSearchRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphSearchRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * esriNamedTypeCategory enum.
                 * @name esriPBuffer.graph.GraphSearchRequest.esriNamedTypeCategory
                 * @enum {number}
                 * @property {number} esriType_UNSPECIFIED=0 esriType_UNSPECIFIED value
                 * @property {number} esriTypeEntity=1 esriTypeEntity value
                 * @property {number} esriTypeRelationship=2 esriTypeRelationship value
                 * @property {number} esriTypeBoth=3 esriTypeBoth value
                 */
                GraphSearchRequest.esriNamedTypeCategory = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "esriType_UNSPECIFIED"] = 0;
                    values[valuesById[1] = "esriTypeEntity"] = 1;
                    values[valuesById[2] = "esriTypeRelationship"] = 2;
                    values[valuesById[3] = "esriTypeBoth"] = 3;
                    return values;
                })();
    
                return GraphSearchRequest;
            })();
    
            graph.DomainMask = (function() {
    
                /**
                 * Properties of a DomainMask.
                 * @memberof esriPBuffer.graph
                 * @interface IDomainMask
                 * @property {boolean|null} [updateType] DomainMask updateType
                 * @property {boolean|null} [updateName] DomainMask updateName
                 * @property {boolean|null} [updateDomain] DomainMask updateDomain
                 * @property {boolean|null} [updateFieldType] DomainMask updateFieldType
                 * @property {boolean|null} [updateMergePolicy] DomainMask updateMergePolicy
                 * @property {boolean|null} [updateSplitPolicy] DomainMask updateSplitPolicy
                 */
    
                /**
                 * Constructs a new DomainMask.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a DomainMask.
                 * @implements IDomainMask
                 * @constructor
                 * @param {esriPBuffer.graph.IDomainMask=} [properties] Properties to set
                 */
                function DomainMask(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DomainMask updateType.
                 * @member {boolean} updateType
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 */
                DomainMask.prototype.updateType = false;
    
                /**
                 * DomainMask updateName.
                 * @member {boolean} updateName
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 */
                DomainMask.prototype.updateName = false;
    
                /**
                 * DomainMask updateDomain.
                 * @member {boolean} updateDomain
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 */
                DomainMask.prototype.updateDomain = false;
    
                /**
                 * DomainMask updateFieldType.
                 * @member {boolean} updateFieldType
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 */
                DomainMask.prototype.updateFieldType = false;
    
                /**
                 * DomainMask updateMergePolicy.
                 * @member {boolean} updateMergePolicy
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 */
                DomainMask.prototype.updateMergePolicy = false;
    
                /**
                 * DomainMask updateSplitPolicy.
                 * @member {boolean} updateSplitPolicy
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 */
                DomainMask.prototype.updateSplitPolicy = false;
    
                /**
                 * Creates a new DomainMask instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {esriPBuffer.graph.IDomainMask=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.DomainMask} DomainMask instance
                 */
                DomainMask.create = function create(properties) {
                    return new DomainMask(properties);
                };
    
                /**
                 * Encodes the specified DomainMask message. Does not implicitly {@link esriPBuffer.graph.DomainMask.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {esriPBuffer.graph.IDomainMask} message DomainMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DomainMask.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.updateType != null && Object.hasOwnProperty.call(message, "updateType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.updateType);
                    if (message.updateName != null && Object.hasOwnProperty.call(message, "updateName"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.updateName);
                    if (message.updateDomain != null && Object.hasOwnProperty.call(message, "updateDomain"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.updateDomain);
                    if (message.updateFieldType != null && Object.hasOwnProperty.call(message, "updateFieldType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateFieldType);
                    if (message.updateMergePolicy != null && Object.hasOwnProperty.call(message, "updateMergePolicy"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.updateMergePolicy);
                    if (message.updateSplitPolicy != null && Object.hasOwnProperty.call(message, "updateSplitPolicy"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.updateSplitPolicy);
                    return writer;
                };
    
                /**
                 * Encodes the specified DomainMask message, length delimited. Does not implicitly {@link esriPBuffer.graph.DomainMask.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {esriPBuffer.graph.IDomainMask} message DomainMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DomainMask.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DomainMask message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.DomainMask} DomainMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DomainMask.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.DomainMask();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.updateType = reader.bool();
                            break;
                        case 2:
                            message.updateName = reader.bool();
                            break;
                        case 3:
                            message.updateDomain = reader.bool();
                            break;
                        case 4:
                            message.updateFieldType = reader.bool();
                            break;
                        case 5:
                            message.updateMergePolicy = reader.bool();
                            break;
                        case 6:
                            message.updateSplitPolicy = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DomainMask message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.DomainMask} DomainMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DomainMask.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DomainMask message.
                 * @function verify
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DomainMask.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.updateType != null && message.hasOwnProperty("updateType"))
                        if (typeof message.updateType !== "boolean")
                            return "updateType: boolean expected";
                    if (message.updateName != null && message.hasOwnProperty("updateName"))
                        if (typeof message.updateName !== "boolean")
                            return "updateName: boolean expected";
                    if (message.updateDomain != null && message.hasOwnProperty("updateDomain"))
                        if (typeof message.updateDomain !== "boolean")
                            return "updateDomain: boolean expected";
                    if (message.updateFieldType != null && message.hasOwnProperty("updateFieldType"))
                        if (typeof message.updateFieldType !== "boolean")
                            return "updateFieldType: boolean expected";
                    if (message.updateMergePolicy != null && message.hasOwnProperty("updateMergePolicy"))
                        if (typeof message.updateMergePolicy !== "boolean")
                            return "updateMergePolicy: boolean expected";
                    if (message.updateSplitPolicy != null && message.hasOwnProperty("updateSplitPolicy"))
                        if (typeof message.updateSplitPolicy !== "boolean")
                            return "updateSplitPolicy: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a DomainMask message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.DomainMask} DomainMask
                 */
                DomainMask.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.DomainMask)
                        return object;
                    var message = new $root.esriPBuffer.graph.DomainMask();
                    if (object.updateType != null)
                        message.updateType = Boolean(object.updateType);
                    if (object.updateName != null)
                        message.updateName = Boolean(object.updateName);
                    if (object.updateDomain != null)
                        message.updateDomain = Boolean(object.updateDomain);
                    if (object.updateFieldType != null)
                        message.updateFieldType = Boolean(object.updateFieldType);
                    if (object.updateMergePolicy != null)
                        message.updateMergePolicy = Boolean(object.updateMergePolicy);
                    if (object.updateSplitPolicy != null)
                        message.updateSplitPolicy = Boolean(object.updateSplitPolicy);
                    return message;
                };
    
                /**
                 * Creates a plain object from a DomainMask message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.DomainMask
                 * @static
                 * @param {esriPBuffer.graph.DomainMask} message DomainMask
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DomainMask.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.updateType = false;
                        object.updateName = false;
                        object.updateDomain = false;
                        object.updateFieldType = false;
                        object.updateMergePolicy = false;
                        object.updateSplitPolicy = false;
                    }
                    if (message.updateType != null && message.hasOwnProperty("updateType"))
                        object.updateType = message.updateType;
                    if (message.updateName != null && message.hasOwnProperty("updateName"))
                        object.updateName = message.updateName;
                    if (message.updateDomain != null && message.hasOwnProperty("updateDomain"))
                        object.updateDomain = message.updateDomain;
                    if (message.updateFieldType != null && message.hasOwnProperty("updateFieldType"))
                        object.updateFieldType = message.updateFieldType;
                    if (message.updateMergePolicy != null && message.hasOwnProperty("updateMergePolicy"))
                        object.updateMergePolicy = message.updateMergePolicy;
                    if (message.updateSplitPolicy != null && message.hasOwnProperty("updateSplitPolicy"))
                        object.updateSplitPolicy = message.updateSplitPolicy;
                    return object;
                };
    
                /**
                 * Converts this DomainMask to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.DomainMask
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DomainMask.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DomainMask;
            })();
    
            graph.DomainUpdateRequest = (function() {
    
                /**
                 * Properties of a DomainUpdateRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IDomainUpdateRequest
                 * @property {esriPBuffer.graph.IDomainMask|null} [mask] DomainUpdateRequest mask
                 * @property {esriPBuffer.EsriTypes.IDomain|null} [domain] DomainUpdateRequest domain
                 */
    
                /**
                 * Constructs a new DomainUpdateRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a DomainUpdateRequest.
                 * @implements IDomainUpdateRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IDomainUpdateRequest=} [properties] Properties to set
                 */
                function DomainUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DomainUpdateRequest mask.
                 * @member {esriPBuffer.graph.IDomainMask|null|undefined} mask
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @instance
                 */
                DomainUpdateRequest.prototype.mask = null;
    
                /**
                 * DomainUpdateRequest domain.
                 * @member {esriPBuffer.EsriTypes.IDomain|null|undefined} domain
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @instance
                 */
                DomainUpdateRequest.prototype.domain = null;
    
                /**
                 * Creates a new DomainUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IDomainUpdateRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.DomainUpdateRequest} DomainUpdateRequest instance
                 */
                DomainUpdateRequest.create = function create(properties) {
                    return new DomainUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified DomainUpdateRequest message. Does not implicitly {@link esriPBuffer.graph.DomainUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IDomainUpdateRequest} message DomainUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DomainUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                        $root.esriPBuffer.graph.DomainMask.encode(message.mask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                        $root.esriPBuffer.EsriTypes.Domain.encode(message.domain, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DomainUpdateRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.DomainUpdateRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IDomainUpdateRequest} message DomainUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DomainUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DomainUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.DomainUpdateRequest} DomainUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DomainUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.DomainUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mask = $root.esriPBuffer.graph.DomainMask.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.domain = $root.esriPBuffer.EsriTypes.Domain.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DomainUpdateRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.DomainUpdateRequest} DomainUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DomainUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DomainUpdateRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DomainUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mask != null && message.hasOwnProperty("mask")) {
                        var error = $root.esriPBuffer.graph.DomainMask.verify(message.mask);
                        if (error)
                            return "mask." + error;
                    }
                    if (message.domain != null && message.hasOwnProperty("domain")) {
                        var error = $root.esriPBuffer.EsriTypes.Domain.verify(message.domain);
                        if (error)
                            return "domain." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a DomainUpdateRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.DomainUpdateRequest} DomainUpdateRequest
                 */
                DomainUpdateRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.DomainUpdateRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.DomainUpdateRequest();
                    if (object.mask != null) {
                        if (typeof object.mask !== "object")
                            throw TypeError(".esriPBuffer.graph.DomainUpdateRequest.mask: object expected");
                        message.mask = $root.esriPBuffer.graph.DomainMask.fromObject(object.mask);
                    }
                    if (object.domain != null) {
                        if (typeof object.domain !== "object")
                            throw TypeError(".esriPBuffer.graph.DomainUpdateRequest.domain: object expected");
                        message.domain = $root.esriPBuffer.EsriTypes.Domain.fromObject(object.domain);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DomainUpdateRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.DomainUpdateRequest} message DomainUpdateRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DomainUpdateRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mask = null;
                        object.domain = null;
                    }
                    if (message.mask != null && message.hasOwnProperty("mask"))
                        object.mask = $root.esriPBuffer.graph.DomainMask.toObject(message.mask, options);
                    if (message.domain != null && message.hasOwnProperty("domain"))
                        object.domain = $root.esriPBuffer.EsriTypes.Domain.toObject(message.domain, options);
                    return object;
                };
    
                /**
                 * Converts this DomainUpdateRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.DomainUpdateRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DomainUpdateRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DomainUpdateRequest;
            })();
    
            graph.GraphDomainUpdateResponse = (function() {
    
                /**
                 * Properties of a GraphDomainUpdateResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphDomainUpdateResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphDomainUpdateResponse error
                 */
    
                /**
                 * Constructs a new GraphDomainUpdateResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphDomainUpdateResponse.
                 * @implements IGraphDomainUpdateResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphDomainUpdateResponse=} [properties] Properties to set
                 */
                function GraphDomainUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphDomainUpdateResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @instance
                 */
                GraphDomainUpdateResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphDomainUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainUpdateResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphDomainUpdateResponse} GraphDomainUpdateResponse instance
                 */
                GraphDomainUpdateResponse.create = function create(properties) {
                    return new GraphDomainUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphDomainUpdateResponse message. Does not implicitly {@link esriPBuffer.graph.GraphDomainUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainUpdateResponse} message GraphDomainUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphDomainUpdateResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphDomainUpdateResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphDomainUpdateResponse} message GraphDomainUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphDomainUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphDomainUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphDomainUpdateResponse} GraphDomainUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphDomainUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphDomainUpdateResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphDomainUpdateResponse} GraphDomainUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphDomainUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphDomainUpdateResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphDomainUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphDomainUpdateResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphDomainUpdateResponse} GraphDomainUpdateResponse
                 */
                GraphDomainUpdateResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphDomainUpdateResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphDomainUpdateResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphDomainUpdateResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphDomainUpdateResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphDomainUpdateResponse} message GraphDomainUpdateResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphDomainUpdateResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphDomainUpdateResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphDomainUpdateResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphDomainUpdateResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphDomainUpdateResponse;
            })();
    
            graph.GraphPropertyMask = (function() {
    
                /**
                 * Properties of a GraphPropertyMask.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyMask
                 * @property {boolean|null} [updateName] GraphPropertyMask updateName
                 * @property {boolean|null} [updateAlias] GraphPropertyMask updateAlias
                 * @property {boolean|null} [updateFieldType] GraphPropertyMask updateFieldType
                 * @property {boolean|null} [updateGeometryType] GraphPropertyMask updateGeometryType
                 * @property {boolean|null} [updateDefaultValue] GraphPropertyMask updateDefaultValue
                 * @property {boolean|null} [updateNullable] GraphPropertyMask updateNullable
                 * @property {boolean|null} [updateEditable] GraphPropertyMask updateEditable
                 * @property {boolean|null} [updateVisible] GraphPropertyMask updateVisible
                 * @property {boolean|null} [updateRequired] GraphPropertyMask updateRequired
                 * @property {boolean|null} [updateDomain] GraphPropertyMask updateDomain
                 * @property {boolean|null} [updateHasZ] GraphPropertyMask updateHasZ
                 * @property {boolean|null} [updateHasM] GraphPropertyMask updateHasM
                 * @property {boolean|null} [updateSearchable] GraphPropertyMask updateSearchable
                 */
    
                /**
                 * Constructs a new GraphPropertyMask.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyMask.
                 * @implements IGraphPropertyMask
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyMask=} [properties] Properties to set
                 */
                function GraphPropertyMask(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyMask updateName.
                 * @member {boolean} updateName
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateName = false;
    
                /**
                 * GraphPropertyMask updateAlias.
                 * @member {boolean} updateAlias
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateAlias = false;
    
                /**
                 * GraphPropertyMask updateFieldType.
                 * @member {boolean} updateFieldType
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateFieldType = false;
    
                /**
                 * GraphPropertyMask updateGeometryType.
                 * @member {boolean} updateGeometryType
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateGeometryType = false;
    
                /**
                 * GraphPropertyMask updateDefaultValue.
                 * @member {boolean} updateDefaultValue
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateDefaultValue = false;
    
                /**
                 * GraphPropertyMask updateNullable.
                 * @member {boolean} updateNullable
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateNullable = false;
    
                /**
                 * GraphPropertyMask updateEditable.
                 * @member {boolean} updateEditable
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateEditable = false;
    
                /**
                 * GraphPropertyMask updateVisible.
                 * @member {boolean} updateVisible
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateVisible = false;
    
                /**
                 * GraphPropertyMask updateRequired.
                 * @member {boolean} updateRequired
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateRequired = false;
    
                /**
                 * GraphPropertyMask updateDomain.
                 * @member {boolean} updateDomain
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateDomain = false;
    
                /**
                 * GraphPropertyMask updateHasZ.
                 * @member {boolean} updateHasZ
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateHasZ = false;
    
                /**
                 * GraphPropertyMask updateHasM.
                 * @member {boolean} updateHasM
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateHasM = false;
    
                /**
                 * GraphPropertyMask updateSearchable.
                 * @member {boolean} updateSearchable
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 */
                GraphPropertyMask.prototype.updateSearchable = false;
    
                /**
                 * Creates a new GraphPropertyMask instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyMask=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyMask} GraphPropertyMask instance
                 */
                GraphPropertyMask.create = function create(properties) {
                    return new GraphPropertyMask(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyMask message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyMask.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyMask} message GraphPropertyMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyMask.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.updateName != null && Object.hasOwnProperty.call(message, "updateName"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.updateName);
                    if (message.updateAlias != null && Object.hasOwnProperty.call(message, "updateAlias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.updateAlias);
                    if (message.updateFieldType != null && Object.hasOwnProperty.call(message, "updateFieldType"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.updateFieldType);
                    if (message.updateGeometryType != null && Object.hasOwnProperty.call(message, "updateGeometryType"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateGeometryType);
                    if (message.updateDefaultValue != null && Object.hasOwnProperty.call(message, "updateDefaultValue"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.updateDefaultValue);
                    if (message.updateNullable != null && Object.hasOwnProperty.call(message, "updateNullable"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.updateNullable);
                    if (message.updateEditable != null && Object.hasOwnProperty.call(message, "updateEditable"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.updateEditable);
                    if (message.updateVisible != null && Object.hasOwnProperty.call(message, "updateVisible"))
                        writer.uint32(/* id 8, wireType 0 =*/64).bool(message.updateVisible);
                    if (message.updateRequired != null && Object.hasOwnProperty.call(message, "updateRequired"))
                        writer.uint32(/* id 9, wireType 0 =*/72).bool(message.updateRequired);
                    if (message.updateDomain != null && Object.hasOwnProperty.call(message, "updateDomain"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.updateDomain);
                    if (message.updateHasZ != null && Object.hasOwnProperty.call(message, "updateHasZ"))
                        writer.uint32(/* id 12, wireType 0 =*/96).bool(message.updateHasZ);
                    if (message.updateHasM != null && Object.hasOwnProperty.call(message, "updateHasM"))
                        writer.uint32(/* id 13, wireType 0 =*/104).bool(message.updateHasM);
                    if (message.updateSearchable != null && Object.hasOwnProperty.call(message, "updateSearchable"))
                        writer.uint32(/* id 14, wireType 0 =*/112).bool(message.updateSearchable);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyMask message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyMask.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyMask} message GraphPropertyMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyMask.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyMask message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyMask} GraphPropertyMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyMask.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyMask();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.updateName = reader.bool();
                            break;
                        case 2:
                            message.updateAlias = reader.bool();
                            break;
                        case 3:
                            message.updateFieldType = reader.bool();
                            break;
                        case 4:
                            message.updateGeometryType = reader.bool();
                            break;
                        case 5:
                            message.updateDefaultValue = reader.bool();
                            break;
                        case 6:
                            message.updateNullable = reader.bool();
                            break;
                        case 7:
                            message.updateEditable = reader.bool();
                            break;
                        case 8:
                            message.updateVisible = reader.bool();
                            break;
                        case 9:
                            message.updateRequired = reader.bool();
                            break;
                        case 10:
                            message.updateDomain = reader.bool();
                            break;
                        case 12:
                            message.updateHasZ = reader.bool();
                            break;
                        case 13:
                            message.updateHasM = reader.bool();
                            break;
                        case 14:
                            message.updateSearchable = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyMask message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyMask} GraphPropertyMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyMask.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyMask message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyMask.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.updateName != null && message.hasOwnProperty("updateName"))
                        if (typeof message.updateName !== "boolean")
                            return "updateName: boolean expected";
                    if (message.updateAlias != null && message.hasOwnProperty("updateAlias"))
                        if (typeof message.updateAlias !== "boolean")
                            return "updateAlias: boolean expected";
                    if (message.updateFieldType != null && message.hasOwnProperty("updateFieldType"))
                        if (typeof message.updateFieldType !== "boolean")
                            return "updateFieldType: boolean expected";
                    if (message.updateGeometryType != null && message.hasOwnProperty("updateGeometryType"))
                        if (typeof message.updateGeometryType !== "boolean")
                            return "updateGeometryType: boolean expected";
                    if (message.updateDefaultValue != null && message.hasOwnProperty("updateDefaultValue"))
                        if (typeof message.updateDefaultValue !== "boolean")
                            return "updateDefaultValue: boolean expected";
                    if (message.updateNullable != null && message.hasOwnProperty("updateNullable"))
                        if (typeof message.updateNullable !== "boolean")
                            return "updateNullable: boolean expected";
                    if (message.updateEditable != null && message.hasOwnProperty("updateEditable"))
                        if (typeof message.updateEditable !== "boolean")
                            return "updateEditable: boolean expected";
                    if (message.updateVisible != null && message.hasOwnProperty("updateVisible"))
                        if (typeof message.updateVisible !== "boolean")
                            return "updateVisible: boolean expected";
                    if (message.updateRequired != null && message.hasOwnProperty("updateRequired"))
                        if (typeof message.updateRequired !== "boolean")
                            return "updateRequired: boolean expected";
                    if (message.updateDomain != null && message.hasOwnProperty("updateDomain"))
                        if (typeof message.updateDomain !== "boolean")
                            return "updateDomain: boolean expected";
                    if (message.updateHasZ != null && message.hasOwnProperty("updateHasZ"))
                        if (typeof message.updateHasZ !== "boolean")
                            return "updateHasZ: boolean expected";
                    if (message.updateHasM != null && message.hasOwnProperty("updateHasM"))
                        if (typeof message.updateHasM !== "boolean")
                            return "updateHasM: boolean expected";
                    if (message.updateSearchable != null && message.hasOwnProperty("updateSearchable"))
                        if (typeof message.updateSearchable !== "boolean")
                            return "updateSearchable: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyMask message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyMask} GraphPropertyMask
                 */
                GraphPropertyMask.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyMask)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyMask();
                    if (object.updateName != null)
                        message.updateName = Boolean(object.updateName);
                    if (object.updateAlias != null)
                        message.updateAlias = Boolean(object.updateAlias);
                    if (object.updateFieldType != null)
                        message.updateFieldType = Boolean(object.updateFieldType);
                    if (object.updateGeometryType != null)
                        message.updateGeometryType = Boolean(object.updateGeometryType);
                    if (object.updateDefaultValue != null)
                        message.updateDefaultValue = Boolean(object.updateDefaultValue);
                    if (object.updateNullable != null)
                        message.updateNullable = Boolean(object.updateNullable);
                    if (object.updateEditable != null)
                        message.updateEditable = Boolean(object.updateEditable);
                    if (object.updateVisible != null)
                        message.updateVisible = Boolean(object.updateVisible);
                    if (object.updateRequired != null)
                        message.updateRequired = Boolean(object.updateRequired);
                    if (object.updateDomain != null)
                        message.updateDomain = Boolean(object.updateDomain);
                    if (object.updateHasZ != null)
                        message.updateHasZ = Boolean(object.updateHasZ);
                    if (object.updateHasM != null)
                        message.updateHasM = Boolean(object.updateHasM);
                    if (object.updateSearchable != null)
                        message.updateSearchable = Boolean(object.updateSearchable);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyMask message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyMask} message GraphPropertyMask
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyMask.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.updateName = false;
                        object.updateAlias = false;
                        object.updateFieldType = false;
                        object.updateGeometryType = false;
                        object.updateDefaultValue = false;
                        object.updateNullable = false;
                        object.updateEditable = false;
                        object.updateVisible = false;
                        object.updateRequired = false;
                        object.updateDomain = false;
                        object.updateHasZ = false;
                        object.updateHasM = false;
                        object.updateSearchable = false;
                    }
                    if (message.updateName != null && message.hasOwnProperty("updateName"))
                        object.updateName = message.updateName;
                    if (message.updateAlias != null && message.hasOwnProperty("updateAlias"))
                        object.updateAlias = message.updateAlias;
                    if (message.updateFieldType != null && message.hasOwnProperty("updateFieldType"))
                        object.updateFieldType = message.updateFieldType;
                    if (message.updateGeometryType != null && message.hasOwnProperty("updateGeometryType"))
                        object.updateGeometryType = message.updateGeometryType;
                    if (message.updateDefaultValue != null && message.hasOwnProperty("updateDefaultValue"))
                        object.updateDefaultValue = message.updateDefaultValue;
                    if (message.updateNullable != null && message.hasOwnProperty("updateNullable"))
                        object.updateNullable = message.updateNullable;
                    if (message.updateEditable != null && message.hasOwnProperty("updateEditable"))
                        object.updateEditable = message.updateEditable;
                    if (message.updateVisible != null && message.hasOwnProperty("updateVisible"))
                        object.updateVisible = message.updateVisible;
                    if (message.updateRequired != null && message.hasOwnProperty("updateRequired"))
                        object.updateRequired = message.updateRequired;
                    if (message.updateDomain != null && message.hasOwnProperty("updateDomain"))
                        object.updateDomain = message.updateDomain;
                    if (message.updateHasZ != null && message.hasOwnProperty("updateHasZ"))
                        object.updateHasZ = message.updateHasZ;
                    if (message.updateHasM != null && message.hasOwnProperty("updateHasM"))
                        object.updateHasM = message.updateHasM;
                    if (message.updateSearchable != null && message.hasOwnProperty("updateSearchable"))
                        object.updateSearchable = message.updateSearchable;
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyMask to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyMask
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyMask.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyMask;
            })();
    
            graph.GraphPropertyUpdateRequest = (function() {
    
                /**
                 * Properties of a GraphPropertyUpdateRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyUpdateRequest
                 * @property {esriPBuffer.graph.IGraphPropertyMask|null} [mask] GraphPropertyUpdateRequest mask
                 * @property {esriPBuffer.graph.IGraphProperty|null} [graphProperty] GraphPropertyUpdateRequest graphProperty
                 * @property {string|null} [propertyName] GraphPropertyUpdateRequest propertyName
                 */
    
                /**
                 * Constructs a new GraphPropertyUpdateRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyUpdateRequest.
                 * @implements IGraphPropertyUpdateRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateRequest=} [properties] Properties to set
                 */
                function GraphPropertyUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyUpdateRequest mask.
                 * @member {esriPBuffer.graph.IGraphPropertyMask|null|undefined} mask
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @instance
                 */
                GraphPropertyUpdateRequest.prototype.mask = null;
    
                /**
                 * GraphPropertyUpdateRequest graphProperty.
                 * @member {esriPBuffer.graph.IGraphProperty|null|undefined} graphProperty
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @instance
                 */
                GraphPropertyUpdateRequest.prototype.graphProperty = null;
    
                /**
                 * GraphPropertyUpdateRequest propertyName.
                 * @member {string} propertyName
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @instance
                 */
                GraphPropertyUpdateRequest.prototype.propertyName = "";
    
                /**
                 * Creates a new GraphPropertyUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateRequest} GraphPropertyUpdateRequest instance
                 */
                GraphPropertyUpdateRequest.create = function create(properties) {
                    return new GraphPropertyUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyUpdateRequest message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateRequest} message GraphPropertyUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                        $root.esriPBuffer.graph.GraphPropertyMask.encode(message.mask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.graphProperty != null && Object.hasOwnProperty.call(message, "graphProperty"))
                        $root.esriPBuffer.graph.GraphProperty.encode(message.graphProperty, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.propertyName != null && Object.hasOwnProperty.call(message, "propertyName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.propertyName);
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyUpdateRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyUpdateRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateRequest} message GraphPropertyUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateRequest} GraphPropertyUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mask = $root.esriPBuffer.graph.GraphPropertyMask.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.graphProperty = $root.esriPBuffer.graph.GraphProperty.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.propertyName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyUpdateRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateRequest} GraphPropertyUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyUpdateRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mask != null && message.hasOwnProperty("mask")) {
                        var error = $root.esriPBuffer.graph.GraphPropertyMask.verify(message.mask);
                        if (error)
                            return "mask." + error;
                    }
                    if (message.graphProperty != null && message.hasOwnProperty("graphProperty")) {
                        var error = $root.esriPBuffer.graph.GraphProperty.verify(message.graphProperty);
                        if (error)
                            return "graphProperty." + error;
                    }
                    if (message.propertyName != null && message.hasOwnProperty("propertyName"))
                        if (!$util.isString(message.propertyName))
                            return "propertyName: string expected";
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyUpdateRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateRequest} GraphPropertyUpdateRequest
                 */
                GraphPropertyUpdateRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyUpdateRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyUpdateRequest();
                    if (object.mask != null) {
                        if (typeof object.mask !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyUpdateRequest.mask: object expected");
                        message.mask = $root.esriPBuffer.graph.GraphPropertyMask.fromObject(object.mask);
                    }
                    if (object.graphProperty != null) {
                        if (typeof object.graphProperty !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyUpdateRequest.graphProperty: object expected");
                        message.graphProperty = $root.esriPBuffer.graph.GraphProperty.fromObject(object.graphProperty);
                    }
                    if (object.propertyName != null)
                        message.propertyName = String(object.propertyName);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyUpdateRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyUpdateRequest} message GraphPropertyUpdateRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyUpdateRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mask = null;
                        object.graphProperty = null;
                        object.propertyName = "";
                    }
                    if (message.mask != null && message.hasOwnProperty("mask"))
                        object.mask = $root.esriPBuffer.graph.GraphPropertyMask.toObject(message.mask, options);
                    if (message.graphProperty != null && message.hasOwnProperty("graphProperty"))
                        object.graphProperty = $root.esriPBuffer.graph.GraphProperty.toObject(message.graphProperty, options);
                    if (message.propertyName != null && message.hasOwnProperty("propertyName"))
                        object.propertyName = message.propertyName;
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyUpdateRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyUpdateRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyUpdateRequest;
            })();
    
            graph.GraphPropertyUpdateResponse = (function() {
    
                /**
                 * Properties of a GraphPropertyUpdateResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphPropertyUpdateResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphPropertyUpdateResponse error
                 */
    
                /**
                 * Constructs a new GraphPropertyUpdateResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphPropertyUpdateResponse.
                 * @implements IGraphPropertyUpdateResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateResponse=} [properties] Properties to set
                 */
                function GraphPropertyUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphPropertyUpdateResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @instance
                 */
                GraphPropertyUpdateResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphPropertyUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateResponse} GraphPropertyUpdateResponse instance
                 */
                GraphPropertyUpdateResponse.create = function create(properties) {
                    return new GraphPropertyUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphPropertyUpdateResponse message. Does not implicitly {@link esriPBuffer.graph.GraphPropertyUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateResponse} message GraphPropertyUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphPropertyUpdateResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphPropertyUpdateResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphPropertyUpdateResponse} message GraphPropertyUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphPropertyUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphPropertyUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateResponse} GraphPropertyUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphPropertyUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphPropertyUpdateResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateResponse} GraphPropertyUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphPropertyUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphPropertyUpdateResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphPropertyUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphPropertyUpdateResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphPropertyUpdateResponse} GraphPropertyUpdateResponse
                 */
                GraphPropertyUpdateResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphPropertyUpdateResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphPropertyUpdateResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphPropertyUpdateResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphPropertyUpdateResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphPropertyUpdateResponse} message GraphPropertyUpdateResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphPropertyUpdateResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphPropertyUpdateResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphPropertyUpdateResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphPropertyUpdateResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphPropertyUpdateResponse;
            })();
    
            graph.GraphNamedObjectTypeUpdateRequest = (function() {
    
                /**
                 * Properties of a GraphNamedObjectTypeUpdateRequest.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphNamedObjectTypeUpdateRequest
                 * @property {esriPBuffer.graph.IGraphEntityTypeUpdate|null} [entityUpdate] GraphNamedObjectTypeUpdateRequest entityUpdate
                 * @property {esriPBuffer.graph.IGraphRelationshipTypeUpdate|null} [relationshipUpdate] GraphNamedObjectTypeUpdateRequest relationshipUpdate
                 */
    
                /**
                 * Constructs a new GraphNamedObjectTypeUpdateRequest.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphNamedObjectTypeUpdateRequest.
                 * @implements IGraphNamedObjectTypeUpdateRequest
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateRequest=} [properties] Properties to set
                 */
                function GraphNamedObjectTypeUpdateRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphNamedObjectTypeUpdateRequest entityUpdate.
                 * @member {esriPBuffer.graph.IGraphEntityTypeUpdate|null|undefined} entityUpdate
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @instance
                 */
                GraphNamedObjectTypeUpdateRequest.prototype.entityUpdate = null;
    
                /**
                 * GraphNamedObjectTypeUpdateRequest relationshipUpdate.
                 * @member {esriPBuffer.graph.IGraphRelationshipTypeUpdate|null|undefined} relationshipUpdate
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @instance
                 */
                GraphNamedObjectTypeUpdateRequest.prototype.relationshipUpdate = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * GraphNamedObjectTypeUpdateRequest namedTypeUpdate.
                 * @member {"entityUpdate"|"relationshipUpdate"|undefined} namedTypeUpdate
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @instance
                 */
                Object.defineProperty(GraphNamedObjectTypeUpdateRequest.prototype, "namedTypeUpdate", {
                    get: $util.oneOfGetter($oneOfFields = ["entityUpdate", "relationshipUpdate"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new GraphNamedObjectTypeUpdateRequest instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateRequest=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest} GraphNamedObjectTypeUpdateRequest instance
                 */
                GraphNamedObjectTypeUpdateRequest.create = function create(properties) {
                    return new GraphNamedObjectTypeUpdateRequest(properties);
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeUpdateRequest message. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateRequest} message GraphNamedObjectTypeUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeUpdateRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.entityUpdate != null && Object.hasOwnProperty.call(message, "entityUpdate"))
                        $root.esriPBuffer.graph.GraphEntityTypeUpdate.encode(message.entityUpdate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.relationshipUpdate != null && Object.hasOwnProperty.call(message, "relationshipUpdate"))
                        $root.esriPBuffer.graph.GraphRelationshipTypeUpdate.encode(message.relationshipUpdate, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeUpdateRequest message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateRequest} message GraphNamedObjectTypeUpdateRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeUpdateRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest} GraphNamedObjectTypeUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeUpdateRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.entityUpdate = $root.esriPBuffer.graph.GraphEntityTypeUpdate.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.relationshipUpdate = $root.esriPBuffer.graph.GraphRelationshipTypeUpdate.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeUpdateRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest} GraphNamedObjectTypeUpdateRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphNamedObjectTypeUpdateRequest message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphNamedObjectTypeUpdateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.entityUpdate != null && message.hasOwnProperty("entityUpdate")) {
                        properties.namedTypeUpdate = 1;
                        {
                            var error = $root.esriPBuffer.graph.GraphEntityTypeUpdate.verify(message.entityUpdate);
                            if (error)
                                return "entityUpdate." + error;
                        }
                    }
                    if (message.relationshipUpdate != null && message.hasOwnProperty("relationshipUpdate")) {
                        if (properties.namedTypeUpdate === 1)
                            return "namedTypeUpdate: multiple values";
                        properties.namedTypeUpdate = 1;
                        {
                            var error = $root.esriPBuffer.graph.GraphRelationshipTypeUpdate.verify(message.relationshipUpdate);
                            if (error)
                                return "relationshipUpdate." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphNamedObjectTypeUpdateRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest} GraphNamedObjectTypeUpdateRequest
                 */
                GraphNamedObjectTypeUpdateRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest();
                    if (object.entityUpdate != null) {
                        if (typeof object.entityUpdate !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest.entityUpdate: object expected");
                        message.entityUpdate = $root.esriPBuffer.graph.GraphEntityTypeUpdate.fromObject(object.entityUpdate);
                    }
                    if (object.relationshipUpdate != null) {
                        if (typeof object.relationshipUpdate !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest.relationshipUpdate: object expected");
                        message.relationshipUpdate = $root.esriPBuffer.graph.GraphRelationshipTypeUpdate.fromObject(object.relationshipUpdate);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphNamedObjectTypeUpdateRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @static
                 * @param {esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest} message GraphNamedObjectTypeUpdateRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphNamedObjectTypeUpdateRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.entityUpdate != null && message.hasOwnProperty("entityUpdate")) {
                        object.entityUpdate = $root.esriPBuffer.graph.GraphEntityTypeUpdate.toObject(message.entityUpdate, options);
                        if (options.oneofs)
                            object.namedTypeUpdate = "entityUpdate";
                    }
                    if (message.relationshipUpdate != null && message.hasOwnProperty("relationshipUpdate")) {
                        object.relationshipUpdate = $root.esriPBuffer.graph.GraphRelationshipTypeUpdate.toObject(message.relationshipUpdate, options);
                        if (options.oneofs)
                            object.namedTypeUpdate = "relationshipUpdate";
                    }
                    return object;
                };
    
                /**
                 * Converts this GraphNamedObjectTypeUpdateRequest to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphNamedObjectTypeUpdateRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphNamedObjectTypeUpdateRequest;
            })();
    
            graph.NamedObjectTypeMask = (function() {
    
                /**
                 * Properties of a NamedObjectTypeMask.
                 * @memberof esriPBuffer.graph
                 * @interface INamedObjectTypeMask
                 * @property {boolean|null} [updateName] NamedObjectTypeMask updateName
                 * @property {boolean|null} [updateAlias] NamedObjectTypeMask updateAlias
                 * @property {boolean|null} [updateRole] NamedObjectTypeMask updateRole
                 */
    
                /**
                 * Constructs a new NamedObjectTypeMask.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a NamedObjectTypeMask.
                 * @implements INamedObjectTypeMask
                 * @constructor
                 * @param {esriPBuffer.graph.INamedObjectTypeMask=} [properties] Properties to set
                 */
                function NamedObjectTypeMask(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NamedObjectTypeMask updateName.
                 * @member {boolean} updateName
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @instance
                 */
                NamedObjectTypeMask.prototype.updateName = false;
    
                /**
                 * NamedObjectTypeMask updateAlias.
                 * @member {boolean} updateAlias
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @instance
                 */
                NamedObjectTypeMask.prototype.updateAlias = false;
    
                /**
                 * NamedObjectTypeMask updateRole.
                 * @member {boolean} updateRole
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @instance
                 */
                NamedObjectTypeMask.prototype.updateRole = false;
    
                /**
                 * Creates a new NamedObjectTypeMask instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectTypeMask=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.NamedObjectTypeMask} NamedObjectTypeMask instance
                 */
                NamedObjectTypeMask.create = function create(properties) {
                    return new NamedObjectTypeMask(properties);
                };
    
                /**
                 * Encodes the specified NamedObjectTypeMask message. Does not implicitly {@link esriPBuffer.graph.NamedObjectTypeMask.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectTypeMask} message NamedObjectTypeMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectTypeMask.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.updateName != null && Object.hasOwnProperty.call(message, "updateName"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.updateName);
                    if (message.updateAlias != null && Object.hasOwnProperty.call(message, "updateAlias"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.updateAlias);
                    if (message.updateRole != null && Object.hasOwnProperty.call(message, "updateRole"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.updateRole);
                    return writer;
                };
    
                /**
                 * Encodes the specified NamedObjectTypeMask message, length delimited. Does not implicitly {@link esriPBuffer.graph.NamedObjectTypeMask.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {esriPBuffer.graph.INamedObjectTypeMask} message NamedObjectTypeMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamedObjectTypeMask.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NamedObjectTypeMask message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.NamedObjectTypeMask} NamedObjectTypeMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectTypeMask.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.NamedObjectTypeMask();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.updateName = reader.bool();
                            break;
                        case 2:
                            message.updateAlias = reader.bool();
                            break;
                        case 4:
                            message.updateRole = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NamedObjectTypeMask message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.NamedObjectTypeMask} NamedObjectTypeMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamedObjectTypeMask.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NamedObjectTypeMask message.
                 * @function verify
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamedObjectTypeMask.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.updateName != null && message.hasOwnProperty("updateName"))
                        if (typeof message.updateName !== "boolean")
                            return "updateName: boolean expected";
                    if (message.updateAlias != null && message.hasOwnProperty("updateAlias"))
                        if (typeof message.updateAlias !== "boolean")
                            return "updateAlias: boolean expected";
                    if (message.updateRole != null && message.hasOwnProperty("updateRole"))
                        if (typeof message.updateRole !== "boolean")
                            return "updateRole: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a NamedObjectTypeMask message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.NamedObjectTypeMask} NamedObjectTypeMask
                 */
                NamedObjectTypeMask.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.NamedObjectTypeMask)
                        return object;
                    var message = new $root.esriPBuffer.graph.NamedObjectTypeMask();
                    if (object.updateName != null)
                        message.updateName = Boolean(object.updateName);
                    if (object.updateAlias != null)
                        message.updateAlias = Boolean(object.updateAlias);
                    if (object.updateRole != null)
                        message.updateRole = Boolean(object.updateRole);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NamedObjectTypeMask message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @static
                 * @param {esriPBuffer.graph.NamedObjectTypeMask} message NamedObjectTypeMask
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamedObjectTypeMask.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.updateName = false;
                        object.updateAlias = false;
                        object.updateRole = false;
                    }
                    if (message.updateName != null && message.hasOwnProperty("updateName"))
                        object.updateName = message.updateName;
                    if (message.updateAlias != null && message.hasOwnProperty("updateAlias"))
                        object.updateAlias = message.updateAlias;
                    if (message.updateRole != null && message.hasOwnProperty("updateRole"))
                        object.updateRole = message.updateRole;
                    return object;
                };
    
                /**
                 * Converts this NamedObjectTypeMask to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.NamedObjectTypeMask
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamedObjectTypeMask.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NamedObjectTypeMask;
            })();
    
            graph.GraphEntityTypeUpdate = (function() {
    
                /**
                 * Properties of a GraphEntityTypeUpdate.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphEntityTypeUpdate
                 * @property {esriPBuffer.graph.INamedObjectTypeMask|null} [mask] GraphEntityTypeUpdate mask
                 * @property {esriPBuffer.graph.IEntityType|null} [entityType] GraphEntityTypeUpdate entityType
                 */
    
                /**
                 * Constructs a new GraphEntityTypeUpdate.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphEntityTypeUpdate.
                 * @implements IGraphEntityTypeUpdate
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphEntityTypeUpdate=} [properties] Properties to set
                 */
                function GraphEntityTypeUpdate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphEntityTypeUpdate mask.
                 * @member {esriPBuffer.graph.INamedObjectTypeMask|null|undefined} mask
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @instance
                 */
                GraphEntityTypeUpdate.prototype.mask = null;
    
                /**
                 * GraphEntityTypeUpdate entityType.
                 * @member {esriPBuffer.graph.IEntityType|null|undefined} entityType
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @instance
                 */
                GraphEntityTypeUpdate.prototype.entityType = null;
    
                /**
                 * Creates a new GraphEntityTypeUpdate instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.IGraphEntityTypeUpdate=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphEntityTypeUpdate} GraphEntityTypeUpdate instance
                 */
                GraphEntityTypeUpdate.create = function create(properties) {
                    return new GraphEntityTypeUpdate(properties);
                };
    
                /**
                 * Encodes the specified GraphEntityTypeUpdate message. Does not implicitly {@link esriPBuffer.graph.GraphEntityTypeUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.IGraphEntityTypeUpdate} message GraphEntityTypeUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphEntityTypeUpdate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                        $root.esriPBuffer.graph.NamedObjectTypeMask.encode(message.mask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.entityType != null && Object.hasOwnProperty.call(message, "entityType"))
                        $root.esriPBuffer.graph.EntityType.encode(message.entityType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphEntityTypeUpdate message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphEntityTypeUpdate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.IGraphEntityTypeUpdate} message GraphEntityTypeUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphEntityTypeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphEntityTypeUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphEntityTypeUpdate} GraphEntityTypeUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphEntityTypeUpdate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphEntityTypeUpdate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mask = $root.esriPBuffer.graph.NamedObjectTypeMask.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.entityType = $root.esriPBuffer.graph.EntityType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphEntityTypeUpdate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphEntityTypeUpdate} GraphEntityTypeUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphEntityTypeUpdate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphEntityTypeUpdate message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphEntityTypeUpdate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mask != null && message.hasOwnProperty("mask")) {
                        var error = $root.esriPBuffer.graph.NamedObjectTypeMask.verify(message.mask);
                        if (error)
                            return "mask." + error;
                    }
                    if (message.entityType != null && message.hasOwnProperty("entityType")) {
                        var error = $root.esriPBuffer.graph.EntityType.verify(message.entityType);
                        if (error)
                            return "entityType." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphEntityTypeUpdate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphEntityTypeUpdate} GraphEntityTypeUpdate
                 */
                GraphEntityTypeUpdate.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphEntityTypeUpdate)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphEntityTypeUpdate();
                    if (object.mask != null) {
                        if (typeof object.mask !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphEntityTypeUpdate.mask: object expected");
                        message.mask = $root.esriPBuffer.graph.NamedObjectTypeMask.fromObject(object.mask);
                    }
                    if (object.entityType != null) {
                        if (typeof object.entityType !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphEntityTypeUpdate.entityType: object expected");
                        message.entityType = $root.esriPBuffer.graph.EntityType.fromObject(object.entityType);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphEntityTypeUpdate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.GraphEntityTypeUpdate} message GraphEntityTypeUpdate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphEntityTypeUpdate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mask = null;
                        object.entityType = null;
                    }
                    if (message.mask != null && message.hasOwnProperty("mask"))
                        object.mask = $root.esriPBuffer.graph.NamedObjectTypeMask.toObject(message.mask, options);
                    if (message.entityType != null && message.hasOwnProperty("entityType"))
                        object.entityType = $root.esriPBuffer.graph.EntityType.toObject(message.entityType, options);
                    return object;
                };
    
                /**
                 * Converts this GraphEntityTypeUpdate to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphEntityTypeUpdate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphEntityTypeUpdate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphEntityTypeUpdate;
            })();
    
            graph.RelationshipTypeMask = (function() {
    
                /**
                 * Properties of a RelationshipTypeMask.
                 * @memberof esriPBuffer.graph
                 * @interface IRelationshipTypeMask
                 * @property {esriPBuffer.graph.INamedObjectTypeMask|null} [namedObjectTypeMask] RelationshipTypeMask namedObjectTypeMask
                 * @property {boolean|null} [addOriginEntityTypes] RelationshipTypeMask addOriginEntityTypes
                 * @property {boolean|null} [deleteOriginEntityTypes] RelationshipTypeMask deleteOriginEntityTypes
                 * @property {boolean|null} [addDestEntityTypes] RelationshipTypeMask addDestEntityTypes
                 * @property {boolean|null} [deleteDestEntityTypes] RelationshipTypeMask deleteDestEntityTypes
                 * @property {boolean|null} [updateStrictOrigin] RelationshipTypeMask updateStrictOrigin
                 * @property {boolean|null} [updateStrictDest] RelationshipTypeMask updateStrictDest
                 */
    
                /**
                 * Constructs a new RelationshipTypeMask.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a RelationshipTypeMask.
                 * @implements IRelationshipTypeMask
                 * @constructor
                 * @param {esriPBuffer.graph.IRelationshipTypeMask=} [properties] Properties to set
                 */
                function RelationshipTypeMask(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RelationshipTypeMask namedObjectTypeMask.
                 * @member {esriPBuffer.graph.INamedObjectTypeMask|null|undefined} namedObjectTypeMask
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.namedObjectTypeMask = null;
    
                /**
                 * RelationshipTypeMask addOriginEntityTypes.
                 * @member {boolean|null|undefined} addOriginEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.addOriginEntityTypes = null;
    
                /**
                 * RelationshipTypeMask deleteOriginEntityTypes.
                 * @member {boolean|null|undefined} deleteOriginEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.deleteOriginEntityTypes = null;
    
                /**
                 * RelationshipTypeMask addDestEntityTypes.
                 * @member {boolean|null|undefined} addDestEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.addDestEntityTypes = null;
    
                /**
                 * RelationshipTypeMask deleteDestEntityTypes.
                 * @member {boolean|null|undefined} deleteDestEntityTypes
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.deleteDestEntityTypes = null;
    
                /**
                 * RelationshipTypeMask updateStrictOrigin.
                 * @member {boolean} updateStrictOrigin
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.updateStrictOrigin = false;
    
                /**
                 * RelationshipTypeMask updateStrictDest.
                 * @member {boolean} updateStrictDest
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                RelationshipTypeMask.prototype.updateStrictDest = false;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * RelationshipTypeMask originEntityType.
                 * @member {"addOriginEntityTypes"|"deleteOriginEntityTypes"|undefined} originEntityType
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                Object.defineProperty(RelationshipTypeMask.prototype, "originEntityType", {
                    get: $util.oneOfGetter($oneOfFields = ["addOriginEntityTypes", "deleteOriginEntityTypes"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * RelationshipTypeMask destEntityType.
                 * @member {"addDestEntityTypes"|"deleteDestEntityTypes"|undefined} destEntityType
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 */
                Object.defineProperty(RelationshipTypeMask.prototype, "destEntityType", {
                    get: $util.oneOfGetter($oneOfFields = ["addDestEntityTypes", "deleteDestEntityTypes"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new RelationshipTypeMask instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipTypeMask=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.RelationshipTypeMask} RelationshipTypeMask instance
                 */
                RelationshipTypeMask.create = function create(properties) {
                    return new RelationshipTypeMask(properties);
                };
    
                /**
                 * Encodes the specified RelationshipTypeMask message. Does not implicitly {@link esriPBuffer.graph.RelationshipTypeMask.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipTypeMask} message RelationshipTypeMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipTypeMask.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.namedObjectTypeMask != null && Object.hasOwnProperty.call(message, "namedObjectTypeMask"))
                        $root.esriPBuffer.graph.NamedObjectTypeMask.encode(message.namedObjectTypeMask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.addOriginEntityTypes != null && Object.hasOwnProperty.call(message, "addOriginEntityTypes"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.addOriginEntityTypes);
                    if (message.deleteOriginEntityTypes != null && Object.hasOwnProperty.call(message, "deleteOriginEntityTypes"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deleteOriginEntityTypes);
                    if (message.addDestEntityTypes != null && Object.hasOwnProperty.call(message, "addDestEntityTypes"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.addDestEntityTypes);
                    if (message.deleteDestEntityTypes != null && Object.hasOwnProperty.call(message, "deleteDestEntityTypes"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.deleteDestEntityTypes);
                    if (message.updateStrictOrigin != null && Object.hasOwnProperty.call(message, "updateStrictOrigin"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.updateStrictOrigin);
                    if (message.updateStrictDest != null && Object.hasOwnProperty.call(message, "updateStrictDest"))
                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.updateStrictDest);
                    return writer;
                };
    
                /**
                 * Encodes the specified RelationshipTypeMask message, length delimited. Does not implicitly {@link esriPBuffer.graph.RelationshipTypeMask.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {esriPBuffer.graph.IRelationshipTypeMask} message RelationshipTypeMask message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RelationshipTypeMask.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RelationshipTypeMask message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.RelationshipTypeMask} RelationshipTypeMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipTypeMask.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.RelationshipTypeMask();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namedObjectTypeMask = $root.esriPBuffer.graph.NamedObjectTypeMask.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.addOriginEntityTypes = reader.bool();
                            break;
                        case 3:
                            message.deleteOriginEntityTypes = reader.bool();
                            break;
                        case 4:
                            message.addDestEntityTypes = reader.bool();
                            break;
                        case 5:
                            message.deleteDestEntityTypes = reader.bool();
                            break;
                        case 6:
                            message.updateStrictOrigin = reader.bool();
                            break;
                        case 7:
                            message.updateStrictDest = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RelationshipTypeMask message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.RelationshipTypeMask} RelationshipTypeMask
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RelationshipTypeMask.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RelationshipTypeMask message.
                 * @function verify
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RelationshipTypeMask.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.namedObjectTypeMask != null && message.hasOwnProperty("namedObjectTypeMask")) {
                        var error = $root.esriPBuffer.graph.NamedObjectTypeMask.verify(message.namedObjectTypeMask);
                        if (error)
                            return "namedObjectTypeMask." + error;
                    }
                    if (message.addOriginEntityTypes != null && message.hasOwnProperty("addOriginEntityTypes")) {
                        properties.originEntityType = 1;
                        if (typeof message.addOriginEntityTypes !== "boolean")
                            return "addOriginEntityTypes: boolean expected";
                    }
                    if (message.deleteOriginEntityTypes != null && message.hasOwnProperty("deleteOriginEntityTypes")) {
                        if (properties.originEntityType === 1)
                            return "originEntityType: multiple values";
                        properties.originEntityType = 1;
                        if (typeof message.deleteOriginEntityTypes !== "boolean")
                            return "deleteOriginEntityTypes: boolean expected";
                    }
                    if (message.addDestEntityTypes != null && message.hasOwnProperty("addDestEntityTypes")) {
                        properties.destEntityType = 1;
                        if (typeof message.addDestEntityTypes !== "boolean")
                            return "addDestEntityTypes: boolean expected";
                    }
                    if (message.deleteDestEntityTypes != null && message.hasOwnProperty("deleteDestEntityTypes")) {
                        if (properties.destEntityType === 1)
                            return "destEntityType: multiple values";
                        properties.destEntityType = 1;
                        if (typeof message.deleteDestEntityTypes !== "boolean")
                            return "deleteDestEntityTypes: boolean expected";
                    }
                    if (message.updateStrictOrigin != null && message.hasOwnProperty("updateStrictOrigin"))
                        if (typeof message.updateStrictOrigin !== "boolean")
                            return "updateStrictOrigin: boolean expected";
                    if (message.updateStrictDest != null && message.hasOwnProperty("updateStrictDest"))
                        if (typeof message.updateStrictDest !== "boolean")
                            return "updateStrictDest: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a RelationshipTypeMask message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.RelationshipTypeMask} RelationshipTypeMask
                 */
                RelationshipTypeMask.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.RelationshipTypeMask)
                        return object;
                    var message = new $root.esriPBuffer.graph.RelationshipTypeMask();
                    if (object.namedObjectTypeMask != null) {
                        if (typeof object.namedObjectTypeMask !== "object")
                            throw TypeError(".esriPBuffer.graph.RelationshipTypeMask.namedObjectTypeMask: object expected");
                        message.namedObjectTypeMask = $root.esriPBuffer.graph.NamedObjectTypeMask.fromObject(object.namedObjectTypeMask);
                    }
                    if (object.addOriginEntityTypes != null)
                        message.addOriginEntityTypes = Boolean(object.addOriginEntityTypes);
                    if (object.deleteOriginEntityTypes != null)
                        message.deleteOriginEntityTypes = Boolean(object.deleteOriginEntityTypes);
                    if (object.addDestEntityTypes != null)
                        message.addDestEntityTypes = Boolean(object.addDestEntityTypes);
                    if (object.deleteDestEntityTypes != null)
                        message.deleteDestEntityTypes = Boolean(object.deleteDestEntityTypes);
                    if (object.updateStrictOrigin != null)
                        message.updateStrictOrigin = Boolean(object.updateStrictOrigin);
                    if (object.updateStrictDest != null)
                        message.updateStrictDest = Boolean(object.updateStrictDest);
                    return message;
                };
    
                /**
                 * Creates a plain object from a RelationshipTypeMask message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @static
                 * @param {esriPBuffer.graph.RelationshipTypeMask} message RelationshipTypeMask
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RelationshipTypeMask.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namedObjectTypeMask = null;
                        object.updateStrictOrigin = false;
                        object.updateStrictDest = false;
                    }
                    if (message.namedObjectTypeMask != null && message.hasOwnProperty("namedObjectTypeMask"))
                        object.namedObjectTypeMask = $root.esriPBuffer.graph.NamedObjectTypeMask.toObject(message.namedObjectTypeMask, options);
                    if (message.addOriginEntityTypes != null && message.hasOwnProperty("addOriginEntityTypes")) {
                        object.addOriginEntityTypes = message.addOriginEntityTypes;
                        if (options.oneofs)
                            object.originEntityType = "addOriginEntityTypes";
                    }
                    if (message.deleteOriginEntityTypes != null && message.hasOwnProperty("deleteOriginEntityTypes")) {
                        object.deleteOriginEntityTypes = message.deleteOriginEntityTypes;
                        if (options.oneofs)
                            object.originEntityType = "deleteOriginEntityTypes";
                    }
                    if (message.addDestEntityTypes != null && message.hasOwnProperty("addDestEntityTypes")) {
                        object.addDestEntityTypes = message.addDestEntityTypes;
                        if (options.oneofs)
                            object.destEntityType = "addDestEntityTypes";
                    }
                    if (message.deleteDestEntityTypes != null && message.hasOwnProperty("deleteDestEntityTypes")) {
                        object.deleteDestEntityTypes = message.deleteDestEntityTypes;
                        if (options.oneofs)
                            object.destEntityType = "deleteDestEntityTypes";
                    }
                    if (message.updateStrictOrigin != null && message.hasOwnProperty("updateStrictOrigin"))
                        object.updateStrictOrigin = message.updateStrictOrigin;
                    if (message.updateStrictDest != null && message.hasOwnProperty("updateStrictDest"))
                        object.updateStrictDest = message.updateStrictDest;
                    return object;
                };
    
                /**
                 * Converts this RelationshipTypeMask to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.RelationshipTypeMask
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RelationshipTypeMask.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RelationshipTypeMask;
            })();
    
            graph.GraphRelationshipTypeUpdate = (function() {
    
                /**
                 * Properties of a GraphRelationshipTypeUpdate.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphRelationshipTypeUpdate
                 * @property {esriPBuffer.graph.IRelationshipTypeMask|null} [mask] GraphRelationshipTypeUpdate mask
                 * @property {esriPBuffer.graph.IRelationshipType|null} [relationshipType] GraphRelationshipTypeUpdate relationshipType
                 */
    
                /**
                 * Constructs a new GraphRelationshipTypeUpdate.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphRelationshipTypeUpdate.
                 * @implements IGraphRelationshipTypeUpdate
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphRelationshipTypeUpdate=} [properties] Properties to set
                 */
                function GraphRelationshipTypeUpdate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphRelationshipTypeUpdate mask.
                 * @member {esriPBuffer.graph.IRelationshipTypeMask|null|undefined} mask
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @instance
                 */
                GraphRelationshipTypeUpdate.prototype.mask = null;
    
                /**
                 * GraphRelationshipTypeUpdate relationshipType.
                 * @member {esriPBuffer.graph.IRelationshipType|null|undefined} relationshipType
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @instance
                 */
                GraphRelationshipTypeUpdate.prototype.relationshipType = null;
    
                /**
                 * Creates a new GraphRelationshipTypeUpdate instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.IGraphRelationshipTypeUpdate=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphRelationshipTypeUpdate} GraphRelationshipTypeUpdate instance
                 */
                GraphRelationshipTypeUpdate.create = function create(properties) {
                    return new GraphRelationshipTypeUpdate(properties);
                };
    
                /**
                 * Encodes the specified GraphRelationshipTypeUpdate message. Does not implicitly {@link esriPBuffer.graph.GraphRelationshipTypeUpdate.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.IGraphRelationshipTypeUpdate} message GraphRelationshipTypeUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphRelationshipTypeUpdate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mask != null && Object.hasOwnProperty.call(message, "mask"))
                        $root.esriPBuffer.graph.RelationshipTypeMask.encode(message.mask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.relationshipType != null && Object.hasOwnProperty.call(message, "relationshipType"))
                        $root.esriPBuffer.graph.RelationshipType.encode(message.relationshipType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphRelationshipTypeUpdate message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphRelationshipTypeUpdate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.IGraphRelationshipTypeUpdate} message GraphRelationshipTypeUpdate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphRelationshipTypeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphRelationshipTypeUpdate message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphRelationshipTypeUpdate} GraphRelationshipTypeUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphRelationshipTypeUpdate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphRelationshipTypeUpdate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mask = $root.esriPBuffer.graph.RelationshipTypeMask.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.relationshipType = $root.esriPBuffer.graph.RelationshipType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphRelationshipTypeUpdate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphRelationshipTypeUpdate} GraphRelationshipTypeUpdate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphRelationshipTypeUpdate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphRelationshipTypeUpdate message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphRelationshipTypeUpdate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mask != null && message.hasOwnProperty("mask")) {
                        var error = $root.esriPBuffer.graph.RelationshipTypeMask.verify(message.mask);
                        if (error)
                            return "mask." + error;
                    }
                    if (message.relationshipType != null && message.hasOwnProperty("relationshipType")) {
                        var error = $root.esriPBuffer.graph.RelationshipType.verify(message.relationshipType);
                        if (error)
                            return "relationshipType." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphRelationshipTypeUpdate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphRelationshipTypeUpdate} GraphRelationshipTypeUpdate
                 */
                GraphRelationshipTypeUpdate.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphRelationshipTypeUpdate)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphRelationshipTypeUpdate();
                    if (object.mask != null) {
                        if (typeof object.mask !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphRelationshipTypeUpdate.mask: object expected");
                        message.mask = $root.esriPBuffer.graph.RelationshipTypeMask.fromObject(object.mask);
                    }
                    if (object.relationshipType != null) {
                        if (typeof object.relationshipType !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphRelationshipTypeUpdate.relationshipType: object expected");
                        message.relationshipType = $root.esriPBuffer.graph.RelationshipType.fromObject(object.relationshipType);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphRelationshipTypeUpdate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @static
                 * @param {esriPBuffer.graph.GraphRelationshipTypeUpdate} message GraphRelationshipTypeUpdate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphRelationshipTypeUpdate.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mask = null;
                        object.relationshipType = null;
                    }
                    if (message.mask != null && message.hasOwnProperty("mask"))
                        object.mask = $root.esriPBuffer.graph.RelationshipTypeMask.toObject(message.mask, options);
                    if (message.relationshipType != null && message.hasOwnProperty("relationshipType"))
                        object.relationshipType = $root.esriPBuffer.graph.RelationshipType.toObject(message.relationshipType, options);
                    return object;
                };
    
                /**
                 * Converts this GraphRelationshipTypeUpdate to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphRelationshipTypeUpdate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphRelationshipTypeUpdate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphRelationshipTypeUpdate;
            })();
    
            graph.GraphNamedObjectTypeUpdateResponse = (function() {
    
                /**
                 * Properties of a GraphNamedObjectTypeUpdateResponse.
                 * @memberof esriPBuffer.graph
                 * @interface IGraphNamedObjectTypeUpdateResponse
                 * @property {esriPBuffer.graph.IError|null} [error] GraphNamedObjectTypeUpdateResponse error
                 */
    
                /**
                 * Constructs a new GraphNamedObjectTypeUpdateResponse.
                 * @memberof esriPBuffer.graph
                 * @classdesc Represents a GraphNamedObjectTypeUpdateResponse.
                 * @implements IGraphNamedObjectTypeUpdateResponse
                 * @constructor
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateResponse=} [properties] Properties to set
                 */
                function GraphNamedObjectTypeUpdateResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GraphNamedObjectTypeUpdateResponse error.
                 * @member {esriPBuffer.graph.IError|null|undefined} error
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @instance
                 */
                GraphNamedObjectTypeUpdateResponse.prototype.error = null;
    
                /**
                 * Creates a new GraphNamedObjectTypeUpdateResponse instance using the specified properties.
                 * @function create
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateResponse=} [properties] Properties to set
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse} GraphNamedObjectTypeUpdateResponse instance
                 */
                GraphNamedObjectTypeUpdateResponse.create = function create(properties) {
                    return new GraphNamedObjectTypeUpdateResponse(properties);
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeUpdateResponse message. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse.verify|verify} messages.
                 * @function encode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateResponse} message GraphNamedObjectTypeUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeUpdateResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.esriPBuffer.graph.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GraphNamedObjectTypeUpdateResponse message, length delimited. Does not implicitly {@link esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.IGraphNamedObjectTypeUpdateResponse} message GraphNamedObjectTypeUpdateResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GraphNamedObjectTypeUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeUpdateResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse} GraphNamedObjectTypeUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeUpdateResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.esriPBuffer.graph.Error.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GraphNamedObjectTypeUpdateResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse} GraphNamedObjectTypeUpdateResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GraphNamedObjectTypeUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GraphNamedObjectTypeUpdateResponse message.
                 * @function verify
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GraphNamedObjectTypeUpdateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.esriPBuffer.graph.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a GraphNamedObjectTypeUpdateResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse} GraphNamedObjectTypeUpdateResponse
                 */
                GraphNamedObjectTypeUpdateResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse)
                        return object;
                    var message = new $root.esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse.error: object expected");
                        message.error = $root.esriPBuffer.graph.Error.fromObject(object.error);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GraphNamedObjectTypeUpdateResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @static
                 * @param {esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse} message GraphNamedObjectTypeUpdateResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GraphNamedObjectTypeUpdateResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.error = null;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.esriPBuffer.graph.Error.toObject(message.error, options);
                    return object;
                };
    
                /**
                 * Converts this GraphNamedObjectTypeUpdateResponse to JSON.
                 * @function toJSON
                 * @memberof esriPBuffer.graph.GraphNamedObjectTypeUpdateResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GraphNamedObjectTypeUpdateResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GraphNamedObjectTypeUpdateResponse;
            })();
    
            return graph;
        })();
    
        return esriPBuffer;
    })();

    return $root;
})(protobuf);
